import 'package:flutter_test/flutter_test.dart';
import 'package:mocktail/mocktail.dart';
import 'package:logger/logger.dart';
import '../../../lib/src/models/models.dart';
import '../../../lib/src/repository/assessment_repository.dart';
import '../../../lib/src/service/assessment_service.dart';

// Mock dependencies
class MockAssessmentRepository extends Mock implements AssessmentRepository {}

class MockLogger extends Mock implements Logger {}

void main() {
  group('AssessmentService', () {
    late MockAssessmentRepository mockRepository;
    late MockLogger mockLogger;
    late AssessmentService service;

    setUp(() {
      mockRepository = MockAssessmentRepository();
      mockLogger = MockLogger();
      service = AssessmentService(
        repository: mockRepository,
        logger: mockLogger,
      );
    });

    group('determineLeadStatus', () {
      test('returns correct lead status for score in range', () async {
        const assessmentId = 'assessment_001';
        const score = 75.0;

        final thresholds = [
          ScoringThreshold(
            thresholdId: 'threshold_1',
            pseudoId: 'pseudo_threshold_1',
            assessmentId: assessmentId,
            minScore: 0.0,
            maxScore: 33.0,
            leadStatus: 'cold',
            createdDate: DateTime.now(),
          ),
          ScoringThreshold(
            thresholdId: 'threshold_2',
            pseudoId: 'pseudo_threshold_2',
            assessmentId: assessmentId,
            minScore: 34.0,
            maxScore: 66.0,
            leadStatus: 'warm',
            createdDate: DateTime.now(),
          ),
          ScoringThreshold(
            thresholdId: 'threshold_3',
            pseudoId: 'pseudo_threshold_3',
            assessmentId: assessmentId,
            minScore: 67.0,
            maxScore: 100.0,
            leadStatus: 'hot',
            createdDate: DateTime.now(),
          ),
        ];

        when(() => mockRepository.getThresholds(assessmentId))
            .thenAnswer((_) async => thresholds);

        final result = await service.determineLeadStatus(assessmentId, score);

        expect(result, 'hot');
        verify(() => mockRepository.getThresholds(assessmentId)).called(1);
      });

      test('returns unqualified when no threshold matches', () async {
        const assessmentId = 'assessment_001';
        const score = -10.0; // Invalid score

        when(() => mockRepository.getThresholds(assessmentId))
            .thenAnswer((_) async => []);

        final result = await service.determineLeadStatus(assessmentId, score);

        expect(result, 'unqualified');
      });

      test('returns unknown on error', () async {
        const assessmentId = 'assessment_001';
        const score = 50.0;

        when(() => mockRepository.getThresholds(assessmentId))
            .thenThrow(Exception('API Error'));

        final result = await service.determineLeadStatus(assessmentId, score);

        expect(result, 'unknown');
      });
    });

    group('validateAnswers', () {
      test('validates required questions are answered', () {
        final questions = [
          AssessmentQuestion(
            questionId: 'q1',
            pseudoId: 'pq1',
            assessmentId: 'a1',
            questionSequence: 1,
            questionType: 'text',
            questionText: 'Required Question',
            isRequired: true,
            createdDate: DateTime.now(),
          ),
          AssessmentQuestion(
            questionId: 'q2',
            pseudoId: 'pq2',
            assessmentId: 'a1',
            questionSequence: 2,
            questionType: 'text',
            questionText: 'Optional Question',
            isRequired: false,
            createdDate: DateTime.now(),
          ),
        ];

        final answers = {'q2': 'answer2'}; // Missing required q1

        final result = service.validateAnswers(questions, answers);

        expect(result.isValid, false);
        expect(result.errors.length, 1);
        expect(result.errors[0], contains('Required Question'));
      });

      test('validates all required questions are answered', () {
        final questions = [
          AssessmentQuestion(
            questionId: 'q1',
            pseudoId: 'pq1',
            assessmentId: 'a1',
            questionSequence: 1,
            questionType: 'text',
            questionText: 'Required Question 1',
            isRequired: true,
            createdDate: DateTime.now(),
          ),
          AssessmentQuestion(
            questionId: 'q2',
            pseudoId: 'pq2',
            assessmentId: 'a1',
            questionSequence: 2,
            questionType: 'text',
            questionText: 'Required Question 2',
            isRequired: true,
            createdDate: DateTime.now(),
          ),
        ];

        final answers = {'q1': 'answer1', 'q2': 'answer2'};

        final result = service.validateAnswers(questions, answers);

        expect(result.isValid, true);
        expect(result.errors.length, 0);
      });
    });

    group('getAssessmentProgress', () {
      test('calculates assessment progress correctly', () async {
        const assessmentId = 'assessment_001';

        final assessment = Assessment(
          assessmentId: assessmentId,
          pseudoId: 'pseudo_a1',
          ownerPartyId: 'company_001',
          assessmentName: 'Test Assessment',
          description: 'Test',
          status: 'ACTIVE',
          createdDate: DateTime.now(),
        );

        final questions = [
          AssessmentQuestion(
            questionId: 'q1',
            pseudoId: 'pq1',
            assessmentId: assessmentId,
            questionSequence: 1,
            questionType: 'text',
            questionText: 'Q1',
            isRequired: true,
            createdDate: DateTime.now(),
          ),
          AssessmentQuestion(
            questionId: 'q2',
            pseudoId: 'pq2',
            assessmentId: assessmentId,
            questionSequence: 2,
            questionType: 'text',
            questionText: 'Q2',
            isRequired: true,
            createdDate: DateTime.now(),
          ),
        ];

        when(() => mockRepository.getAssessment(assessmentId))
            .thenAnswer((_) async => assessment);
        when(() => mockRepository.getQuestions(assessmentId))
            .thenAnswer((_) async => questions);
        when(() => mockRepository.getThresholds(assessmentId))
            .thenAnswer((_) async => []);

        final progress = await service.getAssessmentProgress(assessmentId);

        expect(progress.assessmentId, assessmentId);
        expect(progress.totalQuestions, 2);
        expect(progress.requiredQuestions, 2);
      });
    });

    group('scoreAssessment', () {
      test('calculates score and determines lead status', () async {
        const assessmentId = 'assessment_001';
        const score = 75.0;
        const answers = {'q1': 'opt1', 'q2': 'opt2'};

        when(() => mockRepository.calculateScore(assessmentId, answers))
            .thenAnswer((_) async => score);

        final thresholds = [
          ScoringThreshold(
            thresholdId: 'threshold_3',
            pseudoId: 'pseudo_threshold_3',
            assessmentId: assessmentId,
            minScore: 67.0,
            maxScore: 100.0,
            leadStatus: 'hot',
            createdDate: DateTime.now(),
          ),
        ];

        when(() => mockRepository.getThresholds(assessmentId))
            .thenAnswer((_) async => thresholds);

        final result = await service.scoreAssessment(assessmentId, answers);

        expect(result.score, score);
        expect(result.leadStatus, 'hot');
      });
    });

    group('getAssessmentResults', () {
      test('retrieves results with pagination', () async {
        const assessmentId = 'assessment_001';

        final results = [
          AssessmentResult(
            resultId: 'result_1',
            pseudoId: 'pseudo_result_1',
            assessmentId: assessmentId,
            ownerPartyId: 'company_001',
            score: 85.0,
            leadStatus: 'hot',
            respondentName: 'John Doe',
            respondentEmail: 'john@example.com',
            answersData: '{}',
            createdDate: DateTime.now(),
          ),
        ];

        when(() => mockRepository.getResults(
              assessmentId,
              start: 0,
              limit: 20,
            )).thenAnswer((_) async => results);

        final page = await service.getAssessmentResults(
          assessmentId,
          page: 1,
          pageSize: 20,
        );

        expect(page.results.length, 1);
        expect(page.page, 1);
        expect(page.pageSize, 20);
      });
    });

    group('analyzeResults', () {
      test('calculates analytics from results', () async {
        const assessmentId = 'assessment_001';

        final results = [
          AssessmentResult(
            resultId: 'result_1',
            pseudoId: 'pseudo_result_1',
            assessmentId: assessmentId,
            ownerPartyId: 'company_001',
            score: 80.0,
            leadStatus: 'hot',
            respondentName: 'John Doe',
            respondentEmail: 'john@example.com',
            answersData: '{}',
            createdDate: DateTime.now(),
          ),
          AssessmentResult(
            resultId: 'result_2',
            pseudoId: 'pseudo_result_2',
            assessmentId: assessmentId,
            ownerPartyId: 'company_001',
            score: 60.0,
            leadStatus: 'warm',
            respondentName: 'Jane Smith',
            respondentEmail: 'jane@example.com',
            answersData: '{}',
            createdDate: DateTime.now(),
          ),
          AssessmentResult(
            resultId: 'result_3',
            pseudoId: 'pseudo_result_3',
            assessmentId: assessmentId,
            ownerPartyId: 'company_001',
            score: 30.0,
            leadStatus: 'cold',
            respondentName: 'Bob Wilson',
            respondentEmail: 'bob@example.com',
            answersData: '{}',
            createdDate: DateTime.now(),
          ),
        ];

        when(() => mockRepository.getResults(
              assessmentId,
              start: 0,
              limit: 100,
            )).thenAnswer((_) async => results);

        final analytics = await service.analyzeResults(assessmentId);

        expect(analytics.totalResponses, 3);
        expect(analytics.averageScore, 56.67, precision: 0.01); // (80+60+30)/3
        expect(analytics.leadStatusDistribution['hot'], 1);
        expect(analytics.leadStatusDistribution['warm'], 1);
        expect(analytics.leadStatusDistribution['cold'], 1);
        expect(analytics.mostCommonLeadStatus, isNotNull);
      });

      test('returns empty analytics for no results', () async {
        const assessmentId = 'assessment_001';

        when(() => mockRepository.getResults(
              assessmentId,
              start: 0,
              limit: 100,
            )).thenAnswer((_) async => []);

        final analytics = await service.analyzeResults(assessmentId);

        expect(analytics.totalResponses, 0);
        expect(analytics.averageScore, 0.0);
      });
    });
  });
}
