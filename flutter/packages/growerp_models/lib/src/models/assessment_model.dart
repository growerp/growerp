import 'package:json_annotation/json_annotation.dart';
import 'assessment_question_model.dart';
import 'scoring_threshold_model.dart';

part 'assessment_model.g.dart';

/// Converts Unix timestamp (milliseconds) to DateTime
class TimestampConverter implements JsonConverter<DateTime, int> {
  const TimestampConverter();

  @override
  DateTime fromJson(int timestamp) =>
      DateTime.fromMillisecondsSinceEpoch(timestamp);

  @override
  int toJson(DateTime dateTime) => dateTime.millisecondsSinceEpoch;
}

/// Converts nullable Unix timestamp (milliseconds) to nullable DateTime
class NullableTimestampConverter implements JsonConverter<DateTime?, int?> {
  const NullableTimestampConverter();

  @override
  DateTime? fromJson(int? timestamp) =>
      timestamp != null ? DateTime.fromMillisecondsSinceEpoch(timestamp) : null;

  @override
  int? toJson(DateTime? dateTime) => dateTime?.millisecondsSinceEpoch;
}

/// Assessment model representing a single assessment/survey
///
/// Supports dual-ID strategy:
/// - assessmentId: System-wide unique identifier
/// - pseudoId: Tenant-unique, user-facing identifier (optional, generated by backend if not provided)
///
/// When fetched via get#Assessment service, includes nested questions and thresholds
@JsonSerializable(explicitToJson: true)
class Assessment {
  /// System-wide unique identifier
  final String? assessmentId;

  /// Tenant-unique identifier (user-facing, used in URLs)
  /// Optional - will be generated by backend if not provided during creation/update
  final String? pseudoId;

  /// Assessment name/title
  @JsonKey(defaultValue: 'Unnamed Assessment')
  final String assessmentName;

  /// Assessment description/instructions
  final String? description;

  /// Assessment status: ACTIVE, INACTIVE, DRAFT
  @JsonKey(defaultValue: 'ACTIVE')
  final String status;

  /// Timestamp when created
  @NullableTimestampConverter()
  final DateTime? createdDate;

  /// Username who created this assessment
  final String? createdByUserLogin;

  /// Timestamp when last modified
  @NullableTimestampConverter()
  final DateTime? lastModifiedDate;

  /// Username who last modified this assessment
  final String? lastModifiedByUserLogin;

  /// Questions with nested options (only present when fetched via get#Assessment)
  final List<AssessmentQuestion>? questions;

  /// Scoring thresholds (only present when fetched via get#Assessment)
  final List<ScoringThreshold>? thresholds;

  const Assessment({
    this.assessmentId,
    this.pseudoId,
    required this.assessmentName,
    this.description,
    required this.status,
    this.createdDate,
    this.createdByUserLogin,
    this.lastModifiedDate,
    this.lastModifiedByUserLogin,
    this.questions,
    this.thresholds,
  });

  /// Creates a copy of this assessment with optionally replaced fields
  Assessment copyWith({
    String? assessmentId,
    String? pseudoId,
    String? assessmentName,
    String? description,
    String? status,
    DateTime? createdDate,
    String? createdByUserLogin,
    DateTime? lastModifiedDate,
    String? lastModifiedByUserLogin,
    List<AssessmentQuestion>? questions,
    List<ScoringThreshold>? thresholds,
  }) {
    return Assessment(
      assessmentId: assessmentId ?? this.assessmentId,
      pseudoId: pseudoId ?? this.pseudoId,
      assessmentName: assessmentName ?? this.assessmentName,
      description: description ?? this.description,
      status: status ?? this.status,
      createdDate: createdDate ?? this.createdDate,
      createdByUserLogin: createdByUserLogin ?? this.createdByUserLogin,
      lastModifiedDate: lastModifiedDate ?? this.lastModifiedDate,
      lastModifiedByUserLogin:
          lastModifiedByUserLogin ?? this.lastModifiedByUserLogin,
      questions: questions ?? this.questions,
      thresholds: thresholds ?? this.thresholds,
    );
  }

  /// Converts JSON to Assessment object
  factory Assessment.fromJson(Map<String, dynamic> json) =>
      _$AssessmentFromJson(json['assessment'] ?? json);

  /// Converts Assessment object to JSON
  Map<String, dynamic> toJson() => _$AssessmentToJson(this);

  @override
  String toString() =>
      'Assessment(id: $assessmentId, name: $assessmentName, status: $status)';

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Assessment &&
          runtimeType == other.runtimeType &&
          assessmentId == other.assessmentId;

  @override
  int get hashCode => assessmentId.hashCode;
}

/// List wrapper for Assessment objects
@JsonSerializable()
class Assessments {
  final List<Assessment> assessments;

  const Assessments({required this.assessments});

  factory Assessments.fromJson(Map<String, dynamic> json) =>
      _$AssessmentsFromJson(json);
  Map<String, dynamic> toJson() => _$AssessmentsToJson(this);
}
