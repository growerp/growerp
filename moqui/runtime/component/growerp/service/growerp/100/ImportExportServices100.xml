<?xml version="1.0" encoding="UTF-8"?>
<!--
This software is in the public domain under CC0 1.0 Universal plus a 
Grant of Patent License.

To the extent possible under law, the author(s) have dedicated all
copyright and related and neighboring rights to this software to the
public domain worldwide. This software is distributed without any
warranty.

You should have received a copy of the CC0 Public Domaicrn Dedication
along with this software (see the LICENSE.md file). If not, see
<http://creativecommons.org/publicdomain/zero/1.0/>.
-->
<services xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:noNamespaceSchemaLocation="http://moqui.org/xsd/service-definition-2.1.xsd">

    <!-- used by the conversion framework in the dart package growerp import client-->
    <service verb="import" noun="ItemTypes">
        <description> Import ItemTypes</description>
        <in-parameters>
            <parameter name="itemTypes" required="true" type="List" />
        </in-parameters>
        <actions>
            <script>System.out.println(">>>>importing ${itemTypes?.size()} item types")</script>
            <set field="itemTypesImported" type="Integer" value="0" />
            <service-call name="growerp.100.GeneralServices100.get#RelatedCompanyAndOwner"
                out-map="context" />
            <!-- delete existing -->
            <entity-delete-by-condition entity-name="mantle.ledger.config.ItemTypeGlAccount">
                <econdition field-name="organizationPartyId" from="companyPartyId" />
            </entity-delete-by-condition>
            <!-- create new -->
            <iterate list="itemTypes" entry="itemType">
                <entity-find entity-name="growerp.ledger.account.GlAccountAndOrganization"
                    list="glAccounts">
                    <econdition field-name="partyId" from="companyPartyId" />
                    <econdition field-name="accountCode" from="itemType.accountCode" />
                </entity-find>
                <if condition="!glAccounts">
                    <script>System.out.println(">>>Could not find accountCode: ${itemType.accountCode} for company: $companyPartyId")</script>
                    <else>
                        <service-call name="create#mantle.ledger.config.ItemTypeGlAccount"
                            in-map="[
                                itemTypeEnumId: itemType.itemTypeId,
                                organizationPartyId: companyPartyId,
                                direction: itemType.direction,
                                glAccountId: glAccounts[0].glAccountId,
                            ]" />
                        <script>itemTypesImported++;</script>
                    </else>
                </if>
            </iterate>
            <if condition="!ec.message.hasError()">
                <script>System.out.println(">>>${itemTypesImported} itemTypes imported")</script>
            </if>
        </actions>
    </service>

    <service verb="import" noun="PaymentTypes">
        <description> Import PaymentTypes</description>
        <in-parameters>
            <parameter name="paymentTypes" required="true" type="List" />
        </in-parameters>
        <actions>
            <script>System.out.println(">>>>importing ${paymentTypes?.size()} paymentTypes")</script>
            <set field="paymentTypesImported" type="Integer" value="0" />
            <set field="paymentTypesIgnored" type="Integer" value="0" />
            <service-call name="growerp.100.GeneralServices100.get#RelatedCompanyAndOwner"
                out-map="context" />
            <!-- delete existing -->
            <entity-delete-by-condition entity-name="mantle.ledger.config.PaymentTypeGlAccount">
                <econdition field-name="organizationPartyId" from="companyPartyId" />
            </entity-delete-by-condition>
            <!-- create new -->
            <iterate list="paymentTypes" entry="paymentType">
                <set field="glAccountId" from="null" />
                <if
                    condition="paymentType.accountCode &amp;&amp; !paymentType.accountCode.isEmpty()">
                    <entity-find entity-name="growerp.ledger.account.GlAccountAndOrganization"
                        list="glAccounts">
                        <econdition field-name="partyId" from="companyPartyId" />
                        <econdition field-name="accountCode" from="paymentType.accountCode" />
                    </entity-find>
                    <if condition="!glAccounts">
                        <return error="true"
                            message="Could not find accountCode: ${paymentType.accountCode} for company: $companyPartyId" />
                        <else>
                            <set field="glAccountId" from="glAccounts[0].glAccountId" />
                        </else>
                    </if>
                    <service-call name="create#mantle.ledger.config.PaymentTypeGlAccount"
                        in-map="[   paymentTypeEnumId: paymentType.paymentTypeId,
                                organizationPartyId: companyPartyId,
                                isPayable: paymentType.isPayable == true ? 'Y' : 'N',
                                isApplied: paymentType.isApplied == true ? 'Y' : 'N',
                                glAccountId: glAccountId,
                            ]" />
                    <script>paymentTypesImported++;</script>
                    <else>
                        <script>System.out.println(">>> PaymentType ${paymentType.paymentTypeId} ignored: GLAccount empty")</script>
                        <script>paymentTypesIgnored++;</script>
                    </else>
                </if>
            </iterate>
            <if condition="!ec.message.hasError()">
                <script>System.out.println(">>>${paymentTypesImported} paymentTypes imported ${paymentTypesIgnored} ignored")</script>
            </if>
        </actions>
    </service>

    <service verb="import" noun="GlAccounts">
        <description> Import GlAccounts</description>
        <in-parameters>
            <parameter name="glAccounts" required="true" type="List" />
            <parameter name="classificationId" />
        </in-parameters>
        <actions>
            <script>System.out.println(">>>>importing ${glAccounts?.size()} GL Accounts")</script>
            <set field="glAccountsImported" type="Integer" value="0" />
            <set field="glAccountsUpdated" type="Integer" value="0" />
            <service-call name="growerp.100.GeneralServices100.get#RelatedCompanyAndOwner"
                out-map="relComp" />
            <!-- delete existing transactions only initial if present-->
            <entity-find entity-name="mantle.ledger.transaction.AcctgTrans" list="transList">
                <econdition field-name="organizationPartyId" from="relComp.companyPartyId" />
            </entity-find>
            <if condition="transList.size() &gt; 1">
                <return error="true"
                    message="Can only delete ledger when when not more than the initial settiung of posted balance." />
            </if>
            <if condition="!transList.isEmpty()">
                <entity-delete-by-condition
                    entity-name="mantle.ledger.transaction.AcctgTransEntry">
                    <econdition field-name="acctgTransId" from="transList[0].acctgTransId" />
                </entity-delete-by-condition>
                <entity-delete-by-condition entity-name="mantle.ledger.transaction.AcctgTrans">
                    <econdition field-name="acctgTransId" from="transList[0].acctgTransId" />
                </entity-delete-by-condition>
            </if>
            <!-- delete existing ledger only if input file has account description and class 
                when not assume an update of the initial posting values-->
            <if
                condition="!glAccounts[0].accountName.isEmpty() &amp;&amp; !glAccounts[0].accountClass.description.isEmpty()">
                <entity-find entity-name="mantle.ledger.account.GlAccountAndOrganization"
                    list="glAccountsOrg">
                    <econdition field-name="organizationPartyId" from="relComp.companyPartyId" />
                    <select-field field-name="glAccountId" />
                </entity-find>
                <entity-delete-by-condition
                    entity-name="mantle.ledger.account.GlAccountOrganization">
                    <econdition field-name="organizationPartyId" from="relComp.companyPartyId" />
                </entity-delete-by-condition>
                <entity-delete-by-condition
                    entity-name="mantle.ledger.account.GlAccount">
                    <econdition field-name="glAccountId" operator="in" from="glAccountsOrg" />
                </entity-delete-by-condition>
                <!-- delete item types-->
                <entity-delete-by-condition entity-name="mantle.ledger.config.ItemTypeGlAccount">
                    <econdition field-name="organizationPartyId" from="relComp.companyPartyId" />
                </entity-delete-by-condition>
                <!-- delete payment types-->
                <entity-delete-by-condition entity-name="mantle.ledger.config.PaymentTypeGlAccount">
                    <econdition field-name="organizationPartyId" from="relComp.companyPartyId" />
                </entity-delete-by-condition>
            </if>
            <!-- create new accounts and collect posted balances for new transactions-->
            <set field="transactions" from="[]" />
            <iterate list="glAccounts" entry="newGlAccount">
                <if condition="newGlAccount.accountCode.isEmpty()">
                    <continue />
                </if>
                <!-- check if glaccount exist update just posted value is present -->
                <entity-find entity-name="mantle.ledger.account.GlAccountAndOrganization"
                    list="glAccountsOrg">
                    <econdition field-name="organizationPartyId" from="relComp.companyPartyId" />
                    <econdition field-name="accountCode" from="newGlAccount.accountCode" />
                </entity-find>
                <if condition="!glAccountsOrg">
                    <service-call name="growerp.100.AccountingServices100.create#GlAccount"
                        in-map="[glAccount: newGlAccount]"
                        out-map="createdGlAccount" />
                    <script>glAccountsImported++</script>
                    <set field="newGlAccountId" from="createdGlAccount.glAccount.glAccountId" />
                    <set field="isDebit" from="createdGlAccount.glAccount.isDebit" />
                    <else>
                        <set field="newGlAccountId" from="glAccountsOrg[0].glAccountId" />
                        <set field="isDebit" from="glAccountsOrg[0].isDebit == 'Y' ? true : false"
                            type="Boolean" />
                        <script>System.out.println(">>>>importing existing GlAccount: ${newGlAccount?.glAccountId}")</script>
                        <script>glAccountsUpdated++</script>
                    </else>
                </if>
                <!-- collect posted balances -->
                <if condition="newGlAccount.postedBalance">
                    <set field="isPositive" value="true" type="Boolean" />
                    <if condition="newGlAccount.postedBalance.startsWith('-')">
                        <set field="isPositive" value="false" type="Boolean" />
                    </if>
                    <script>transactions.add([
                        isDebit: isDebit == isPositive 
                            ? isDebit : !isDebit,
                        price: new BigDecimal(newGlAccount.postedBalance.replace('-','')),
                        glAccount: [glAccountId: newGlAccountId],
                        ])</script>
                </if>
            </iterate>
            <!-- create posted balance in initial transaction-->
            <if condition="!transactions.isEmpty()">
                <service-call name="growerp.100.FinDocServices100.create#FinDoc"
                    in-map="finDoc: [docType: 'transaction', sales: 'true', isPosted: true,
                                            description: 'Initial balance',
                                            items: transactions]"
                    out-map="context" />
            </if>
            <!-- recalculate posted summary-->
            <service-call name="growerp.100.AccountingServices100.recalculate#GlAccountOrgSummaries"
                in-map="companyPartyId: relComp.companyPartyId" />
            <if condition="!ec.message.hasError()">
                <script>System.out.println(">>>${glAccountsImported} glAccounts imported, updated: ${glAccountsUpdated}")</script>
            </if>
        </actions>
    </service>

    <service verb="import" noun="Companies">
        <in-parameters>
            <parameter name="companies" required="true" type="List" />
            <parameter name="classificationId" />
        </in-parameters>
        <actions>
            <script>System.out.println(">>>===== importing ${companies?.size()} companies")</script>
            <service-call
                name="growerp.100.GeneralServices100.get#RelatedCompanyAndOwner"
                out-map="context" />
            <set field="companiesImported" type="Integer" value="0" />
            <iterate list="companies" entry="company">
                <if condition="company.partyId == '_MOD_'"><!-- used in automated test-->
                    <entity-find entity-name="growerp.party.OwnerCompanyDetailAndEmployee"
                        list="parties">
                        <econdition field-name="ownerPartyId" from="ownerPartyId" />
                        <econdition field-name="companyName" operator="like"
                            value="${company.name}%" />
                    </entity-find>
                    <if condition="!parties.isEmpty()">
                        <set field="company.partyId" from="parties[0].companyPartyId" />
                        <service-call name="growerp.100.PartyServices100.update#Company"
                            in-map="[company: company]" />
                        <script>companiesImported++;</script>
                    </if>
                    <else>
                        <if condition="!company.role">
                            <script>System.out.println(">>>Company id: ${company.pseudoId} ${company.name} not processed, role is missing!")</script>
                            <continue />
                        </if>
                        <if condition="!company.name">
                            <script>System.out.println(">>>Company id: ${company.pseudoId} ${company.name} name is missing, set to pseudoId!")</script>
                            <set field="company.name" from="company.pseudoId" />
                        </if>
                        <if
                            condition="company.email &amp;&amp; company.email != '' &amp;&amp; !org.apache.commons.validator.routines.EmailValidator.getInstance().isValid(company.email)">
                            <script>System.out.println(">>>Company id: ${company.pseudoId} ${company.name} email: ${company.email} is not valid")</script>
                            <set field="company.email" value="" />
                        </if>
                        <!-- main company already exist so need update -->
                        <if condition="company.role == 'OrgInternal'">
                            <entity-find entity-name="growerp.party.OwnerCompanyDetailAndEmployee"
                                list="mainCompanies">
                                <econdition field-name="companyRole" value="OrgInternal" />
                                <econdition field-name="ownerPartyId" from="ownerPartyId" />
                            </entity-find>
                            <if condition="mainCompanies.isEmpty()">
                                <script>System.out.println(">>>Main company supplied but cannot find within owner: $ownerPartyId")</script>
                                <else>
                                    <set field="company.partyId"
                                        from="mainCompanies[0].companyPartyId" />
                                    <service-call
                                        name="growerp.100.PartyServices100.update#Company"
                                        in-map="[company: company]" />
                                    <script>companiesImported++;</script>
                                    <continue />
                                </else>
                            </if>
                        </if>
                        <!-- check if company already exist -->
                        <entity-find entity-name="mantle.party.Party" list="parties">
                            <econdition field-name="pseudoId" from="company.pseudoId" />
                            <econdition field-name="ownerPartyId" from="ownerPartyId" />
                        </entity-find>
                        <if condition="!parties.isEmpty()">
                            <then>
                                <entity-find entity-name="mantle.party.PartyRole" list="roles">
                                    <econdition field-name="partyId" from="parties[0].partyId" />
                                    <econdition field-name="roleTypeId" from="company.role" />
                                </entity-find>
                                <if condition="roles.isEmpty()">
                                    <service-call name="create#mantle.party.PartyRole"
                                        in-map="[   partyId: parties[0].partyId,
                                                        roleTypeId: company.role]" />
                                    <else>
                                        <script>System.out.println(">>>Company: ${company.name} not processed, pseudoId: ${company.pseudoId} ${company.role} already exist!")</script>
                                    </else>
                                </if>
                            </then>
                            <else>
                                <service-call
                                    name="growerp.100.PartyServices100.create#Company"
                                    in-map="[company: company]" />
                                <script>companiesImported++;</script>
                            </else>
                        </if>
                    </else>
                </if>
            </iterate>
            <if condition="!ec.message.hasError()">
                <script>System.out.println(">>>===== $companiesImported companies imported")</script>
            </if>
        </actions>
    </service>

    <service verb="import" noun="Users">
        <in-parameters>
            <parameter name="users" required="true" type="List" />
        </in-parameters>
        <actions>
            <script>System.out.println(">>>>importing ${users?.size()} users")</script>
            <set field="usersImported" type="Integer" value="0" />
            <iterate list="users" entry="user">
                <service-call name="growerp.100.PartyServices100.create#User"
                    in-map="[user: user]" />
                <script>usersImported++;</script>
            </iterate>
            <if condition="!ec.message.hasError()">
                <script>System.out.println(">>>${usersImported} users imported")</script>
            </if>
        </actions>
    </service>

    <service verb="import" noun="Products">
        <in-parameters>
            <parameter name="products" required="true" type="List" />
            <parameter name="classificationId" required="true" />
        </in-parameters>
        <actions>
            <script>System.out.println(">>>>importing ${products?.size()} products")</script>
            <set field="productsImported" type="Integer" value="0" />
            <service-call name="growerp.100.GeneralServices100.get#RelatedCompanyAndOwner"
                out-map="relComp" />
            <script>ec.user.setEffectiveTime(Timestamp.valueOf("1999-01-01 00:00:00"))</script>
            <iterate list="products" entry="product">
                <!-- check if related category exist using name, if yes use these-->
                <iterate list="product.categories" entry="category">
                    <entity-find entity-name="mantle.product.category.ProductCategory"
                        list="foundCategories">
                        <econdition field-name="categoryName" from="category.categoryName" />
                        <econdition field-name="ownerPartyId" from="relComp.ownerPartyId" />
                    </entity-find>
                    <if condition="foundCategories">
                        <set field="category.categoryId"
                            from="foundCategories[0].productCategoryId" />
                    </if>
                </iterate>
                <entity-find entity-name="mantle.product.Product" list="products">
                    <econdition field-name="pseudoId" from="product.pseudoId" />
                    <econdition field-name="ownerPartyId" from="relComp.ownerPartyId" />
                </entity-find>
                <if condition="!products">
                    <service-call name="growerp.100.CatalogServices100.create#Product"
                        out-map="result"
                        in-map="[product: product, classificationId: classificationId]" />
                    <script>productsImported++</script>
                </if>
            </iterate>
            <if condition="!ec.message.hasError()">
                <script>System.out.println(">>>${productsImported} products imported")</script>
            </if>
        </actions>
    </service>

    <service verb="import" noun="Categories">
        <in-parameters>
            <parameter name="categories" required="true" type="List" />
            <parameter name="classificationId" />
        </in-parameters>
        <actions>
            <script>System.out.println(">>>>importing ${categories?.size()} categories")</script>
            <script>ec.user.setEffectiveTime(Timestamp.valueOf("1999-01-01 00:00:00"))</script>
            <iterate list="categories" entry="category">
                <service-call name="growerp.100.CatalogServices100.create#ProductCategory"
                    in-map="[category: category, classificationId: classificationId]" />
            </iterate>
            <if condition="!ec.message.hasError()">
                <script>System.out.println(">>>${categories?.size()} categories imported")</script>
            </if>
        </actions>
    </service>

    <service verb="import" noun="Assets">
        <in-parameters>
            <parameter name="assets" required="true" type="List" />
            <parameter name="classificationId" />
        </in-parameters>
        <actions>
            <script>System.out.println(">>>>importing ${assets?.size()} assets")</script>
            <iterate list="assets" entry="asset">
                <service-call name="growerp.100.InventoryServices100.create#Asset"
                    out-map="result"
                    in-map="[asset: asset, classificationId: classificationId]" />
            </iterate>
            <if condition="!ec.message.hasError()">
                <script>System.out.println(">>>${assets?.size()} assets imported")</script>
            </if>
        </actions>
    </service>

    <service verb="import" noun="FinDocs">
        <in-parameters>
            <parameter name="finDocs" required="true" type="List" />
            <parameter name="classificationId" />
        </in-parameters>
        <actions>
            <script>System.out.println(">>>>importing ${finDocs[0].sales == true ? 'Sales' : 'Purchase'} ${finDocs[0].docType} ${finDocs?.size()} finDocs")</script>
            <set field="finDocsImported" type="Integer" value="0" />
            <set field="companiesCreated" type="Integer" value="0" />
            <service-call out-map="context"
                name="growerp.100.GeneralServices100.get#RelatedCompanyAndOwner" />
            <!-- check if we have a timeperiod here just for transactions.....-->
            <if condition="finDocs[0].docType == 'transaction'">
                <!-- date-filter does not seem to work here date: 2010-12-31 not found!-->
                <entity-find entity-name="mantle.party.time.TimePeriod" list="periods">
                    <econdition field-name="partyId" from="companyPartyId" />
                    <econdition field-name="fromDate" operator="less-equals"
                        from="Timestamp.valueOf(finDocs[0].creationDate)" />
                    <econdition field-name="thruDate" operator="greater-equals"
                        from="Timestamp.valueOf(finDocs[0].creationDate)" />
                </entity-find>
                <!-- when not yet create all until next year -->
                <if condition="!periods">
                    <script>System.out.println(">>>Creating time periods starting with ${finDocs[0].creationDate.substring(0,4)} for company $companyPartyId")</script>
                    <!-- delete existing timeperiods-->
                    <entity-find entity-name="mantle.party.time.TimePeriod" list="periods">
                        <econdition field-name="partyId" from="companyPartyId" />
                        <order-by field-name="-timePeriodId" />
                    </entity-find>
                    <iterate list="periods.timePeriodId" entry="id">
                        <entity-delete-by-condition entity-name="mantle.party.time.TimePeriod">
                            <econdition field-name="partyId" from="companyPartyId" />
                            <econdition field-name="timePeriodId" from="id" />
                        </entity-delete-by-condition>
                    </iterate>
                    <!-- create new yearly, quartely, monthly periods until next year-->
                    <set field="nextYearInt"
                        from="((Calendar) ec.user.nowCalendar).get(Calendar.YEAR) + 1" />
                    <set field="lastYear" from="ec.l10n.format(nextYearInt, '0000')" />

                    <!-- start year from first tranaction ordered by date -->
                    <set field="curYear" from="finDocs[0].creationDate.substring(0,4)" />
                    <set field="prevPeriodId" from="null" />
                    <while condition="curYear &lt;= lastYear">
                        <set field="fromDate"
                            from="ec.l10n.parseDate(curYear + '-01-01', 'yyyy-MM-dd')" />
                        <service-call name="mantle.party.TimeServices.getOrCreate#TimePeriod"
                            out-map="curYearOut"
                            in-map="[partyId:companyPartyId, timePeriodTypeId:'FiscalYear', fromDate:fromDate, previousPeriodId:prevPeriodId]" />
                        <service-call name="mantle.party.TimeServices.get#DescendantPeriods"
                            out-map="quartersOut"
                            in-map="[parentPeriodId:curYearOut.timePeriodId, timePeriodTypeId:'FiscalQuarter', createMissing:true]" />
                        <iterate list="quartersOut.timePeriodList" entry="quarterPeriod">
                            <service-call name="mantle.party.TimeServices.get#DescendantPeriods"
                                out-map="quartersOut"
                                in-map="[parentPeriodId:quarterPeriod.timePeriodId, timePeriodTypeId:'FiscalMonth', createMissing:true]" />
                        </iterate>
                        <set field="prevPeriodId" from="curYearOut.timePeriodId" />
                        <set field="curYear" from="((curYear as int) + 1) as String" />
                    </while>
                    <entity-find-count entity-name="mantle.party.time.TimePeriod"
                        count-field="periods">
                        <econdition field-name="partyId" from="companyPartyId" />
                    </entity-find-count>
                </if>
            </if>
            <iterate list="finDocs" entry="finDoc">
                <!-- change system date -->
                <script>ec.user.setEffectiveTime(Timestamp.valueOf(finDoc.creationDate))</script>
                <!-- find partyId of other company-->
                <if condition="!finDoc.otherCompany.pseudoId &amp;&amp; finDoc.otherCompany.name">
                    <set field="finDoc.otherCompany.pseudoId" from="finDoc.otherCompany.name" />
                </if>
                <!-- translate pseudoId to moqui Id -->
                <if condition="finDoc.otherCompany &amp;&amp; finDoc.otherCompany.pseudoId">
                    <entity-find entity-name="mantle.party.Party" list="parties">
                        <econdition field-name="pseudoId" from="finDoc.otherCompany.pseudoId" />
                        <econdition field-name="ownerPartyId" from="ownerPartyId" />
                    </entity-find>
                    <if condition="parties">
                        <!--log
                            message="=====result from: ${finDoc.otherCompany.pseudoId} to ${parties[0].partyId}" /-->
                        <set field="finDoc.otherCompany.partyId" from="parties[0].partyId" />
                        <else-if
                            condition="finDoc.otherCompany.pseudoId &amp;&amp; finDoc.otherCompany.name">
                            <!-- create company -->
                            <if condition="finDoc.sales">
                                <set field="finDoc.otherCompany.role" value="Customer" />
                                <else>
                                    <set field="finDoc.otherCompany.role" value="Supplier" />
                                </else>
                            </if>
                            <service-call name="growerp.100.PartyServices100.create#Company"
                                in-map="[company: finDoc.otherCompany, ownerPartyId: ownerPartyId]"
                                out-map="context" />
                            <set field="finDoc.otherCompany.partyId" from="company.partyId" />
                            <script>companiesCreated++</script>
                        </else-if>
                        <else>
                            <script>System.out.println(">>>Import finDocId ${finDoc.pseudoId} company pseudoId: ${finDoc.otherCompany.pseudoId} not found under owner: $ownerPartyId : need also name to add")</script>
                        </else>
                    </if>
                </if>
                <!-- transaction posted-->
                <if condition="finDoc.docType == 'transaction'">
                    <set field="finDoc.isPosted" value="false" type="Boolean" />
                </if>
                <!-- create findoc-->
                <set field="finDoc.statusId" value="FinDocCreated" />
                <service-call name="growerp.100.FinDocServices100.create#FinDoc"
                    in-map="[finDoc: finDoc, classificationId: classificationId]"
                    out-map="resultCreateFindoc" />
                <script>finDocsImported++</script>
                <!-- create references-->
                <if condition="finDoc.docType == 'invoice'">
                    <if condition="finDoc.reference">
                        <!-- find transaction for invoice-->
                        <entity-find entity-name="mantle.ledger.transaction.AcctgTrans"
                            list="transactions" for-update="true">
                            <econdition field-name="organizationPartyId" from="companyPartyId" />
                            <econdition field-name="theirAcctgTransId" from="finDoc.reference" />
                        </entity-find>
                        <if condition="!transactions">
                            <script>System.out.println(">>>Import : could not find ${finDoc.sales?'sales':'purchase'} invoice ${resultCreateFindoc.finDoc.invoiceId} reference ${finDoc.reference}")</script>
                            <else>
                                <if condition="!transactions[0].invoiceId">
                                    <!-- ok found empty transaction -->
                                    <set field="transactions[0].invoiceId"
                                        from="resultCreateFindoc.finDoc.invoiceId" />
                                    <entity-update value-field="transactions[0]" />
                                    <else>
                                        <script>System.out.println(">>>Transaction: ${transactions[0].acctgTransId}/${transactions[0].pseudoId} already has invoiceId: ${transactions[0].invoiceId} cannot add ${finDoc.sales?'sales':'purchase'} ${resultCreateFindoc.finDoc.invoiceId} reference: ${finDoc.reference} otherCompany: ${finDoc.otherCompany.partyId} trans other partyId: ${transactions[0].otherPartyId}")</script>
                                    </else>
                                </if>
                            </else>
                        </if>
                    </if>
                </if>
                <!-- incoming receipts-->
                <if condition="finDoc.docType == 'payment' &amp;&amp; finDoc.sales == true">
                    <!-- find transaction for payment-->
                    <entity-find entity-name="mantle.ledger.transaction.AcctgTrans"
                        list="transactions" for-update="true">
                        <econdition field-name="organizationPartyId" from="companyPartyId" />
                        <econdition field-name="theirAcctgTransId" from="finDoc.reference" />
                        <econdition field-name="otherPartyId" from="finDoc.otherCompany.partyId" />
                    </entity-find>
                    <if condition="!transactions">
                        <script>System.out.println(">>>Import : could not find ${finDoc.sales?'sales':'purchase'} payment ${resultCreateFindoc.finDoc.paymentId} reference ${finDoc.reference}  otherCompany: ${finDoc.otherCompany.partyId}")</script>
                        <else>
                            <if condition="!transactions[0].paymentId">
                                <!-- ok found empty transaction -->
                                <set field="transactions[0].paymentId"
                                    from="resultCreateFindoc.finDoc.paymentId" />
                                <entity-update value-field="transactions[0]" />
                                <else>
                                    <script>System.out.println(">>>Transaction: ${transactions[0].acctgTransId}/${transactions[0].pseudoId} already has ${finDoc.sales?'sales':'purchase'} paymentId: ${transactions[0].paymentId} cannot add ${resultCreateFindoc.finDoc.paymentId} reference: ${finDoc.reference} otherCompany: ${finDoc.otherCompany.partyId} trans other partyId: ${transactions[0].otherPartyId}")</script>
                                </else>
                            </if>
                        </else>
                    </if>
                </if>
                <!-- for payment use check number as reference into the ledger -->
                <if
                    condition="finDoc.docType == 'payment' &amp;&amp; finDoc.paymentMethod?.checkNumber">
                    <!--log
                        message="===looking for tranaction for payment with checknumber:
                    ${finDoc.paymentMethod?.checkNumber}" /-->
                    <entity-find entity-name="mantle.ledger.transaction.AcctgTrans"
                        list="transactions" for-update="true">
                        <econdition field-name="organizationPartyId" from="companyPartyId" />
                        <econdition field-name="theirAcctgTransId"
                            from="finDoc.paymentMethod?.checkNumber" />
                    </entity-find>
                    <if condition="!transactions">
                        <script>System.out.println(">>>Import : could not find ${finDoc.sales?'sales':'purchase'} payment ${resultCreateFindoc.finDoc.paymentId} checknumber ${finDoc.paymentMethod?.checkNumber}")</script>
                        <else>
                            <if condition="!transactions[0].paymentId">
                                <!-- ok found empty transaction -->
                                <set field="transactions[0].paymentId"
                                    from="resultCreateFindoc.finDoc.paymentId" />
                                <entity-update value-field="transactions[0]" />
                                <else>
                                    <script>System.out.println(">>>Transaction: ${transactions[0].acctgTransId}/${transactions[0].pseudoId} already has paymentId: ${transactions[0].paymentId} cannot add ${resultCreateFindoc.finDoc.sales?'sales':'purchase'} ${resultCreateFindoc.finDoc.paymentId} checkNr: ${finDoc.paymentMethod?.checkNumber} otherCompany: ${finDoc.otherCompany.partyId} trans: ${transactions[0].otherPartyId}")</script>
                                </else>
                            </if>
                        </else>
                    </if>
                </if>
                <!-- try to find invoice for payment -->
                <if condition="finDoc.docType == 'payment'">
                    <if condition="finDoc.sales == true">
                        <set field="fromPartyId" from="companyPartyId" />
                        <set field="toPartyId" from="null" />
                        <set field="pseudoIds" from="[finDoc.classificationId]" />
                        <else>
                            <set field="toPartyId" from="companyPartyId" />
                            <set field="fromPartyId" from="null" />
                            <set field="pseudoIds" from="finDoc.reference.split(',')" />
                        </else>
                    </if>
                    <iterate list="pseudoIds" entry="pseudoId">
                        <if condition="pseudoId == ''">
                            <continue />
                        </if>
                        <entity-find entity-name="mantle.account.invoice.Invoice" limit="3"
                            list="invoiceFound">
                            <econdition field-name="pseudoId" from="pseudoId" />
                            <econdition field-name="fromPartyId" ignore-if-empty="true" />
                            <econdition field-name="toPartyId" ignore-if-empty="true" />
                        </entity-find>
                        <!--log
                            message="looking from ${finDoc.sales ? 'sales' : 'purchase'} payment: ${finDoc.pseudoId} for
                        invoice: $pseudoId from: $fromPartyId to: $toPartyId result:
                        ${invoiceFound?.size()}" /-->
                        <if condition="invoiceFound">
                            <service-call name="update#mantle.account.payment.Payment"
                                in-map="[paymentId: resultCreateFindoc.finDoc.paymentId,
                                    forInvoiceId:  invoiceFound[0].invoiceId, status: 'PmntDelivered']" />
                            <service-call
                                name="mantle.account.PaymentServices.apply#PaymentForInvoice"
                                in-map="[paymentId: resultCreateFindoc.finDoc.paymentId]" />
                            <else>
                                <script>System.out.println(">>>could not find an invoice ${pseudoId} to apply for payment: ${resultCreateFindoc.finDoc.paymentId} amount: ${resultCreateFindoc.finDoc.grandTotal}")</script>
                            </else>
                        </if>
                    </iterate>
                </if>
                <!-- link invoices to order, so order should be created first -->
                <if condition="finDoc.docType == 'invoice' &amp;&amp; finDoc.classificationId">
                    <set field="pseudoId" from="finDoc.classificationId" />
                    <if condition="finDoc.sales == true">
                        <set field="vendorPartyId" from="companyPartyId" />
                        <set field="customerPartyId" from="null" />
                        <else>
                            <set field="customerPartyId" from="companyPartyId" />
                            <set field="vendorPartyId" from="null" />
                        </else>
                    </if>
                    <!--log
                        message="===looking for order from invoice:${resultCreateFindoc.finDoc.invoiceId} order pseudoId:
                    ${pseudoId} cust ${customerPartyId} vend: ${vendorPartyId}" /-->
                    <entity-find entity-name="mantle.order.OrderHeaderAndPart" limit="1"
                        list="orderFound">
                        <econdition field-name="pseudoId" from="pseudoId" />
                        <econdition field-name="customerPartyId" ignore-if-empty="true" />
                        <econdition field-name="vendorPartyId" ignore-if-empty="true" />
                    </entity-find>
                    <if condition="orderFound">
                        <service-call name="create#mantle.order.OrderItemBilling"
                            in-map="[invoiceId: resultCreateFindoc.finDoc.invoiceId, orderId: orderFound[0].orderId]" />
                        <else>
                            <script>System.out.println(">>>could not find an order ${pseudoId} from invoice: ${resultCreateFindoc.finDoc.pseudoId}[${resultCreateFindoc.finDoc.invoiceId}]")</script>
                        </else>
                    </if>
                </if>
                <if condition="finDoc.docType == 'shipment' &amp;&amp; finDoc.reference">
                    <!-- connect shipment to transaction -->
                    <entity-find entity-name="growerp.account.AcctgTransAndCompany"
                        list="transactions" limit="1">
                        <econdition field-name="companyPartyId" from="companyPartyId" />
                        <econdition field-name="theirAcctgTransId" from="finDoc.reference" />
                    </entity-find>
                    <if condition="transactions">
                        <if condition="transactions[0].shipmentId == null">
                            <service-call name="update#mantle.ledger.transaction.AcctgTrans"
                                in-map="transactions[0] + [shipmentId: resultCreateFindoc.finDoc.shipmentId] " />
                            <else>
                                <script>System.out.println(">>>transaction already has shipment: ${resultCreateFindoc.finDoc.shipmentId} could not create relation to shipment: ${resultCreateFindoc.finDoc.shipmentId} and reference: ${finDoc.reference}")</script>
                            </else>
                        </if>
                        <else>
                            <script>System.out.println(">>>transaction could not be found for shipment: ${resultCreateFindoc.finDoc.shipmentId} and reference: ${finDoc.reference}")</script>
                        </else>
                    </if>
                </if>
            </iterate>
            <if condition="!ec.message.hasError()">
                <script>System.out.println(">>>${finDocsImported} finDocs  ${finDocs[0].docType} imported, Companies created: ${companiesCreated}")</script>
            </if>
        </actions>
    </service>

    <service verb="import" noun="FinDocItems" transaction-timeout="3600">
        <in-parameters>
            <parameter name="finDocItems" required="true" type="List" />
            <parameter name="classificationId" required="true" />
        </in-parameters>
        <actions>
            <script>System.out.println(">>>>importing ${finDocItems?.size()} ${!finDocItems.isEmpty() ? finDocItems[0].docType : ''} items")</script>
            <set field="itemsImported" type="Integer" value="0" />
            <service-call out-map="context"
                name="growerp.100.GeneralServices100.get#RelatedCompanyAndOwner" />
            <set field="itemsOut" from="[]" />
            <set field="index" value="0" type="Integer" />
            <iterate list="finDocItems" entry="item">
                <if condition="lastItem &amp;&amp; lastItem.pseudoId != item.pseudoId">
                    <script>ec.user.setEffectiveTime(Timestamp.valueOf("${finDoc.creationDate} 00:00:00"))</script>
                    <!-- get current document id-->
                    <service-call name="growerp.100.FinDocServices100.get#FinDoc" out-map="context"
                        in-map="[pseudoId: lastItem.pseudoId, docType: lastItem.docType,
                                classificationId: classificationId]" />
                    <if condition="finDocs.isEmpty()">
                        <!-- cannot find, so not try to add items -->
                        <script>System.out.println(">>>>importing ${lastItem.docType} items could not find company: $companyPartyId and pseudo: ${lastItem.pseudoId}")</script>
                        <else>
                            <set field="finDoc" from="finDocs[0]" />
                            <!-- add items collected below to finDoc[0] already got below-->
                            <set field="finDoc.items" from="itemsOut" />
                            <if condition="finDoc.docType == 'transaction'">
                                <set field="finDoc.isPosted" value="true" type="Boolean" />
                            </if>
                            <if condition="finDoc.docType == 'shipment' &amp;&amp; finDoc.reference">
                                <service-call
                                    name="growerp.100.ImportExportServices100.get#InvoiceItemsForShipmentQuantities"
                                    in-map="[companyPartyId: companyPartyId, finDoc: finDoc]"
                                    out-map="context" />
                            </if>
                            <service-call name="growerp.100.FinDocServices100.update#FinDoc"
                                in-map="[finDoc: finDoc, classificationId: classificationId]" />
                            <script>itemsImported += finDoc.items?.size()</script>
                        </else>
                    </if>
                    <set field="itemsOut" from="[]" />
                </if>
                <if condition="!lastItem || lastItem.pseudoId != item.pseudoId">
                    <!-- find related finDoc header -->
                    <service-call name="growerp.100.FinDocServices100.get#FinDoc"
                        in-map="[pseudoId: item.pseudoId, docType: item.docType]"
                        out-map="context" />
                    <if condition="finDocs.isEmpty()">
                        <script>System.out.println(">>>Import ${item.docType} pseudoId: ${item.pseudoId} not found")</script>
                        <set field="lastItem" from="null" />
                        <continue />
                        <else>
                            <set field="finDoc" from="finDocs[0]" />
                        </else>
                    </if>
                </if>
                <if condition="item.glAccount.accountCode">
                    <!-- find internal item glAccountId from glAccount.accountCode-->
                    <entity-find entity-name="growerp.ledger.account.GlAccountAndOrganization"
                        list="glAccounts">
                        <econdition field-name="partyId" from="companyPartyId" />
                        <econdition field-name="accountCode" from="item.glAccount.accountCode" />
                    </entity-find>
                    <if condition="glAccounts">
                        <set field="item.glAccount.glAccountId" from="glAccounts[0].glAccountId" />
                        <else>
                            <script>System.out.println(">>>id: ${item.pseudoId} could not find item accountCode ${item.glAccount.accountCode} for company: $companyPartyId")</script>
                        </else>
                    </if>
                    <if condition="finDocs[0].docType == 'transaction'">
                        <if condition="item.isDebit == null">
                            <set field="item.isDebit"
                                from="glAccounts[0].isDebit == 'Y' ? true : false" />
                        </if>
                    </if>
                </if>
                <if condition="!item.product.pseudoId.isEmpty()">
                    <!-- find productId from pseudoProductId -->
                    <service-call name="growerp.100.CatalogServices100.get#Products"
                        out-map="context"
                        in-map="[pseudoId: item.product.pseudoId,
                                classificationId: classificationId,
                                ownerPartyId: ownerPartyId]" />
                    <if condition="!products.isEmpty()"><!-- get services always provide list -->
                        <set field="item.product.productId" from="products[0].productId" />
                        <!-- update prices when on an invoice -->
                        <if condition="item.docType == 'invoice'">
                            <set field="products[0].price" from="item.price" />
                            <set field="products[0].listPrice" from="item.price" />
                            <service-call name="growerp.100.CatalogServices100.update#Product"
                                out-map="context"
                                in-map="[product: products[0], classificationId: classificationId]" />
                        </if>
                        <else>
                            <!-- not found so better add it when not null -->
                            <if condition="item.pseudoProductId != null">
                                <script>System.out.println(">>>id: ${item.pseudoId} could not find pseudoProductId ${item.pseudoProductId} for owner: $ownerPartyId, will add it")</script>
                                <set field="product"
                                    from="[
                                    ownerPartyId: ownerPartyId,
                                    pseudoId: item.pseudoProductId,
                                    productTypeId: 'Physical Good',
                                    productName: item.description,
                                    price: item.price,
                                    listPrice: item.price,
                                    ]" />
                                <service-call name="growerp.100.CatalogServices100.create#Product"
                                    out-map="context"
                                    in-map="[product: product, classificationId: classificationId]" />
                                <set field="item.productId" from="product.productId" />
                            </if>
                        </else>
                    </if>
                </if>
                <!-- item type on orders if missing create some: -->
                <if condition="finDoc.docType == 'order' &amp;&amp; !item.itemType">
                    <script>System.out.println(">>>id: ${item.pseudoId} no item type for ${item.glAccount.glAccountId} set to ItemExpense")</script>
                    <set field="item.itemType" from="[itemTypeId: 'ItemExpense']" />
                </if>
                <script>itemsOut.add(item)</script>
                <set field="lastItem" from="item" />
            </iterate>
            <!-- process last record -->
            <if condition="lastItem">
                <script>ec.user.setEffectiveTime(Timestamp.valueOf("${finDoc.creationDate} 00:00:00"))</script>
                <!-- get current document id-->
                <service-call name="growerp.100.FinDocServices100.get#FinDoc" out-map="context"
                    in-map="[pseudoId: lastItem.pseudoId, docType: lastItem.docType,
                            classificationId: classificationId]" />
                <if condition="finDocs.isEmpty()">
                    <!-- cannot find, so not try to add items -->
                    <script>System.out.println(">>>>importing items could not find ${lastItem.pseudoId}")</script>
                    <else>
                        <set field="finDoc" from="finDocs[0]" />
                        <!-- add items collected below to finDoc[0] already got below-->
                        <set field="finDoc.items" from="itemsOut" />
                        <if condition="finDoc.docType == 'transaction'">
                            <set field="finDoc.isPosted" value="true" type="Boolean" />
                        </if>
                        <if condition="finDoc.docType == 'shipment' &amp;&amp; finDoc.reference">
                            <service-call
                                name="growerp.100.ImportExportServices100.get#InvoiceItemsForShipmentQuantities"
                                in-map="[companyPartyId: companyPartyId, finDoc: finDoc]"
                                out-map="context" />
                        </if>
                        <service-call name="growerp.100.FinDocServices100.update#FinDoc"
                            in-map="[finDoc: finDoc, classificationId: classificationId]" />
                        <script>itemsImported + finDoc.items?.size()</script>
                    </else>
                </if>
            </if>

            <!-- end of service result -->
            <if condition="!ec.message.hasError()">
                <script>System.out.println(">>>${itemsImported} findoc items ${finDocItems[0].docType} imported")</script>
            </if>
        </actions>
    </service>

    <service verb="get" noun="InvoiceItemsForShipmentQuantities">
        <in-parameters>
            <parameter name="companyPartyId" />
            <parameter name="finDoc" type="Map" />
        </in-parameters>
        <out-parameters>
            <parameter name="finDoc" type="Map" />
        </out-parameters>
        <actions>
            <!-- looking for invoice of shipment to get quantity -->
            <if condition="finDoc.sales">
                <set field="fromPartyId" from="companyPartyId" />
                <else>
                    <set field="toPartyId" from="companyPartyId" />
                </else>
            </if>
            <!-- log
                message="matching invoice ${finDoc.invoiceId}/${finDoc.pseudoId} on finDoc ref: ${finDoc.reference}
            with fromPartyId:
            $fromPartyId toPartyId: $toPartyId sales: ${finDoc.sales}" /-->
            <entity-find entity-name="mantle.account.invoice.Invoice"
                list="invoices" limit="1">
                <econdition field-name="externalId" from="finDoc.reference" />
                <econdition field-name="fromPartyId" from="fromPartyId"
                    ignore-if-empty="true" />
                <econdition field-name="toPartyId" from="toPartyId" ignore-if-empty="true" />
            </entity-find>
            <if condition="invoices">
                <!-- connect to invoice/order-->
                <entity-find entity-name="mantle.order.OrderItemBilling" limit="1" list="billings"
                    for-update="true">
                    <econdition field-name="invoiceId" from="invoices[0].invoiceId" />
                </entity-find>
                <if condition="billings">
                    <set field="billings[0].shipmentId" from="finDoc.shipmentId" />
                    <entity-update value-field="billings[0]" />
                </if>
                <!-- find a matching invoice item to get quantity -->
                <entity-find entity-name="mantle.account.invoice.InvoiceItem"
                    list="invoiceItems">
                    <econdition field-name="invoiceId" from="invoices[0].invoiceId" />
                </entity-find>
                <!-- log message="matching items: ${finDoc.items?.size()}" /-->
                <set field="newShipmentItems" from="[]" />
                <iterate list="finDoc.items" entry="shipmentItem">
                    <set field="quantityUpdated" value="false" type="Boolean" />
                    <iterate list="invoiceItems" entry="invoiceItem">
                        <if
                            condition="shipmentItem.product?.productId &amp;&amp;
                                invoiceItem.product?.productId == shipmentItem.product?.productId">
                            <script>newShipmentItems.add(
                                    shipmentItem + [quantity: invoiceItem.quantity])</script>
                            <set field="quantityUpdated" value="true" type="Boolean" />
                        </if>
                    </iterate>
                    <if condition="quantityUpdated == false">
                        <script>System.out.println(">>>Could not update shipment # quantity, shipmentId/productId: ${finDoc.shipmentId}/${shipmentItem.productId}  invoiceId/products: ${invoiceId}/${invoiceItems.productId}")</script>
                    </if>
                </iterate>
                <set field="finDoc.items" from="newShipmentItems" />
                <else>
                    <script>System.out.println(">>>Could not find related invoice for company: $companyPartyId sales: ${finDoc.sales} shipment: ${finDoc.shipmentId}/${finDoc.pseudoId} ref: ${finDoc.reference}")</script>
                </else>
            </if>
        </actions>
    </service>

    <service verb="finalize" noun="Import">
        <description> Post imported findocs of which the status is not finalized and already have a link
            in the ledger so the status will update but will not change the ledger</description>
        <actions>
            <service-call out-map="context"
                name="growerp.100.GeneralServices100.get#RelatedCompanyAndOwner" />

            <!-- find oldest non-closed period -->
            <entity-find entity-name="mantle.party.time.TimePeriod" list="periods">
                <econdition field-name="partyId" from="companyPartyId" />
                <econdition field-name="timePeriodTypeId" value="FiscalYear" />
                <econdition field-name="isClosed" value="N" />
                <order-by field-name="periodNum" />
            </entity-find>
            <if condition="!periods">
                <return error="true" message="Could not find the oldest not closed period" />
            </if>
            <service-call name="mantle.party.TimeServices.get#TimePeriodInfo"
                in-map="[timePeriod:periods[0]]" out-map="periodInfo" />
            <set field="fromTimestamp" from="periodInfo.fromTimestamp" />
            <set field="thruTimestamp" from="periodInfo.thruTimestamp" />

            <!-- change system date to end of period -->
            <script>ec.user.setEffectiveTime(thruTimestamp)</script>

            <!-- with the assumption that the old system tranactions  balance, group all unposted
            transaction entries in a single transaction and post that -->
            <entity-find entity-name="growerp.account.AcctgTransAndCompany" list="unpostedTrans">
                <econdition field-name="isPosted" operator="not-equals" value="Y" or-null="true" />
                <econdition field-name="companyPartyId" from="companyPartyId" />
                <econdition field-name="transactionDate" operator="greater-equals"
                    from="fromTimestamp" />
                <econdition field-name="transactionDate" operator="less-equals" from="thruTimestamp" />
            </entity-find>
            <if condition="unpostedTrans">
                <service-call name="growerp.100.GeneralServices100.getNext#PseudoId"
                    in-map="[ownerPartyId: ownerPartyId, seqName: 'transaction']" out-map="context" />
                <service-call name="create#mantle.ledger.transaction.AcctgTrans"
                    in-map="[pseudoId: seqNum, description: 'Conversion combined unposted entries',
                            organizationPartyId: companyPartyId]"
                    out-map="context" />
                <!-- re-assign all unposted entries to ne transaction -->
                <set field="index" value="1" type="Integer" />
                <iterate list="unpostedTrans" entry="trans">
                    <entity-find entity-name="mantle.ledger.transaction.AcctgTransEntry"
                        list="transEntries" for-update="true">
                        <econdition field-name="acctgTransId" from="trans.transactionId" />
                    </entity-find>
                    <iterate list="transEntries" entry="transEntry">
                        <entity-delete value-field="transEntry" />
                        <set field="transEntry.acctgTransId" from="acctgTransId" />
                        <set field="transEntry.acctgTransEntrySeqId" from="(index++).toString()" />
                        <entity-create value-field="transEntry" />
                    </iterate>
                    <!-- delete original transaction -->
                    <service-call name="delete#mantle.ledger.transaction.AcctgTrans"
                        in-map="[acctgTransId: trans.transactionId]" />
                </iterate>
                <!-- post found entries -->
                <service-call name="mantle.ledger.LedgerServices.post#AcctgTrans"
                    in-map="[acctgTransId: acctgTransId]" />
            </if>
            <!-- period should succeeed to close -->
            <service-call name="growerp.100.AccountingServices100.close#FinancialTimePeriod"
                in-map="[timePeriodId: periods[0].timePeriodId, closeChildren: true]" />

            <!-- invoices -->
            <entity-find entity-name="mantle.account.invoice.Invoice" list="invoices">
                <econditions combine="or">
                    <econdition field-name="fromPartyId" from="companyPartyId" />
                    <econdition field-name="toPartyId" from="companyPartyId" />
                </econditions>
                <econditions combine="or">
                    <econdition field-name="statusId" value="InvoiceInProcess" />
                    <econdition field-name="statusId" value="InvoiceIncoming" />
                </econditions>
            </entity-find>
            <set field="updatedCount" value="0" type="Integer" />
            <set field="notFoundCount" value="0" type="Integer" />
            <iterate list="invoices" entry="invoice">
                <!-- check if referenced in the ledger-->
                <entity-find entity-name="mantle.ledger.transaction.AcctgTrans" list="transList">
                    <econdition field-name="organizationPartyId" from="companyPartyId" />
                    <econdition field-name="invoiceId" from="invoice.invoiceId" />
                </entity-find>
                <if condition="transList"><!-- only close when in the ledger-->
                    <if condition="invoice.statusId == 'InvoiceInProcess'">
                        <set field="statusId1" value="InvoiceFinalized" />
                        <set field="statusId2" value="InvoiceSent" />
                        <else>
                            <set field="statusId1" value="InvoiceReceived" />
                            <set field="statusId2" value="InvoiceApproved" />
                        </else>
                    </if>
                    <service-call name="update#mantle.account.invoice.Invoice"
                        in-map="[invoiceId: invoice.invoiceId, statusId: statusId1]" />
                    <set field="updatedCount" from="updatedCount + 1" />
                    <entity-find-one entity-name="mantle.account.invoice.Invoice" value-field="inv">
                        <field-map field-name="invoiceId" from="invoice.invoiceId" />
                    </entity-find-one>
                    <if condition="inv.statusId == statusId1">
                        <service-call name="update#mantle.account.invoice.Invoice"
                            in-map="[invoiceId: invoice.invoiceId, statusId: statusId2]" />
                    </if>
                    <else>
                        <set field="notFoundCount" from="notFoundCount + 1" />
                        <script>System.out.println(">>>Could not find invoice in the ledger, sales: ${finDoc?.sales} invoice: ${finDoc?.invoiceId}/${finDoc?.pseudoId} ref: ${finDoc?.reference}")</script>
                    </else>
                </if>
            </iterate>
            <script>System.out.println(">>>${invoices.size()} not completed invoices found ${updatedCount} updated, ${notFoundCount} not found in ledger")</script>

            <!-- payments -->
            <entity-find entity-name="mantle.account.payment.Payment" list="payments">
                <econditions combine="or">
                    <econdition field-name="fromPartyId" from="companyPartyId" />
                    <econdition field-name="toPartyId" from="companyPartyId" />
                </econditions>
                <econdition field-name="statusId" value="PmntPromised" />
            </entity-find>
            <set field="updatedCount" value="0" type="Integer" />
            <set field="notFoundCount" value="0" type="Integer" />
            <iterate list="payments" entry="payment">
                <!-- check if referenced in the ledger-->
                <entity-find entity-name="mantle.ledger.transaction.AcctgTrans" list="transList">
                    <econdition field-name="organizationPartyId" from="companyPartyId" />
                    <econdition field-name="paymentId" from="payment.paymentId" />
                </entity-find>
                <if condition="transList">
                    <!-- found, so can be completed -->
                    <service-call name="update#mantle.account.payment.Payment"
                        in-map="[paymentId: payment.paymentId, statusId: 'PmntDelivered']" />
                    <set field="updatedCount" from="updatedCount + 1" />
                    <else>
                        <script>System.out.println(">>>Could not find payment in the ledger, payment: ${payment.paymentId}/${payment.pseudoId} ref: ${payment.paymentRefNum}")</script>
                        <set field="notFoundCount" from="notFoundCount + 1" />
                    </else>
                </if>
            </iterate>
            <script>System.out.println(">>>${payments.size()} not completed payments found ${updatedCount} updated, ${notFoundCount} not found in ledger")</script>

            <!-- complete invoices and orders -->
            <entity-find
                entity-name="mantle.account.invoice.Invoice" list="invoices">
                <econditions combine="or">
                    <econdition field-name="fromPartyId" from="companyPartyId" />
                    <econdition field-name="toPartyId" from="companyPartyId" />
                </econditions>
                <econditions combine="or">
                    <econdition field-name="statusId" value="InvoiceApproved" />
                    <econdition field-name="statusId" value="InvoiceSent" />
                </econditions>
            </entity-find>
            <set field="updatedCount" value="0" type="Integer" />
            <set field="notFoundCount" value="0" type="Integer" />
            <iterate list="invoices" entry="invoice">
                <service-call name="update#mantle.account.invoice.Invoice"
                    in-map="[invoiceId: invoice.invoiceId,
                        statusId: invoice.statusId == 'InvoiceSent'? 'InvoicePmtRecvd' : 'InvoicePmtSent']" />
                <entity-find entity-name="mantle.order.OrderItemBilling" list="orders">
                    <econdition field-name="invoiceId" from="invoice.invoiceId" />
                </entity-find>
                <if condition="orders">
                    <service-call name="update#mantle.order.OrderHeader"
                        in-map="[orderId: orders[0].orderId, statusId: 'OrderApproved']" />
                    <service-call name="update#mantle.order.OrderHeader"
                        in-map="[orderId: orders[0].orderId, statusId: 'OrderCompleted']" />
                </if>
            </iterate>
            <!-- receive incoming shipments-->
            <entity-find entity-name="mantle.shipment.Shipment" list="shipments">
                <econdition field-name="toPartyId" from="companyPartyId" />
                <econdition field-name="statusId" value="ShipScheduled" />
            </entity-find>
            <iterate list="shipments" entry="shipment">
                <service-call name="growerp.100.FinDocServices100.get#FinDoc"
                    in-map="[finDocId: shipment.shipmentId, docType: 'shipment']" out-map="context" />
                <service-call name="growerp.100.FinDocServices100.update#FinDoc"
                    in-map="[finDoc: finDocs[0] + [statusId: 'FinDocApproved']]" />
                <service-call name="growerp.100.FinDocServices100.get#FinDoc"
                    in-map="[finDocId: shipment.shipmentId, docType: 'shipment']" out-map="context" />
                <service-call name="growerp.100.FinDocServices100.receive#Shipment"
                    in-map="[finDoc: finDocs[0] + [statusId: 'FinDocApproved']]" />
            </iterate>
            <!-- send outgoing shipments -->
            <!--entity-find
                entity-name="mantle.shipment.Shipment" list="shipments">
                <econdition field-name="fromPartyId" from="companyPartyId" />
                <econdition field-name="statusId" value="ShipScheduled" />
            </entity-find>
            <iterate list="shipments" entry="shipment">
                <service-call name="growerp.100.FinDocServices100.get#FinDoc"
                    in-map="[finDocId: shipment.shipmentId, docType: 'shipment']" out-map="context" />
                <log message="=====processing outgoing shipment: ${finDocs[0]}" />
                <service-call name="growerp.100.FinDocServices100.update#FinDoc"
                    in-map="[finDoc: finDocs[0] + [statusId: 'FinDocApproved']]" />
                <service-call name="growerp.100.FinDocServices100.update#FinDoc"
                    in-map="[finDoc: finDocs[0] + [statusId: 'FinDocCompleted']]" />
            </iterate-->
        </actions>
    </service>

    <!-- used by the screens and the tests-->
    <service verb="import" noun="Entities">
        <description> Import general entities</description>
        <in-parameters>
            <parameter name="entities" required="true" type="Map" />
            <parameter name="classificationId" />
        </in-parameters>
        <actions>
            <service-call name="growerp.100.GeneralServices100.get#RelatedCompanyAndOwner"
                out-map="relComp" />
            <if condition="entities.companies">
                <iterate list="entities.companies" entry="company">
                    <if condition="company.partyId == '_MOD_'">
                        <entity-find entity-name="growerp.party.OwnerCompanyDetailAndEmployee"
                            list="parties">
                            <econdition field-name="ownerPartyId" from="relComp.ownerPartyId" />
                            <econdition field-name="companyName" operator="like"
                                value="${company.name}%" />
                        </entity-find>
                        <if condition="parties">
                            <set field="company.partyId" from="parties[0].companyPartyId" />
                            <service-call name="growerp.100.PartyServices100.update#Company"
                                in-map="[company: company]" />
                        </if>
                        <else>
                            <service-call name="growerp.100.PartyServices100.create#Company"
                                in-map="[company: company, ownerPartyId: relComp.ownerPartyId]" />
                        </else>
                    </if>
                </iterate>
            </if>
            <if condition="entities.users">
                <iterate list="entities.users" entry="user">
                    <service-call name="growerp.100.PartyServices100.create#User"
                        in-map="[user: user]" />
                </iterate>
            </if>
            <if condition="entities.categories">
                <iterate list="entities.categories" entry="category">
                    <service-call name="growerp.100.CatalogServices100.create#ProductCategory"
                        in-map="[category: category, classificationId: classificationId]" />
                </iterate>
            </if>
            <if condition="entities.products">
                <iterate list="entities.products" entry="product">
                    <!-- check if related category exist using name, if yes use these-->
                    <iterate list="product.categories" entry="category">
                        <entity-find entity-name="mantle.product.category.ProductCategory"
                            list="foundCategories">
                            <econdition field-name="categoryName" from="category.categoryName" />
                            <econdition field-name="ownerPartyId" from="relComp.ownerPartyId" />
                        </entity-find>
                        <if condition="foundCategories">
                            <set field="category.categoryId"
                                from="foundCategories[0].productCategoryId" />
                        </if>
                    </iterate>
                    <service-call name="growerp.100.CatalogServices100.create#Product"
                        out-map="result"
                        in-map="[product: product, classificationId: classificationId]" />
                </iterate>
                <message public="true" type="success">Products Upload completed</message>
            </if>
            <if condition="entities.assets">
                <iterate list="entities.assets" entry="asset">
                    <service-call name="growerp.100.InventoryServices100.create#Asset"
                        in-map="[asset: asset, classificationId: classificationId]" />
                </iterate>
                <message public="true" type="success">Assets Upload completed</message>
            </if>
            <if condition="entities.locations">
                <iterate list="entities.locations" entry="location">
                    <service-call name="growerp.100.InventoryServices100.create#Location"
                        in-map="[location: location]" />
                </iterate>
                <message public="true" type="success">Locations Upload completed</message>
            </if>
            <!-- empty list will remove all accounts-->
            <if condition="entities.glAccounts || entities.glAccounts?.size == 0">
                <!-- delete existing transactions only initial if present-->
                <entity-find entity-name="mantle.ledger.transaction.AcctgTrans" list="transList">
                    <econdition field-name="organizationPartyId" from="relComp.companyPartyId" />
                </entity-find>
                <if condition="transList.size() &gt; 1">
                    <return error="true"
                        message="Can only delete ledger when when not more than the initial settiung of posted balance." />
                </if>
                <if condition="!transList.isEmpty()">
                    <entity-delete-by-condition
                        entity-name="mantle.ledger.transaction.AcctgTransEntry">
                        <econdition field-name="acctgTransId" from="transList[0].acctgTransId" />
                    </entity-delete-by-condition>
                    <entity-delete-by-condition entity-name="mantle.ledger.transaction.AcctgTrans">
                        <econdition field-name="acctgTransId" from="transList[0].acctgTransId" />
                    </entity-delete-by-condition>
                </if>
                <!-- delete existing ledger -->
                <entity-find entity-name="mantle.ledger.account.GlAccountAndOrganization"
                    list="glAccounts">
                    <econdition field-name="organizationPartyId" from="relComp.companyPartyId" />
                    <select-field field-name="glAccountId" />
                </entity-find>
                <entity-delete-by-condition
                    entity-name="mantle.ledger.account.GlAccountOrganization">
                    <econdition field-name="organizationPartyId" from="relComp.companyPartyId" />
                </entity-delete-by-condition>
                <entity-delete-by-condition
                    entity-name="mantle.ledger.account.GlAccount">
                    <econdition field-name="glAccountId" operator="in" from="glAccounts" />
                </entity-delete-by-condition>
                <!-- create new accounts and collect posted balances for new transactions-->
                <set field="transactions" from="[]" />
                <iterate list="entities.glAccounts" entry="newGlAccount">
                    <service-call name="growerp.100.AccountingServices100.create#GlAccount"
                        in-map="[glAccount: newGlAccount]"
                        out-map="createdGlAccount" />
                    <if condition="newGlAccount.postedBalance">
                        <script>transactions.add([
                            isDebit: createdGlAccount.glAccount.isDebit,
                            price: newGlAccount.postedBalance,
                            glAccount: [glAccountId: createdGlAccount.glAccount.glAccountId],
                        ])</script>
                    </if>
                </iterate>
                <!-- create unposted balance in initial transaction-->
                <if condition="!transactions.isEmpty()">
                    <service-call name="growerp.100.FinDocServices100.create#FinDoc"
                        in-map="finDoc: [docType: 'transaction', sales: 'true',
                                description: 'Initial balance',
                                items: transactions]"
                        out-map="context" />
                </if>
                <message public="true" type="success">${entities.glAccounts.size()} Ledger accounts with ${transactions.size()} initial transactions Upload completed</message>
            </if>
        </actions>
    </service>

    <service verb="get" noun="ExportCategories">
        <description>
            Get Categories information into a CSV file attachement
        </description>
        <in-parameters>
            <parameter name="classificationId" />
        </in-parameters>
        <out-parameters>
            <parameter name="fileText" />
        </out-parameters>
        <actions>
            <service-call name="growerp.100.CatalogServices100.get#ProductCategories"
                in-map="[classificationId: classificationId]" out-map="context" />
            <set field="fileText" value="" />
            <script><![CDATA[
                import org.apache.commons.csv.CSVPrinter
                import org.apache.commons.csv.CSVFormat
                import org.apache.commons.csv.CSVRecord
                import org.apache.commons.csv.QuoteMode
                StringBuilder outSb = new StringBuilder()
                CSVPrinter printer = CSVFormat.DEFAULT.withHeader(
                    "name", "description", "image").print(outSb)
                for (Map item in categories) {
                    printer.printRecord(item.categoryName,
                                        item.description,
                                        item.image)}
                fileText = outSb.toString()
            ]]></script>
            <!--log
            message="output in catgories CSV: ${fileText}"/-->
        </actions>
    </service>

    <service verb="get" noun="ExportProducts">
        <description>
            Get Products information into a CSV file attachement
        </description>
        <out-parameters>
            <parameter name="fileText" />
        </out-parameters>
        <actions>
            <script>logger.warn("getting products")</script>
            <service-call name="growerp.100.CatalogServices100.get#Products"
                out-map="context" />
            <set field="fileText" value="" />
            <script><![CDATA[
                import org.apache.commons.csv.CSVPrinter
                import org.apache.commons.csv.CSVFormat
                import org.apache.commons.csv.CSVRecord
                import org.apache.commons.csv.QuoteMode
                StringBuilder outSb = new StringBuilder()
                CSVPrinter printer = CSVFormat.DEFAULT.withHeader(
                    "name", "description", "Product Type Id", "image", "assetClassId","List Price","Price","Use Warehouse","Nbr of Assets","Category1", "Category2", "Category3").print(outSb)
                for (Map item in products) {
                    printer.printRecord(item.productName,
                                        item.description,
                                        item.productTypeId,
                                        item.image,
                                        item.assetClassId,
                                        item.listPrice,
                                        item.price,
                                        item.requireInventory,
                                        item.assetCount,
                                        item.categories[0] ? item.categories[0].categoryName :'',
                                        item.categories[1] ? item.categories[1].categoryName :'',
                                        item.categories[2] ? item.categories[2].categoryName :'',
                                        )}
                fileText = outSb.toString()
            ]]></script>
        </actions>
    </service>

    <service verb="get" noun="ExportGlAccounts">
        <description>
            Get ledger Gl Accounts information into a CSV file attachement
        </description>
        <in-parameters>
            <parameter name="classificationId" />
        </in-parameters>
        <out-parameters>
            <parameter name="fileText" />
        </out-parameters>
        <actions>
            <service-call name="growerp.100.AccountingServices100.get#GlAccount"
                in-map="[limit: 999]"
                out-map="context" />
            <set field="fileText" value="" />
            <script><![CDATA[
                import org.apache.commons.csv.CSVPrinter
                import org.apache.commons.csv.CSVFormat
                import org.apache.commons.csv.CSVRecord
                import org.apache.commons.csv.QuoteMode
                StringBuilder outSb = new StringBuilder()
                CSVPrinter printer = CSVFormat.DEFAULT.withHeader(
                    "id", "name", "isDebit", "class", "type","postedBalance").print(outSb)
                for (Map item in glAccountList) {
                    printer.printRecord(item.accountCode,
                                        item.accountName,
                                        item.isDebit,
                                        item.accountClass.description,
                                        item.accountType.description,
                                        item.posteBalance,
                                        )}
                fileText = outSb.toString()
            ]]></script>
        </actions>
    </service>


    <service verb="export" noun="Entities">
        <description> Export general entities</description>
        <in-parameters>
            <parameter name="entityName" required="true" />
            <parameter name="classificationId" required="true" />
        </in-parameters>
        <actions>
            <set field="emailAddress" from="ec.user.userAccount.emailAddress" />
            <set field="userAccount" from="ec.user.userAccount" />
            <set field="bodyParameters" from="[classificationId: classificationId]" />
            <if condition="entityName == 'Category'">
                <service-call name="org.moqui.impl.EmailServices.send#EmailTemplate" async="true"
                    in-map="[emailTemplateId: 'GrowerpExportCategories',
                        toAddresses: emailAddress, bodyParameters: bodyParameters]"
                    out-map="context" />
                <message public="true" type="success">A Categories CSV file was sent by email to ${userAccount.emailAddress}.</message>
            </if>
            <if condition="entityName == 'Product'">
                <service-call name="org.moqui.impl.EmailServices.send#EmailTemplate" async="true"
                    in-map="[emailTemplateId: 'GrowerpExportProducts',
                        toAddresses: emailAddress, bodyParameters: bodyParameters]"
                    out-map="context" />
                <message public="true" type="success">A Products CSV file was sent by email to ${userAccount.emailAddress}.</message>
            </if>
            <if condition="entityName == 'GlAccount'">
                <service-call name="org.moqui.impl.EmailServices.send#EmailTemplate" async="true"
                    in-map="[emailTemplateId: 'GrowerpExportGlAccounts',
                        toAddresses: emailAddress, bodyParameters: bodyParameters]"
                    out-map="context" />
                <message public="true" type="success">A GlAccount CSV file was sent by email to ${userAccount.emailAddress}.</message>
            </if>
        </actions>
    </service>

    <service verb="export" noun="Website">
        <out-parameters>
            <parameter name="website" type="Map" />
        </out-parameters>
        <actions>
            <service-call name="growerp.100.WebsiteServices100.get#Website"
                out-map="context" />
            <set field="websiteContent" from="[]" />
            <iterate list="website.websiteContent" entry="wsContent">
                <service-call name="growerp.100.WebsiteServices100.get#WebsiteContent"
                    in-map="path: wsContent.path, text: wsContent.text"
                    out-map="context" />
                <script>
                    websiteContent.add(content)
                </script>
            </iterate>
            <set field="website.websiteContent" from="websiteContent" />
        </actions>
    </service>

    <service verb="import" noun="Website">
        <in-parameters>
            <parameter name="website" type="Map" required="true">
                <parameter name="id" required="true" />
                <parameter name="title" />
                <parameter name="hostName" />
                <parameter name="websiteContent" type="List">
                    <parameter name="content" type="Map">
                        <parameter name="path" />
                        <parameter name="title" /><!-- if path found and title empty, page will be
                        deleted -->
                        <parameter name="text" />
                        <parameter name="seqId" type="Integer" />
                    </parameter>
                </parameter>
                <parameter name="websiteCategories" type="List">
                    <parameter name="websiteCategory" type="Map">
                        <parameter name="categoryId" />
                        <parameter name="categoryName" />
                        <parameter name="products" type="List" />
                        <parameter name="product" type="Map">
                            <parameter name="productId" />
                            <parameter name="productName" />
                        </parameter>
                    </parameter>
                </parameter>
                <parameter name="productCategories" type="List">
                    <parameter name="productCategory" type="Map">
                        <parameter name="categoryId" />
                    </parameter>
                </parameter>
                <parameter name="colorJson" />
                <parameter name="obsidianName" />
                <parameter name="measurementId" />
            </parameter>
            <parameter name="webContents" type="List">
                <parameter name="path" />
                <parameter name="title" />
                <parameter name="text" />
                <parameter name="image" />
                <parameter name="seqId" type="Integer" />
            </parameter>
        </in-parameters>
        <out-parameters>
            <parameter name="website" />
        </out-parameters>
        <actions>
            <service-call name="growerp.100.WebsiteServices100.update#Website"
                in-map="website: website"
                out-map="context" />
            <iterate list="websiteContents" entry="webSiteContent">
                <service-call name="growerp.100.WebsiteServices100.upload#WebsiteContent"
                    in-map="content: websiteContent"
                    out-map="context" />
            </iterate>
        </actions>
    </service>

</services>