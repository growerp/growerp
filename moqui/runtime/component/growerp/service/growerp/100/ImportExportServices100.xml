<?xml version="1.0" encoding="UTF-8"?>
<!--
This software is in the public domain under CC0 1.0 Universal plus a 
Grant of Patent License.

To the extent possible under law, the author(s) have dedicated all
copyright and related and neighboring rights to this software to the
public domain worldwide. This software is distributed without any
warranty.

You should have received a copy of the CC0 Public Domaicrn Dedication
along with this software (see the LICENSE.md file). If not, see
<http://creativecommons.org/publicdomain/zero/1.0/>.
-->
<services xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:noNamespaceSchemaLocation="http://moqui.org/xsd/service-definition-2.1.xsd">

    <!-- used by the conversion framework in the dart package growerp import client-->
    <service verb="import" noun="ItemTypes">
        <description> Import ItemTypes</description>
        <in-parameters>
            <parameter name="itemTypes" required="true" type="List">
                <parameter name="itemType" type="Map">
                    <parameter name="itemTypeId" />
                    <parameter name="direction" />
                    <parameter name="itemTypeName" />
                    <parameter name="accountCode" />
                    <parameter name="accountName" />
                </parameter>
            </parameter>
        </in-parameters>
        <actions>
            <script>System.out.println(">>>>importing ${itemTypes?.size()} item types")</script>
            <set field="itemTypesImported" type="Integer" value="0" />
            <service-call name="growerp.100.GeneralServices100.get#RelatedCompanyAndOwner"
                out-map="context" />
            <!-- delete existing -->
            <entity-delete-by-condition entity-name="mantle.ledger.config.ItemTypeGlAccount">
                <econdition field-name="organizationPartyId" from="companyPartyId" />
            </entity-delete-by-condition>
            <!-- create new -->
            <iterate list="itemTypes" entry="itemType">
                <entity-find entity-name="growerp.ledger.account.GlAccountAndOrganization"
                    list="glAccounts">
                    <econdition field-name="partyId" from="companyPartyId" />
                    <econdition field-name="accountCode" from="itemType.accountCode" />
                </entity-find>
                <if condition="!glAccounts">
                    <script>System.out.println(">>>Could not find accountCode: ${itemType.accountCode} for company: $companyPartyId")</script>
                    <else>
                        <service-call name="create#mantle.ledger.config.ItemTypeGlAccount"
                            in-map="[
                                itemTypeEnumId: itemType.itemTypeId,
                                organizationPartyId: companyPartyId,
                                direction: itemType.direction,
                                glAccountId: glAccounts[0].glAccountId,
                            ]" />
                        <script>itemTypesImported++;</script>
                    </else>
                </if>
            </iterate>
            <if condition="!ec.message.hasError()">
                <script>System.out.println(">>>${itemTypesImported} itemTypes imported")</script>
            </if>
        </actions>
    </service>

    <service verb="import" noun="PaymentTypes">
        <description> Import PaymentTypes</description>
        <in-parameters>
            <parameter name="paymentTypes" required="true" type="List">
                <parameter name="paymentType" type="Map">
                    <parameter name="paymentTypeId" />
                    <parameter name="isPayable" type="Boolean" />
                    <parameter name="isApplied" type="Boolean" />
                    <parameter name="paymentTypeName" />
                    <parameter name="accountCode" />
                    <parameter name="accountName" />
                </parameter>
            </parameter>
        </in-parameters>
        <actions>
            <script>System.out.println(">>>>importing ${paymentTypes?.size()} paymentTypes")</script>
            <set field="paymentTypesImported" type="Integer" value="0" />
            <set field="paymentTypesIgnored" type="Integer" value="0" />
            <service-call name="growerp.100.GeneralServices100.get#RelatedCompanyAndOwner"
                out-map="context" />
            <!-- delete existing -->
            <entity-delete-by-condition entity-name="mantle.ledger.config.PaymentTypeGlAccount">
                <econdition field-name="organizationPartyId" from="companyPartyId" />
            </entity-delete-by-condition>
            <!-- create new -->
            <iterate list="paymentTypes" entry="paymentType">
                <set field="glAccountId" from="null" />
                <if
                    condition="paymentType.accountCode &amp;&amp; !paymentType.accountCode.isEmpty()">
                    <entity-find entity-name="growerp.ledger.account.GlAccountAndOrganization"
                        list="glAccounts">
                        <econdition field-name="partyId" from="companyPartyId" />
                        <econdition field-name="accountCode" from="paymentType.accountCode" />
                    </entity-find>
                    <if condition="!glAccounts">
                        <return error="true"
                            message="Could not find accountCode: ${paymentType.accountCode} for company: $companyPartyId" />
                        <else>
                            <set field="glAccountId" from="glAccounts[0].glAccountId" />
                        </else>
                    </if>
                    <service-call name="create#mantle.ledger.config.PaymentTypeGlAccount"
                        in-map="[   paymentTypeEnumId: paymentType.paymentTypeId,
                                organizationPartyId: companyPartyId,
                                isPayable: paymentType.isPayable == true ? 'Y' : 'N',
                                isApplied: paymentType.isApplied == true ? 'Y' : 'N',
                                glAccountId: glAccountId,
                            ]" />
                    <script>paymentTypesImported++;</script>
                    <else>
                        <script>System.out.println(">>> PaymentType ${paymentType.paymentTypeId} ignored: GLAccount empty")</script>
                        <script>paymentTypesIgnored++;</script>
                    </else>
                </if>
            </iterate>
            <if condition="!ec.message.hasError()">
                <script>System.out.println(">>>${paymentTypesImported} paymentTypes imported ${paymentTypesIgnored} ignored")</script>
            </if>
        </actions>
    </service>

    <service verb="import" noun="GlAccounts">
        <description> Import GlAccounts</description>
        <in-parameters>
            <parameter name="glAccounts" type="List" required="true">
                <parameter name="glAccount" type="Map">
                    <parameter name="glAccountId" />
                    <parameter name="accountCode" />
                    <parameter name="accountName" />
                    <parameter name="level" />
                    <parameter name="beginningBalance" />
                    <parameter name="postedDebits" />
                    <parameter name="postedCredits" />
                    <parameter name="postedBalance" />
                </parameter>
            </parameter>
            <parameter name="classificationId" />
        </in-parameters>
        <actions>
            <script>System.out.println(">>>>importing ${glAccounts?.size()} GL Accounts")</script>
            <set field="glAccountsImported" type="Integer" value="0" />
            <set field="glAccountsUpdated" type="Integer" value="0" />
            <service-call name="growerp.100.GeneralServices100.get#RelatedCompanyAndOwner"
                out-map="relComp" />
            <!-- delete existing transactions only initial if present-->
            <entity-find entity-name="mantle.ledger.transaction.AcctgTrans" list="transList">
                <econdition field-name="organizationPartyId" from="relComp.companyPartyId" />
            </entity-find>
            <if condition="transList.size() &gt; 1">
                <return error="true"
                    message="Can only delete ledger when when not more than the initial settiung of posted balance." />
            </if>
            <if condition="!transList.isEmpty()">
                <entity-delete-by-condition
                    entity-name="mantle.ledger.transaction.AcctgTransEntry">
                    <econdition field-name="acctgTransId" from="transList[0].acctgTransId" />
                </entity-delete-by-condition>
                <entity-delete-by-condition entity-name="mantle.ledger.transaction.AcctgTrans">
                    <econdition field-name="acctgTransId" from="transList[0].acctgTransId" />
                </entity-delete-by-condition>
            </if>
            <!-- delete existing ledger only if input file has account description and class 
                when not assume an update of the initial posting values-->
            <if
                condition="!glAccounts[0].accountName.isEmpty() &amp;&amp; !glAccounts[0].accountClass.description.isEmpty()">
                <entity-find entity-name="mantle.ledger.account.GlAccountAndOrganization"
                    list="glAccountsOrg">
                    <econdition field-name="organizationPartyId" from="relComp.companyPartyId" />
                    <select-field field-name="glAccountId" />
                </entity-find>
                <entity-delete-by-condition
                    entity-name="mantle.ledger.account.GlAccountOrganization">
                    <econdition field-name="organizationPartyId" from="relComp.companyPartyId" />
                </entity-delete-by-condition>
                <entity-delete-by-condition
                    entity-name="mantle.ledger.account.GlAccount">
                    <econdition field-name="glAccountId" operator="in" from="glAccountsOrg" />
                </entity-delete-by-condition>
                <!-- delete item types-->
                <entity-delete-by-condition entity-name="mantle.ledger.config.ItemTypeGlAccount">
                    <econdition field-name="organizationPartyId" from="relComp.companyPartyId" />
                </entity-delete-by-condition>
                <!-- delete payment types-->
                <entity-delete-by-condition entity-name="mantle.ledger.config.PaymentTypeGlAccount">
                    <econdition field-name="organizationPartyId" from="relComp.companyPartyId" />
                </entity-delete-by-condition>
            </if>
            <!-- create new accounts and collect posted balances for new transactions-->
            <set field="transactions" from="[]" />
            <iterate list="glAccounts" entry="newGlAccount">
                <if condition="newGlAccount.accountCode.isEmpty()">
                    <continue />
                </if>
                <!-- check if glaccount exist update just posted value is present -->
                <entity-find entity-name="mantle.ledger.account.GlAccountAndOrganization"
                    list="glAccountsOrg">
                    <econdition field-name="organizationPartyId" from="relComp.companyPartyId" />
                    <econdition field-name="accountCode" from="newGlAccount.accountCode" />
                </entity-find>
                <if condition="!glAccountsOrg">
                    <service-call name="growerp.100.AccountingServices100.create#GlAccount"
                        in-map="[glAccount: newGlAccount]"
                        out-map="createdGlAccount" />
                    <script>glAccountsImported++</script>
                    <set field="newGlAccountId" from="createdGlAccount.glAccount.glAccountId" />
                    <set field="isDebit" from="createdGlAccount.glAccount.isDebit" />
                    <else>
                        <set field="newGlAccountId" from="glAccountsOrg[0].glAccountId" />
                        <set field="isDebit" from="glAccountsOrg[0].isDebit == 'Y' ? true : false"
                            type="Boolean" />
                        <script>System.out.println(">>>>importing existing GlAccount: ${newGlAccount?.glAccountId}")</script>
                        <script>glAccountsUpdated++</script>
                    </else>
                </if>
                <!-- collect posted balances -->
                <if condition="newGlAccount.postedBalance">
                    <set field="isPositive" value="true" type="Boolean" />
                    <if condition="newGlAccount.postedBalance.startsWith('-')">
                        <set field="isPositive" value="false" type="Boolean" />
                    </if>
                    <script>transactions.add([
                        isDebit: isDebit == isPositive 
                            ? isDebit : !isDebit,
                        price: new BigDecimal(newGlAccount.postedBalance.replace('-','')),
                        glAccount: [glAccountId: newGlAccountId],
                        ])</script>
                </if>
            </iterate>
            <!-- create posted balance in initial transaction-->
            <if condition="!transactions.isEmpty()">
                <service-call name="growerp.100.FinDocServices100.create#FinDoc"
                    in-map="finDoc: [docType: 'transaction', sales: 'true', isPosted: true,
                                            description: 'Initial balance',
                                            items: transactions]"
                    out-map="context" />
            </if>
            <!-- recalculate posted summary-->
            <service-call name="growerp.100.AccountingServices100.recalculate#GlAccountOrgSummaries"
                in-map="companyPartyId: relComp.companyPartyId" />
            <if condition="!ec.message.hasError()">
                <script>System.out.println(">>>${glAccountsImported} glAccounts imported, updated: ${glAccountsUpdated}")</script>
            </if>
        </actions>
    </service>

    <service verb="import" noun="Companies">
        <in-parameters>
            <parameter name="companies" type="List">
                <parameter name="company" type="Map">
                    <parameter name="partyId" />
                    <parameter name="pseudoId" />
                    <parameter name="name" />
                    <parameter name="email" />
                    <parameter name="role" />
                    <parameter name="email" />
                    <parameter name="currency" type="Map">
                        <parameter name="currencyId" />
                        <parameter name="description" />
                    </parameter>
                    <parameter name="vatPerc">
                        <description>Percentage used for VAT if applicable</description>
                    </parameter>
                    <parameter name="salesPerc">
                        <description>Percentage used for sales tax</description>
                    </parameter>
                </parameter>
            </parameter>
            <parameter name="classificationId" />
        </in-parameters>
        <actions>
            <script>System.out.println(">>>===== importing ${companies?.size()} companies")</script>
            <service-call
                name="growerp.100.GeneralServices100.get#RelatedCompanyAndOwner"
                out-map="context" />
            <set field="companiesImported" type="Integer" value="0" />
            <iterate list="companies" entry="company">
                <if condition="company.partyId == '_MOD_'"><!-- used in automated test-->
                    <entity-find entity-name="growerp.party.OwnerCompanyDetailAndEmployee"
                        list="parties">
                        <econdition field-name="ownerPartyId" from="ownerPartyId" />
                        <econdition field-name="companyName" operator="like"
                            value="${company.name}%" />
                    </entity-find>
                    <if condition="!parties.isEmpty()">
                        <set field="company.partyId" from="parties[0].companyPartyId" />
                        <service-call name="growerp.100.PartyServices100.update#Company"
                            in-map="[company: company]" />
                        <script>companiesImported++;</script>
                    </if>
                    <else>
                        <if condition="!company.role">
                            <script>System.out.println(">>>Company id: ${company.pseudoId} ${company.name} not processed, role is missing!")</script>
                            <continue />
                        </if>
                        <if condition="!company.name">
                            <script>System.out.println(">>>Company id: ${company.pseudoId} ${company.name} name is missing, set to pseudoId!")</script>
                            <set field="company.name" from="company.pseudoId" />
                        </if>
                        <if
                            condition="company.email &amp;&amp; company.email != '' &amp;&amp; !org.apache.commons.validator.routines.EmailValidator.getInstance().isValid(company.email)">
                            <script>System.out.println(">>>Company id: ${company.pseudoId} ${company.name} email: ${company.email} is not valid")</script>
                            <set field="company.email" value="" />
                        </if>
                        <!-- main company already exist so need update -->
                        <if condition="company.role == 'OrgInternal'">
                            <entity-find entity-name="growerp.party.OwnerCompanyDetailAndEmployee"
                                list="mainCompanies">
                                <econdition field-name="companyRole" value="OrgInternal" />
                                <econdition field-name="ownerPartyId" from="ownerPartyId" />
                            </entity-find>
                            <if condition="mainCompanies.isEmpty()">
                                <script>System.out.println(">>>Main company supplied but cannot find within owner: $ownerPartyId")</script>
                                <else>
                                    <set field="company.partyId"
                                        from="mainCompanies[0].companyPartyId" />
                                    <service-call
                                        name="growerp.100.PartyServices100.update#Company"
                                        in-map="[company: company]" />
                                    <script>companiesImported++;</script>
                                    <continue />
                                </else>
                            </if>
                        </if>
                        <!-- check if company already exist -->
                        <entity-find entity-name="mantle.party.Party" list="parties">
                            <econdition field-name="pseudoId" from="company.pseudoId" />
                            <econdition field-name="ownerPartyId" from="ownerPartyId" />
                        </entity-find>
                        <if condition="!parties.isEmpty()">
                            <then>
                                <entity-find entity-name="mantle.party.PartyRole" list="roles">
                                    <econdition field-name="partyId" from="parties[0].partyId" />
                                    <econdition field-name="roleTypeId" from="company.role" />
                                </entity-find>
                                <if condition="roles.isEmpty()">
                                    <service-call name="create#mantle.party.PartyRole"
                                        in-map="[   partyId: parties[0].partyId,
                                                        roleTypeId: company.role]" />
                                    <else>
                                        <script>System.out.println(">>>Company: ${company.name} not processed, pseudoId: ${company.pseudoId} ${company.role} already exist!")</script>
                                    </else>
                                </if>
                            </then>
                            <else>
                                <service-call
                                    name="growerp.100.PartyServices100.create#Company"
                                    in-map="[company: company]" />
                                <script>companiesImported++;</script>
                            </else>
                        </if>
                    </else>
                </if>
            </iterate>
            <if condition="!ec.message.hasError()">
                <script>System.out.println(">>>===== $companiesImported companies imported")</script>
            </if>
        </actions>
    </service>

    <service verb="import" noun="Users">
        <in-parameters>
            <parameter name="users" type="List" required="true">
                <parameter name="user" type="Map">
                    <parameter name="partyId" />
                    <parameter name="pseudoId" />
                    <parameter name="email" />
                    <parameter name="role" />
                    <parameter name="firstName" />
                    <parameter name="lastName" />
                    <parameter name="loginDisabled" type="Boolean" />
                    <parameter name="loginName" />
                    <parameter name="userGroupId" />
                    <parameter name="groupDescription" />
                    <parameter name="language" />
                    <parameter name="address" type="Map">
                        <parameter name="addressId" />
                        <parameter name="address1" />
                        <parameter name="address2" />
                        <parameter name="city" />
                        <parameter name="postalCode" />
                        <parameter name="province" />
                        <parameter name="provinceId" />
                        <parameter name="country" />
                        <parameter name="countryId" />
                    </parameter>
                    <parameter name="paymentMethod" type="Map">
                        <parameter name="ccPaymentMethodId" />
                        <parameter name="ccDescription" />
                    </parameter>
                    <parameter name="company" type="Map">
                        <parameter name="partyId" />
                        <parameter name="pseudoId" />
                        <parameter name="name" />
                        <parameter name="email" />
                        <parameter name="role" />
                    </parameter>
                    <parameter name="image" />
                    <parameter name="userId" />
                    <parameter name="locale" />
                    <parameter name="telephoneNr" />
                    <parameter name="appsUsed" type="List">
                        <parameter name="partyClassificationId" />
                    </parameter>
                </parameter>
            </parameter>
        </in-parameters>
        <actions>
            <script>System.out.println(">>>>importing ${users?.size()} users")</script>
            <set field="usersImported" type="Integer" value="0" />
            <iterate list="users" entry="user">
                <service-call name="growerp.100.PartyServices100.create#User"
                    in-map="[user: user]" />
                <script>usersImported++;</script>
            </iterate>
            <if condition="!ec.message.hasError()">
                <script>System.out.println(">>>${usersImported} users imported")</script>
            </if>
        </actions>
    </service>

    <service verb="import" noun="CompanyUsers">
        <in-parameters>
            <parameter name="companyUsers" type="List" required="true">
                <parameter name="pseudoId" />
                <parameter name="partyType" />
                <parameter name="role" />
                <parameter name="email" />
                <parameter name="url" />
                <parameter name="name" />
                <parameter name="telephoneNr" />
                <parameter name="address" type="Map">
                    <parameter name="address1" />
                    <parameter name="address2" />
                    <parameter name="city" />
                    <parameter name="postalCode" />
                    <parameter name="province" />
                    <parameter name="provinceId" />
                    <parameter name="country" />
                    <parameter name="countryId" />
                </parameter>
                <parameter name="paymentMethod">
                    <parameter name="ccPaymentMethodId" />
                    <parameter name="ccDescription" />
                </parameter>
                <parameter name="company" type="Map">
                    <parameter name="name" />
                    <parameter name="pseudoId" />
                </parameter>
            </parameter>
        </in-parameters>
        <actions>
            <script>System.out.println(">>>>importing ${companysUsers?.size()} company/users")</script>
            <service-call name="growerp.100.GeneralServices100.get#RelatedCompanyAndOwner"
                out-map="context" />
            <set field="imported" type="Integer" value="0" />
            <iterate list="companyUsers" entry="companyUser">
                <if condition="companyUser.toString().replaceAll(' ','').isEmpty()">
                    <continue />
                </if>
                <!-- validate -->
                <if condition="!['Company','User'].contains(companyUser.type)">
                    <return error="true"
                        message="Invalid type value: ${companyUser.type} valid: 'Company','User'" />
                </if>
                <if
                    condition="!['OrgInternal','Customer','Lead','Supplier'].contains(companyUser.role)">
                    <return error="true"
                        message="Invalid role value: ${companyUser.role} valid: 'Customer','Lead','Supplier'" />
                </if>

                <!-- check if company exist for either company or company within user -->
                <if
                    condition="(companyUser.type == 'Company' &amp;&amp; companyUser.pseudoId != null) || 
                                                companyUser.company?.pseudoId != null">
                    <if condition="companyUser.type == 'Company'">
                        <set field="pseudoId" from="companyUser.pseudoId" />
                        <set field="name" from="companyUser.name" />
                        <else>
                            <set field="pseudoId" from="companyUser.company?.pseudoId" />
                            <set field="name" from="companyUser.company?.name" />
                        </else>
                    </if>
                    <entity-find entity-name="growerp.party.OwnerCompany"
                        list="companies" limit="1">
                        <econdition field-name="ownerPartyId" from="ownerPartyId" />
                        <econdition field-name="pseudoId"
                            from="pseudoId"
                            ignore-if-empty="true" />
                        <econdition field-name="name"
                            from="name"
                            ignore-if-empty="true" />
                    </entity-find>
                </if>

                <if condition="companyUser.type == 'User'">
                    <then>
                        <if condition="companies">
                            <set field="companyUser.company"
                                from="companyUser.company + [partyId: companies[0].partyId]" />
                        </if>
                        <!-- process first/last name -->
                        <if condition="companyUser.name">
                            <if condition="!companyUser.name.contains(',')">
                                <if condition="companyUser.name.contains(' ')">
                                    <set field="companyUser.name"
                                        from="companyUser.name.replace(' ',',')" />
                                </if>
                            </if>
                            <set field="companyUser.name"
                                from="companyUser.name.replace(' ','')" />
                            <if condition="companyUser.name.split(',').size() &gt; 1">
                                <set field="firstName" from="companyUser.name.split(',')[0]" />
                                <set field="lastName" from="companyUser.name.split(',')[1]" />
                            </if>
                        </if>
                        <set field="user"
                            from="companyUser + [
                                        firstName: firstName,
                                        lastName: lastName,
                                        company: company,
                                    ]" />
                        <service-call name="growerp.100.PartyServices100.create#User"
                            out-map="result"
                            in-map="[user: user, classificationId: classificationId]" />
                    </then>

                    <else-if condition="companyUser.type == 'Company'">
                        <if condition="!companies">
                            <service-call
                                name="growerp.100.PartyServices100.create#Company"
                                out-map="result"
                                in-map="[company: companyUser, classificationId: classificationId]" />
                            <else>
                                <service-call
                                    name="growerp.100.PartyServices100.update#Company"
                                    out-map="result"
                                    in-map="[company: companyUser, classificationId: classificationId]" />
                            </else>
                        </if>
                    </else-if>

                    <else>
                        <log level="error" message="Unknown party type: ${companyUser.type}" />
                    </else>
                </if>
                <set field="imported" from="imported + 1" />
            </iterate>

            <if condition="!ec.message.hasError()">
                <script>System.out.println(">>>${imported} companies/users imported")</script>
            </if>
        </actions>
    </service>

    <service verb="import" noun="Products">
        <in-parameters>
            <parameter name="products" required="true" type="List">
                <parameter name="product" required="true" type="Map">
                    <parameter name="pseudoId" />
                    <parameter name="productTypeId" />
                    <parameter name="assetClassId" />
                    <parameter name="productName" />
                    <parameter name="description" />
                    <parameter name="price" />
                    <parameter name="listPrice" />
                    <parameter name="categories" type="List">
                        <parameter name="category" type="Map">
                            <parameter name="categoryId" />
                            <parameter name="categoryName" />
                            <parameter name="description" />
                            <parameter name="image" />
                        </parameter>
                    </parameter>
                    <parameter name="useWarehouse" type="Boolean" />
                    <parameter name="image" />
                </parameter>
            </parameter>
            <parameter name="classificationId" required="true" />
        </in-parameters>
        <actions>
            <script>System.out.println(">>>>importing ${products?.size()} products")</script>
            <set field="productsImported" type="Integer" value="0" />
            <service-call name="growerp.100.GeneralServices100.get#RelatedCompanyAndOwner"
                out-map="relComp" />
            <script>ec.user.setEffectiveTime(Timestamp.valueOf("1999-01-01 00:00:00"))</script>
            <iterate list="products" entry="product">
                <!-- check if related category exist using name, if yes use these-->
                <iterate list="product.categories" entry="category">
                    <entity-find entity-name="mantle.product.category.ProductCategory"
                        list="foundCategories">
                        <econdition field-name="categoryName" from="category.categoryName" />
                        <econdition field-name="ownerPartyId" from="relComp.ownerPartyId" />
                    </entity-find>
                    <if condition="foundCategories">
                        <set field="category.categoryId"
                            from="foundCategories[0].productCategoryId" />
                    </if>
                </iterate>
                <entity-find entity-name="mantle.product.Product" list="products">
                    <econdition field-name="pseudoId" from="product.pseudoId" />
                    <econdition field-name="ownerPartyId" from="relComp.ownerPartyId" />
                </entity-find>
                <if condition="!products">
                    <service-call name="growerp.100.CatalogServices100.create#Product"
                        out-map="result"
                        in-map="[product: product, classificationId: classificationId]" />
                    <script>productsImported++</script>
                </if>
            </iterate>
            <if condition="!ec.message.hasError()">
                <script>System.out.println(">>>${productsImported} products imported")</script>
            </if>
        </actions>
    </service>

    <service verb="import" noun="Categories">
        <in-parameters>
            <parameter name="categories" required="true" type="List">
                <parameter name="category" type="Map" required="true">
                    <parameter name="pseudoId" />
                    <parameter name="categoryName" />
                    <parameter name="description" />
                    <parameter name="image" />
                </parameter>
            </parameter>
            <parameter name="classificationId" />
        </in-parameters>
        <actions>
            <script>System.out.println(">>>>importing ${categories?.size()} categories")</script>
            <script>ec.user.setEffectiveTime(Timestamp.valueOf("1999-01-01 00:00:00"))</script>
            <iterate list="categories" entry="category">
                <service-call name="growerp.100.CatalogServices100.create#ProductCategory"
                    in-map="[category: category, classificationId: classificationId]" />
            </iterate>
            <if condition="!ec.message.hasError()">
                <script>System.out.println(">>>${categories?.size()} categories imported")</script>
            </if>
        </actions>
    </service>

    <service verb="import" noun="Assets">
        <in-parameters>
            <parameter name="assets" required="true" type="List">
                <parameter name="classificationId" required="true" />
                <parameter name="asset" type="Map" required="true">
                    <parameter name="pseudoId" />
                    <parameter name="statusId" />
                    <parameter name="assetTypeId" />
                    <parameter name="assetClassId" />
                    <parameter name="assetName" />
                    <parameter name="quantityOnHand" />
                    <parameter name="availableToPromise" />
                    <parameter name="acquireCost" />
                    <parameter name="receivedDate" />
                    <parameter name="expectedEndOfLifeDate" />
                    <parameter name="product" type="Map">
                        <parameter name="productId" />
                        <parameter name="productTypeId" />
                        <parameter name="assetClassId" />
                        <parameter name="productName" />
                        <parameter name="description" />
                        <parameter name="price" />
                        <parameter name="listPrice" />
                        <parameter name="categories" type="List">
                            <parameter name="category" type="Map">
                                <parameter name="categoryId" />
                                <parameter name="categoryName" />
                                <parameter name="description" />
                                <parameter name="image" />
                            </parameter>
                        </parameter>
                        <parameter name="useWarehouse" type="Boolean" />
                        <parameter name="image" />
                    </parameter>
                    <parameter name="location" type="Map">
                        <parameter name="locationId" />
                        <parameter name="locationName" />
                    </parameter>
                </parameter>
            </parameter>
            <parameter name="classificationId" />
        </in-parameters>
        <actions>
            <script>System.out.println(">>>>importing ${assets?.size()} assets")</script>
            <iterate list="assets" entry="asset">
                <service-call name="growerp.100.InventoryServices100.create#Asset"
                    out-map="result"
                    in-map="[asset: asset, classificationId: classificationId]" />
            </iterate>
            <if condition="!ec.message.hasError()">
                <script>System.out.println(">>>${assets?.size()} assets imported")</script>
            </if>
        </actions>
    </service>

    <service verb="import" noun="FinDocs">
        <in-parameters>
            <parameter name="finDocs" required="true" type="List">
                <parameter name="finDoc" type="Map" required="true">
                    <parameter name="docType" />
                    <parameter name="sales" type="Boolean" />
                    <parameter name="pseudoId" />
                    <parameter name="reference" />
                    <parameter name="statusId" />
                    <parameter name="paymentInstrument" />
                    <parameter name="description" />
                    <parameter name="otherUser" type="Map">
                        <parameter name="partyId" />
                    </parameter>
                    <parameter name="otherCompany" type="Map">
                        <parameter name="partyId" />
                        <parameter name="paymentMethod" type="Map">
                            <parameter name="ccPaymentMethodId" />
                        </parameter>
                    </parameter>
                    <parameter name="grandTotal" />
                    <parameter name="classificationId" />
                    <parameter name="isPosted" type="Boolean" />
                    <parameter name="journal">
                        <parameter name="journalId" />
                    </parameter>
                    <parameter name="requestType" />
                </parameter>
            </parameter>
            <parameter name="classificationId" />
        </in-parameters>
        <actions>
            <script>System.out.println(">>>>importing ${finDocs[0].sales == true ? 'Sales' : 'Purchase'} ${finDocs[0].docType} ${finDocs?.size()} finDocs")</script>
            <set field="finDocsImported" type="Integer" value="0" />
            <set field="companiesCreated" type="Integer" value="0" />
            <service-call out-map="context"
                name="growerp.100.GeneralServices100.get#RelatedCompanyAndOwner" />
            <!-- check if we have a timeperiod here just for transactions.....-->
            <if condition="finDocs[0].docType == 'transaction'">
                <!-- date-filter does not seem to work here date: 2010-12-31 not found!-->
                <entity-find entity-name="mantle.party.time.TimePeriod" list="periods">
                    <econdition field-name="partyId" from="companyPartyId" />
                    <econdition field-name="fromDate" operator="less-equals"
                        from="Timestamp.valueOf(finDocs[0].creationDate)" />
                    <econdition field-name="thruDate" operator="greater-equals"
                        from="Timestamp.valueOf(finDocs[0].creationDate)" />
                </entity-find>
                <!-- when not yet create all until next year -->
                <if condition="!periods">
                    <script>System.out.println(">>>Creating time periods starting with ${finDocs[0].creationDate.substring(0,4)} for company $companyPartyId")</script>
                    <!-- delete existing timeperiods-->
                    <entity-find entity-name="mantle.party.time.TimePeriod" list="periods">
                        <econdition field-name="partyId" from="companyPartyId" />
                        <order-by field-name="-timePeriodId" />
                    </entity-find>
                    <iterate list="periods.timePeriodId" entry="id">
                        <entity-delete-by-condition entity-name="mantle.party.time.TimePeriod">
                            <econdition field-name="partyId" from="companyPartyId" />
                            <econdition field-name="timePeriodId" from="id" />
                        </entity-delete-by-condition>
                    </iterate>
                    <!-- create new yearly, quartely, monthly periods until next year-->
                    <set field="nextYearInt"
                        from="((Calendar) ec.user.nowCalendar).get(Calendar.YEAR) + 1" />
                    <set field="lastYear" from="ec.l10n.format(nextYearInt, '0000')" />

                    <!-- start year from first tranaction ordered by date -->
                    <set field="curYear" from="finDocs[0].creationDate.substring(0,4)" />
                    <set field="prevPeriodId" from="null" />
                    <while condition="curYear &lt;= lastYear">
                        <set field="fromDate"
                            from="ec.l10n.parseDate(curYear + '-01-01', 'yyyy-MM-dd')" />
                        <service-call name="mantle.party.TimeServices.getOrCreate#TimePeriod"
                            out-map="curYearOut"
                            in-map="[partyId:companyPartyId, timePeriodTypeId:'FiscalYear', fromDate:fromDate, previousPeriodId:prevPeriodId]" />
                        <service-call name="mantle.party.TimeServices.get#DescendantPeriods"
                            out-map="quartersOut"
                            in-map="[parentPeriodId:curYearOut.timePeriodId, timePeriodTypeId:'FiscalQuarter', createMissing:true]" />
                        <iterate list="quartersOut.timePeriodList" entry="quarterPeriod">
                            <service-call name="mantle.party.TimeServices.get#DescendantPeriods"
                                out-map="quartersOut"
                                in-map="[parentPeriodId:quarterPeriod.timePeriodId, timePeriodTypeId:'FiscalMonth', createMissing:true]" />
                        </iterate>
                        <set field="prevPeriodId" from="curYearOut.timePeriodId" />
                        <set field="curYear" from="((curYear as int) + 1) as String" />
                    </while>
                    <entity-find-count entity-name="mantle.party.time.TimePeriod"
                        count-field="periods">
                        <econdition field-name="partyId" from="companyPartyId" />
                    </entity-find-count>
                </if>
            </if>
            <iterate list="finDocs" entry="finDoc">
                <!-- change system date -->
                <script>ec.user.setEffectiveTime(Timestamp.valueOf(finDoc.creationDate))</script>
                <!-- find partyId of other company-->
                <if condition="!finDoc.otherCompany.pseudoId &amp;&amp; finDoc.otherCompany.name">
                    <set field="finDoc.otherCompany.pseudoId" from="finDoc.otherCompany.name" />
                </if>
                <!-- translate pseudoId to moqui Id -->
                <if condition="finDoc.otherCompany &amp;&amp; finDoc.otherCompany.pseudoId">
                    <entity-find entity-name="mantle.party.Party" list="parties">
                        <econdition field-name="pseudoId" from="finDoc.otherCompany.pseudoId" />
                        <econdition field-name="ownerPartyId" from="ownerPartyId" />
                    </entity-find>
                    <if condition="parties">
                        <!--log
                            message="=====result from: ${finDoc.otherCompany.pseudoId} to ${parties[0].partyId}" /-->
                        <set field="finDoc.otherCompany.partyId" from="parties[0].partyId" />
                        <else-if
                            condition="finDoc.otherCompany.pseudoId &amp;&amp; finDoc.otherCompany.name">
                            <!-- create company -->
                            <if condition="finDoc.sales">
                                <set field="finDoc.otherCompany.role" value="Customer" />
                                <else>
                                    <set field="finDoc.otherCompany.role" value="Supplier" />
                                </else>
                            </if>
                            <service-call name="growerp.100.PartyServices100.create#Company"
                                in-map="[company: finDoc.otherCompany, ownerPartyId: ownerPartyId]"
                                out-map="context" />
                            <set field="finDoc.otherCompany.partyId" from="company.partyId" />
                            <script>companiesCreated++</script>
                        </else-if>
                        <else>
                            <script>System.out.println(">>>Import finDocId ${finDoc.pseudoId} company pseudoId: ${finDoc.otherCompany.pseudoId} not found under owner: $ownerPartyId : need also name to add")</script>
                        </else>
                    </if>
                </if>
                <!-- transaction posted-->
                <if condition="finDoc.docType == 'transaction'">
                    <set field="finDoc.isPosted" value="false" type="Boolean" />
                </if>
                <!-- create findoc-->
                <set field="finDoc.statusId" value="FinDocCreated" />
                <service-call name="growerp.100.FinDocServices100.create#FinDoc"
                    in-map="[finDoc: finDoc, classificationId: classificationId]"
                    out-map="resultCreateFindoc" />
                <script>finDocsImported++</script>
                <!-- create references-->
                <if condition="finDoc.docType == 'invoice'">
                    <if condition="finDoc.reference">
                        <!-- find transaction for invoice-->
                        <entity-find entity-name="mantle.ledger.transaction.AcctgTrans"
                            list="transactions" for-update="true">
                            <econdition field-name="organizationPartyId" from="companyPartyId" />
                            <econdition field-name="theirAcctgTransId" from="finDoc.reference" />
                        </entity-find>
                        <if condition="!transactions">
                            <script>System.out.println(">>>Import : could not find transaction for ${finDoc.sales?'sales':'purchase'} invoice ${resultCreateFindoc.finDoc.invoiceId} reference ${finDoc.reference}")</script>
                            <else>
                                <if condition="!transactions[0].invoiceId">
                                    <!-- ok found empty transaction -->
                                    <set field="transactions[0].invoiceId"
                                        from="resultCreateFindoc.finDoc.invoiceId" />
                                    <entity-update value-field="transactions[0]" />
                                    <else>
                                        <script>System.out.println(">>>Transaction: ${transactions[0].acctgTransId}/${transactions[0].pseudoId} already has invoiceId: ${transactions[0].invoiceId} cannot add ${finDoc.sales?'sales':'purchase'} ${resultCreateFindoc.finDoc.invoiceId} reference: ${finDoc.reference} otherCompany: ${finDoc.otherCompany.partyId} trans other partyId: ${transactions[0].otherPartyId}")</script>
                                    </else>
                                </if>
                            </else>
                        </if>
                    </if>
                </if>
                <!-- incoming receipts-->
                <if condition="finDoc.docType == 'payment' &amp;&amp; finDoc.sales == true">
                    <!-- find transaction for payment-->
                    <entity-find entity-name="mantle.ledger.transaction.AcctgTrans"
                        list="transactions" for-update="true">
                        <econdition field-name="organizationPartyId" from="companyPartyId" />
                        <econdition field-name="theirAcctgTransId" from="finDoc.reference" />
                        <econdition field-name="otherPartyId" from="finDoc.otherCompany.partyId" />
                    </entity-find>
                    <if condition="!transactions">
                        <script>System.out.println(">>>Import : could not find transaction ${finDoc.sales?'sales':'purchase'} payment ${resultCreateFindoc.finDoc.paymentId} reference ${finDoc.reference}  otherCompany: ${finDoc.otherCompany.partyId}")</script>
                        <else>
                            <if condition="!transactions[0].paymentId">
                                <!-- ok found empty transaction -->
                                <set field="transactions[0].paymentId"
                                    from="resultCreateFindoc.finDoc.paymentId" />
                                <entity-update value-field="transactions[0]" />
                                <else>
                                    <script>System.out.println(">>>Transaction: ${transactions[0].acctgTransId}/${transactions[0].pseudoId} already has ${finDoc.sales?'sales':'purchase'} paymentId: ${transactions[0].paymentId} cannot add ${resultCreateFindoc.finDoc.paymentId} reference: ${finDoc.reference} otherCompany: ${finDoc.otherCompany.partyId} trans other partyId: ${transactions[0].otherPartyId}")</script>
                                </else>
                            </if>
                        </else>
                    </if>
                </if>
                <!-- for payment use check number as reference into the ledger -->
                <if
                    condition="finDoc.docType == 'payment' &amp;&amp; finDoc.paymentMethod?.checkNumber">
                    <!--log
                        message="===looking for tranaction for payment with checknumber:
                    ${finDoc.paymentMethod?.checkNumber}" /-->
                    <entity-find entity-name="mantle.ledger.transaction.AcctgTrans"
                        list="transactions" for-update="true">
                        <econdition field-name="organizationPartyId" from="companyPartyId" />
                        <econdition field-name="theirAcctgTransId"
                            from="finDoc.paymentMethod?.checkNumber" />
                    </entity-find>
                    <if condition="!transactions">
                        <script>System.out.println(">>>Import : could not find transaction for ${finDoc.sales?'sales':'purchase'} payment ${resultCreateFindoc.finDoc.paymentId} checknumber ${finDoc.paymentMethod?.checkNumber}")</script>
                        <else>
                            <if condition="!transactions[0].paymentId">
                                <!-- ok found empty transaction -->
                                <set field="transactions[0].paymentId"
                                    from="resultCreateFindoc.finDoc.paymentId" />
                                <entity-update value-field="transactions[0]" />
                                <else>
                                    <script>System.out.println(">>>Transaction: ${transactions[0].acctgTransId}/${transactions[0].pseudoId} already has paymentId: ${transactions[0].paymentId} cannot add ${resultCreateFindoc.finDoc.sales?'sales':'purchase'} ${resultCreateFindoc.finDoc.paymentId} checkNr: ${finDoc.paymentMethod?.checkNumber} otherCompany: ${finDoc.otherCompany.partyId} trans: ${transactions[0].otherPartyId}")</script>
                                </else>
                            </if>
                        </else>
                    </if>
                </if>
                <!-- try to find invoice for payment -->
                <if condition="finDoc.docType == 'payment'">
                    <if condition="finDoc.sales == true">
                        <set field="fromPartyId" from="companyPartyId" />
                        <set field="toPartyId" from="null" />
                        <set field="pseudoIds" from="[finDoc.classificationId]" />
                        <else>
                            <set field="toPartyId" from="companyPartyId" />
                            <set field="fromPartyId" from="null" />
                            <set field="pseudoIds" from="finDoc.reference.split(',')" />
                        </else>
                    </if>
                    <iterate list="pseudoIds" entry="pseudoId">
                        <if condition="pseudoId == ''">
                            <continue />
                        </if>
                        <entity-find entity-name="mantle.account.invoice.Invoice" limit="3"
                            list="invoiceFound">
                            <econdition field-name="pseudoId" from="pseudoId" />
                            <econdition field-name="fromPartyId" ignore-if-empty="true" />
                            <econdition field-name="toPartyId" ignore-if-empty="true" />
                        </entity-find>
                        <!--log
                            message="looking from ${finDoc.sales ? 'sales' : 'purchase'} payment: ${finDoc.pseudoId} for
                        invoice: $pseudoId from: $fromPartyId to: $toPartyId result:
                        ${invoiceFound?.size()}" /-->
                        <if condition="invoiceFound">
                            <service-call name="update#mantle.account.payment.Payment"
                                in-map="[paymentId: resultCreateFindoc.finDoc.paymentId,
                                    forInvoiceId:  invoiceFound[0].invoiceId, status: 'PmntDelivered']" />
                            <service-call
                                name="mantle.account.PaymentServices.apply#PaymentForInvoice"
                                in-map="[paymentId: resultCreateFindoc.finDoc.paymentId]" />
                            <else>
                                <script>System.out.println(">>>could not find an invoice ${pseudoId} to apply for payment: ${resultCreateFindoc.finDoc.paymentId} amount: ${resultCreateFindoc.finDoc.grandTotal}")</script>
                            </else>
                        </if>
                    </iterate>
                </if>
                <!-- link invoices to order, so order should be created first -->
                <if condition="finDoc.docType == 'invoice' &amp;&amp; finDoc.classificationId">
                    <set field="pseudoId" from="finDoc.classificationId" />
                    <if condition="finDoc.sales == true">
                        <set field="vendorPartyId" from="companyPartyId" />
                        <set field="customerPartyId" from="null" />
                        <else>
                            <set field="customerPartyId" from="companyPartyId" />
                            <set field="vendorPartyId" from="null" />
                        </else>
                    </if>
                    <!--log
                        message="===looking for order from invoice:${resultCreateFindoc.finDoc.invoiceId} order pseudoId:
                    ${pseudoId} cust ${customerPartyId} vend: ${vendorPartyId}" /-->
                    <entity-find entity-name="mantle.order.OrderHeaderAndPart" limit="1"
                        list="orderFound">
                        <econdition field-name="pseudoId" from="pseudoId" />
                        <econdition field-name="customerPartyId" ignore-if-empty="true" />
                        <econdition field-name="vendorPartyId" ignore-if-empty="true" />
                    </entity-find>
                    <if condition="orderFound">
                        <service-call name="create#mantle.order.OrderItemBilling"
                            in-map="[invoiceId: resultCreateFindoc.finDoc.invoiceId, orderId: orderFound[0].orderId]" />
                        <else>
                            <script>System.out.println(">>>could not find an order ${pseudoId} from invoice: ${resultCreateFindoc.finDoc.pseudoId}[${resultCreateFindoc.finDoc.invoiceId}]")</script>
                        </else>
                    </if>
                </if>
                <if condition="finDoc.docType == 'shipment' &amp;&amp; finDoc.reference">
                    <!-- connect shipment to transaction -->
                    <entity-find entity-name="growerp.account.AcctgTransAndCompany"
                        list="transactions" limit="1">
                        <econdition field-name="companyPartyId" from="companyPartyId" />
                        <econdition field-name="theirAcctgTransId" from="finDoc.reference" />
                    </entity-find>
                    <if condition="transactions">
                        <if condition="transactions[0].shipmentId == null">
                            <service-call name="update#mantle.ledger.transaction.AcctgTrans"
                                in-map="transactions[0] + [shipmentId: resultCreateFindoc.finDoc.shipmentId] " />
                            <else>
                                <script>System.out.println(">>>transaction already has shipment: ${resultCreateFindoc.finDoc.shipmentId} could not create relation to shipment: ${resultCreateFindoc.finDoc.shipmentId} and reference: ${finDoc.reference}")</script>
                            </else>
                        </if>
                        <else>
                            <script>System.out.println(">>>transaction could not be found for shipment: ${resultCreateFindoc.finDoc.shipmentId} and reference: ${finDoc.reference}")</script>
                        </else>
                    </if>
                </if>
            </iterate>
            <if condition="!ec.message.hasError()">
                <script>System.out.println(">>>${finDocsImported} finDocs  ${finDocs[0].docType} imported, Companies created: ${companiesCreated}")</script>
            </if>
        </actions>
    </service>

    <service verb="import" noun="FinDocItems" transaction-timeout="3600">
        <in-parameters>
            <parameter name="finDocItems" required="true" type="List">
                <parameter name="items" type="List">
                    <parameter name="pseudoId" />
                    <parameter name="finDocType" />
                    <parameter name="itemSeqId" />
                    <parameter name="itemType" type="Map">
                        <parameter name="itemTypeId" />
                        <parameter name="itemTypeName" />
                    </parameter>
                    <parameter name="paymentType" type="Map">
                        <parameter name="paymentTypeId" />
                        <parameter name="paymentTypeName" />
                    </parameter>
                    <parameter name="productId" />
                    <parameter name="pseudoProductId" />
                    <parameter name="description" />
                    <parameter name="quantity" />
                    <parameter name="price" />
                    <parameter name="isDebit" type="Boolean" />
                    <parameter name="glAccount">
                        <parameter name="glAccountId" />
                    </parameter>
                    <parameter name="asset" type="Map">
                        <parameter name="assetId" />
                        <parameter name="assetName" />
                        <parameter name="location" type="Map">
                            <parameter name="locationId" />
                            <parameter name="locationName" />
                        </parameter>
                    </parameter>
                    <parameter name="rentalFromDate" />
                    <parameter name="rentalThruDate" />
                </parameter>
            </parameter>
            <parameter name="classificationId" required="true" />
        </in-parameters>
        <actions>
            <script>System.out.println(">>>>importing ${finDocItems?.size()} ${!finDocItems.isEmpty() ? finDocItems[0].docType : ''} items")</script>
            <set field="itemsImported" type="Integer" value="0" />
            <service-call out-map="context"
                name="growerp.100.GeneralServices100.get#RelatedCompanyAndOwner" />
            <set field="itemsOut" from="[]" />
            <set field="index" value="0" type="Integer" />
            <iterate list="finDocItems" entry="item">
                <!-- if document id changed-->
                <if condition="lastItem &amp;&amp; lastItem.pseudoId != item.pseudoId">
                    <!-- change current date -->
                    <script>ec.user.setEffectiveTime(Timestamp.valueOf("${finDoc.creationDate} 00:00:00"))</script>
                    <!-- get last document id-->
                    <service-call name="growerp.100.FinDocServices100.get#FinDoc" out-map="context"
                        in-map="[pseudoId: lastItem.pseudoId, docType: lastItem.docType,
                                classificationId: classificationId]" />
                    <if condition="finDocs.isEmpty()">
                        <!-- cannot find, so not try to add items -->
                        <script>System.out.println(">>>>importing ${lastItem.docType} items could not find company: $companyPartyId and pseudo: ${lastItem.pseudoId}")</script>
                        <else>
                            <set field="finDoc" from="finDocs[0]" />
                            <!-- add items collected below to finDoc[0] already got below-->
                            <set field="finDoc.items" from="itemsOut" />
                            <if condition="finDoc.docType == 'transaction'">
                                <set field="finDoc.isPosted" value="true" type="Boolean" />
                            </if>
                            <if condition="finDoc.docType == 'shipment' &amp;&amp; finDoc.reference">
                                <service-call
                                    name="growerp.100.ImportExportServices100.get#InvoiceItemsForShipmentQuantities"
                                    in-map="[companyPartyId: companyPartyId, finDoc: finDoc]"
                                    out-map="context" />
                                <!-- create shipment from order when found -->
                                <if condition="orderId">
                                    <service-call
                                        name="mantle.shipment.ShipmentServices.add#OrderPartToShipment"
                                        in-map="[orderId: orderId, orderPartSeqId: '01',
                                                shipmentId: finDoc.shipmentId]"
                                        out-map="context" />
                                </if>
                                <else>
                                    <!-- other doctypes -->
                                    <service-call name="growerp.100.FinDocServices100.update#FinDoc"
                                        in-map="[finDoc: finDoc, classificationId: classificationId]" />
                                </else>
                            </if>
                            <script>itemsImported += finDoc.items?.size()</script>
                        </else>
                    </if>
                    <set field="itemsOut" from="[]" />
                </if>
                <if condition="!lastItem || lastItem.pseudoId != item.pseudoId">
                    <!-- find related finDoc header -->
                    <service-call name="growerp.100.FinDocServices100.get#FinDoc"
                        in-map="[pseudoId: item.pseudoId, docType: item.docType]"
                        out-map="context" />
                    <if condition="finDocs.isEmpty()">
                        <script>System.out.println(">>>Import ${item.docType} pseudoId: ${item.pseudoId} not found")</script>
                        <set field="lastItem" from="null" />
                        <continue />
                        <else>
                            <set field="finDoc" from="finDocs[0]" />
                        </else>
                    </if>
                </if>
                <if condition="item.glAccount.accountCode">
                    <!-- find internal item glAccountId from glAccount.accountCode-->
                    <entity-find entity-name="growerp.ledger.account.GlAccountAndOrganization"
                        list="glAccounts">
                        <econdition field-name="partyId" from="companyPartyId" />
                        <econdition field-name="accountCode" from="item.glAccount.accountCode" />
                    </entity-find>
                    <if condition="glAccounts">
                        <set field="item.glAccount.glAccountId" from="glAccounts[0].glAccountId" />
                        <else>
                            <script>System.out.println(">>>id: ${item.pseudoId} could not find item accountCode ${item.glAccount.accountCode} for company: $companyPartyId")</script>
                        </else>
                    </if>
                    <if condition="finDocs[0].docType == 'transaction'">
                        <if condition="item.isDebit == null">
                            <set field="item.isDebit"
                                from="glAccounts[0].isDebit == 'Y' ? true : false" />
                        </if>
                    </if>
                </if>
                <if condition="!item.product.pseudoId.isEmpty()">
                    <!-- find productId from pseudoProductId -->
                    <entity-find entity-name="mantle.product.Product" list="products">
                        <econdition field-name="pseudoId" from="item.product.pseudoId" />
                        <econdition field-name="ownerPartyId" from="ownerPartyId" />
                    </entity-find>
                    <if condition="products">
                        <set field="item.product.productId" from="products[0].productId" />
                        <!-- update prices when on an invoice -->
                        <if condition="item.docType == 'invoice'">
                            <set field="priceMap"
                                from="[productId: products[0].productId,
                                    priceTypeEnumId: 'PptList',
                                    price: item.price,
                                    quantityUomId: 'OTH_ea',
                                    fromDate: ec.user.nowTimestamp,
                                    pricePurposeEnumId: 'PppPurchase']" />
                            <service-call name="create#mantle.product.ProductPrice"
                                in-map="priceMap" />
                            <service-call name="create#mantle.product.ProductPrice"
                                in-map="priceMap + [priceTypeEnumId: 'PptCurrent']" />
                        </if>
                        <else>
                            <!-- not found so better add it when not null -->
                            <if condition="item.pseudoProductId != null">
                                <script>System.out.println(">>>id: ${item.pseudoId} could not find pseudoProductId ${item.pseudoProductId} for owner: $ownerPartyId, will add it")</script>
                                <set field="product"
                                    from="[
                                    ownerPartyId: ownerPartyId,
                                    pseudoId: item.pseudoProductId,
                                    productTypeId: 'Physical Good',
                                    productName: item.description,
                                    price: item.price,
                                    listPrice: item.price,
                                    ]" />
                                <service-call name="growerp.100.CatalogServices100.create#Product"
                                    out-map="context"
                                    in-map="[product: product, classificationId: classificationId]" />
                                <set field="item.productId" from="product.productId" />
                            </if>
                        </else>
                    </if>
                </if>
                <!-- item type on orders if missing create some: -->
                <if condition="finDoc.docType == 'order' &amp;&amp; !item.itemType">
                    <script>System.out.println(">>>id: ${item.pseudoId} no item type for ${item.glAccount.glAccountId} set to ItemExpense")</script>
                    <set field="item.itemType" from="[itemTypeId: 'ItemExpense']" />
                </if>
                <script>itemsOut.add(item)</script>
                <set field="lastItem" from="item" />
            </iterate>
            <!-- process last record -->
            <if condition="lastItem">
                <script>ec.user.setEffectiveTime(Timestamp.valueOf("${finDoc.creationDate} 00:00:00"))</script>
                <!-- get current document id-->
                <service-call name="growerp.100.FinDocServices100.get#FinDoc" out-map="context"
                    in-map="[pseudoId: lastItem.pseudoId, docType: lastItem.docType,
                            classificationId: classificationId]" />
                <if condition="finDocs.isEmpty()">
                    <!-- cannot find, so not try to add items -->
                    <script>System.out.println(">>>>importing items ${lastItem.docType} could not find header ${lastItem.pseudoId}")</script>
                    <else>
                        <set field="finDoc" from="finDocs[0]" />
                        <!-- add items collected below to finDoc[0] already got below-->
                        <set field="finDoc.items" from="itemsOut" />
                        <if condition="finDoc.docType == 'transaction'">
                            <set field="finDoc.isPosted" value="true" type="Boolean" />
                        </if>
                        <if condition="finDoc.docType == 'shipment' &amp;&amp; finDoc.reference">
                            <service-call
                                name="growerp.100.ImportExportServices100.get#InvoiceItemsForShipmentQuantities"
                                in-map="[companyPartyId: companyPartyId, finDoc: finDoc]"
                                out-map="context" />
                            <!-- create shipment items from order when found -->
                            <if condition="orderId">
                                <service-call
                                    name="mantle.shipment.ShipmentServices.add#OrderPartToShipment"
                                    in-map="[orderId: orderId, orderPartSeqId: '01',
                                            shipmentId: finDoc.shipmentId]" />
                            </if>
                            <else>
                                <!-- other doctypes -->
                                <service-call name="growerp.100.FinDocServices100.update#FinDoc"
                                    in-map="[finDoc: finDoc, classificationId: classificationId]" />
                            </else>
                        </if>
                    </else>
                </if>
            </if>

            <!-- end of service result -->
            <if condition="!ec.message.hasError()">
                <script>System.out.println(">>>${itemsImported} findoc items ${finDocItems[0].docType} imported")</script>
            </if>
        </actions>
    </service>

    <service verb="get" noun="InvoiceItemsForShipmentQuantities">
        <in-parameters>
            <parameter name="companyPartyId" />
            <parameter name="finDoc" type="Map" />
        </in-parameters>
        <out-parameters>
            <parameter name="finDoc" type="Map" />
            <parameter name="orderId" />
        </out-parameters>
        <actions>
            <!-- looking for invoice of shipment to get quantity -->
            <if condition="finDoc.sales">
                <set field="fromPartyId" from="companyPartyId" />
                <else>
                    <set field="toPartyId" from="companyPartyId" />
                </else>
            </if>
            <!--log
                message="matching invoice ${finDoc.invoiceId}/${finDoc.pseudoId} on finDoc ref: ${finDoc.reference}
                    with fromPartyId: $fromPartyId toPartyId: $toPartyId sales: ${finDoc.sales}" /-->
            <entity-find entity-name="mantle.account.invoice.Invoice"
                list="invoices" limit="1">
                <econdition field-name="externalId" from="finDoc.reference" />
                <econdition field-name="fromPartyId" from="fromPartyId"
                    ignore-if-empty="true" />
                <econdition field-name="toPartyId" from="toPartyId" ignore-if-empty="true" />
            </entity-find>
            <if condition="invoices">
                <!-- find a matching invoice item to get quantity -->
                <entity-find entity-name="mantle.account.invoice.InvoiceItem"
                    list="invoiceItems">
                    <econdition field-name="invoiceId" from="invoices[0].invoiceId" />
                </entity-find>
                <set field="newShipmentItems" from="[]" />
                <iterate list="finDoc.items" entry="shipmentItem">
                    <set field="quantityUpdated" value="false" type="Boolean" />
                    <iterate list="invoiceItems" entry="invoiceItem">
                        <if
                            condition="shipmentItem.product?.productId &amp;&amp;
                                invoiceItem.productId == shipmentItem.product?.productId">
                            <script>newShipmentItems.add(
                                    shipmentItem + [quantity: invoiceItem.quantity])</script>
                            <set field="quantityUpdated" value="true" type="Boolean" />
                        </if>
                    </iterate>
                    <if condition="quantityUpdated == false">
                        <script>System.out.println(">>>Could not update shipment # quantity, shipmentId/productId: ${finDoc.shipmentId}/${shipmentItem.productId}  invoiceId/products: ${invoiceId}/${invoiceItems.productId}")</script>
                    </if>
                </iterate>
                <!-- connect to order-->
                <set field="invoice" from="invoices[0]" />
                <entity-find entity-name="mantle.order.OrderItemBilling" limit="1" list="billings"
                    for-update="true">
                    <econdition field-name="invoiceId" from="invoice.invoiceId" />
                </entity-find>
                <!-- get order from invoice -->
                <if condition="billings[0]?.orderId">
                    <set field="orderId" from="billings[0].orderId" />
                    <else>
                        <!-- create order from invoice-->
                        <entity-find entity-name="mantle.product.store.ProductStore" list="stores">
                            <econdition field-name="organizationPartyId" from="companyPartyId" />
                        </entity-find>
                        <set field="productStoreId" from="stores[0].productStoreId" />
                        <!-- create order -->
                        <entity-find entity-name="mantle.facility.Facility" list="facilities">
                            <econdition field-name="ownerPartyId" from="companyPartyId" />
                        </entity-find>
                        <if condition="finDoc.sales == true">
                            <set field="vendorPartyId" from="companyPartyId" />
                            <set field="customerPartyId" from="invoice.toPartyId" />
                            <else>
                                <set field="customerPartyId" from="companyPartyId" />
                                <set field="vendorPartyId" from="invoice.fromPartyId" />
                            </else>
                        </if>
                        <service-call out-map="context"
                            name="growerp.100.GeneralServices100.get#RelatedCompanyAndOwner" />
                        <service-call name="growerp.100.GeneralServices100.getNext#PseudoId"
                            in-map="[ownerPartyId: ownerPartyId, seqName: 'order']"
                            out-map="context" />
                        <if condition="finDoc.sales == true">
                            <entity-find entity-name="mantle.party.contact.PartyContactMech"
                                list="postalContactMechs">
                                <econdition field-name="partyId" from="customerPartyId" />
                                <econdition field-name="contactMechPurposeId" value="PostalPrimary" />
                            </entity-find>
                            <service-call name="mantle.order.OrderServices.create#Order"
                                in-map="[productStoreId: productStoreId,
                                        pseudoId: seqNum,
                                        facilityId: facilities[0].facilityId,
                                        vendorPartyId: vendorPartyId,
                                        customerPartyId: customerPartyId,
                                        postalContactMechId: postalContactMechs ? postalContactMechs[0].contactMechId : null,
                                        orderName: invoice.description]"
                                out-map="context" />
                            <else>
                                <service-call name="mantle.order.OrderServices.create#Order"
                                    in-map="[   
                                            facilityId: facilities[0].facilityId,
                                            pseudoId: seqNum,
                                            vendorPartyId: vendorPartyId,
                                            customerPartyId: customerPartyId,
                                            orderName: invoice.description]"
                                    out-map="context" />
                            </else>
                        </if>
                        <script>System.out.println(">>>Could not find related order for invoice " +
                            "${invoices[0].invoiceId} for company: $companyPartyId sales: " +
                            "${finDoc.sales} shipment: ${finDoc.shipmentId}/${finDoc.pseudoId} ref: " +
                            "${finDoc.reference} CREATED NEW ORDER: ${orderId}")</script>
                        <service-call name="growerp.100.FinDocServices100.replace#OrderItems"
                            in-map="[orderId: orderId,
                                         orderPartSeqId: orderPartSeqId,
                                         orderItems: newShipmentItems]" />

                        <if condition="billings">
                            <entity-update
                                value-field="billings[0] + [orderId: orderId, shipmentId: finDoc.shipmentId]" />
                            <else>
                                <service-call name="create#mantle.order.OrderItemBilling"
                                    in-map="[orderId: orderId, shipmentId: finDoc.shipmentId, invoiceId: invoices[0].invoiceId]" />
                            </else>
                        </if>
                    </else>
                </if>
                <!-- approve order -->
                <service-call name="mantle.order.OrderServices.place#Order"
                    in-map="[orderId: orderId, orderPartSeqId: '01']" />
                <service-call name="mantle.order.OrderServices.update#OrderStatus"
                    in-map="[orderId: orderId, orderPartSeqId: '01',statusId:'OrderApproved']" />
                <else>
                    <script>System.out.println(">>>Could not find related invoice for company: $companyPartyId sales: ${finDoc.sales} shipment: ${finDoc.shipmentId}/${finDoc.pseudoId} ref: ${finDoc.reference}")</script>
                </else>
            </if>
        </actions>
    </service>

    <service verb="finalize" noun="Import">
        <description> Post imported findocs of which the status is not finalized and already have a link
            in the ledger so the status will update but will not change the ledger</description>
        <in-parameters>
            <parameter name="limit" type="Integer" default="2000" />
            <parameter name="start" type="Integer" default="0" />
            <!-- closePeriod, approveInvoices, completePayments,
                completeInvoicesOrders, receiveShipments, sendShipments -->
            <parameter name="part" />
        </in-parameters>
        <out-parameters>
            <parameter name="limitOut" />
        </out-parameters>
        <actions>
            <service-call out-map="context"
                name="growerp.100.GeneralServices100.get#RelatedCompanyAndOwner" />
            <if condition="part == 'closePeriod'">
                <entity-find entity-name="mantle.party.time.TimePeriod"
                    list="periods" offset="start" limit="limit">
                    <econdition field-name="partyId" from="companyPartyId" />
                    <econdition field-name="timePeriodTypeId" value="FiscalYear" />
                    <econdition field-name="isClosed" value="N" />
                    <econdition field-name="periodNum" operator="less"
                        from="ec.user.nowTimestamp.getYear() + 1900" />
                    <order-by field-name="periodNum" />
                </entity-find>
                <iterate list="periods" entry="period">
                    <service-call name="mantle.party.TimeServices.get#TimePeriodInfo"
                        in-map="[period]" out-map="periodInfo" />
                    <set field="fromTimestamp" from="periodInfo.fromTimestamp" />
                    <set field="thruTimestamp" from="periodInfo.thruTimestamp" />

                    <!-- change system date to end of period -->
                    <script>ec.user.setEffectiveTime(thruTimestamp)</script>

                    <!-- with the assumption that the old system transactions  balance, group all
                        unposted transaction entries in a single transaction and post that -->
                    <entity-find entity-name="growerp.account.AcctgTransAndCompany"
                        list="unpostedTrans">
                        <econdition field-name="isPosted" operator="not-equals" value="Y"
                            or-null="true" />
                        <econdition field-name="companyPartyId" from="companyPartyId" />
                        <econdition field-name="transactionDate" operator="greater-equals"
                            from="fromTimestamp" />
                        <econdition field-name="transactionDate" operator="less-equals"
                            from="thruTimestamp" />
                    </entity-find>
                    <if condition="unpostedTrans">
                        <service-call name="growerp.100.GeneralServices100.getNext#PseudoId"
                            in-map="[ownerPartyId: ownerPartyId, seqName: 'transaction']"
                            out-map="context" />
                        <service-call name="create#mantle.ledger.transaction.AcctgTrans"
                            in-map="[pseudoId: seqNum, description: 'Conversion combined unposted entries',
                            organizationPartyId: companyPartyId]"
                            out-map="context" />
                        <!-- re-assign all unposted entries to one new transaction -->
                        <set field="index" value="1" type="Integer" />
                        <iterate list="unpostedTrans" entry="trans">
                            <entity-find entity-name="mantle.ledger.transaction.AcctgTransEntry"
                                list="transEntries" for-update="true">
                                <econdition field-name="acctgTransId" from="trans.transactionId" />
                            </entity-find>
                            <iterate list="transEntries" entry="transEntry">
                                <entity-delete value-field="transEntry" />
                                <set field="transEntry.acctgTransId" from="acctgTransId" />
                                <set field="transEntry.acctgTransEntrySeqId"
                                    from="(index++).toString()" />
                                <entity-create value-field="transEntry" />
                            </iterate>
                            <!-- delete original transaction -->
                            <service-call name="delete#mantle.ledger.transaction.AcctgTrans"
                                in-map="[acctgTransId: trans.transactionId]" />
                        </iterate>

                        <!-- post found entries -->
                        <service-call name="mantle.ledger.LedgerServices.post#AcctgTrans"
                            in-map="[acctgTransId: acctgTransId]" />
                        <script>System.out.println(">>>Grouped ${transEntries?.size()} unposted ledger entries in a single transaction and posted these")</script>
                    </if>
                    <!-- period should succeeed to close -->
                    <service-call name="growerp.100.AccountingServices100.close#FinancialTimePeriod"
                        in-map="[timePeriodId: period.timePeriodId, closeChildren: true]" />
                    <!-- calculate totals for the closed period -->
                    <!--log
                    message="=========recalculateclosing period ${period.periodName}" />
                    <service-call
                        name="mantle.ledger.LedgerServices.recalculate#GlAccountOrgSummaries"
                        in-map="[year: period.periodName.substring(1),
                                organizationPartyId: companyPartyId,
                                recalculateClosed: true]" /-->
                    <script>System.out.println(">>>Posted ledger time period ${period.periodName}")</script>
                </iterate>
                <set field="limit" from="periods? 0 :  -1" />
            </if>
            <!-- invoices -->
            <if condition="part == 'approveInvoices'">
                <entity-find entity-name="mantle.account.invoice.Invoice" list="invoices"
                    limit="limit" offset="start" for-update="true">
                    <econditions combine="or">
                        <econdition field-name="fromPartyId" from="companyPartyId" />
                        <econdition field-name="toPartyId" from="companyPartyId" />
                    </econditions>
                    <econditions combine="or">
                        <econdition field-name="statusId" value="InvoiceInProcess" />
                        <econdition field-name="statusId" value="InvoiceIncoming" />
                    </econditions>
                    <order-by field-name="invoiceDate" />
                </entity-find>
                <if condition="!invoices">
                    <set field="limitOut" value="-1" />
                    <return />
                </if>
                <script>System.out.println(">>>Approving ${invoices?.size()} invoices}")</script>
                <set field="updatedCount" value="0" type="Integer" />
                <set field="notFoundCount" value="0" type="Integer" />
                <iterate list="invoices" entry="invoice">
                    <!-- check if referenced in the ledger-->
                    <entity-find entity-name="mantle.ledger.transaction.AcctgTrans" list="transList">
                        <econdition field-name="organizationPartyId" from="companyPartyId" />
                        <econdition field-name="invoiceId" from="invoice.invoiceId" />
                    </entity-find>
                    <if condition="transList"><!-- only close when in the ledger-->
                        <!-- change system date to the transActiondate -->
                        <script>ec.user.setEffectiveTime(transList[0].postedDate)</script>

                        <!-- convert to credit memo if total negative -->
                        <service-call name="mantle.account.InvoiceServices.get#InvoiceTotal"
                            in-map="[invoiceId:invoice.invoiceId]" out-map="totalOut" />
                        <if condition="totalOut.invoiceTotal &lt; 0.0">
                            <set field="temp" from="invoice.toPartyId" />
                            <set field="invoice.toPartyId" from="invoice.fromPartyId" />
                            <set field="invoice.fromPartyId" from="temp" />
                            <set field="invoice.invoiceTypeEnumId" value="InvoiceCreditMemo" />
                            <set field="invoice.statusId"
                                from="invoice.statusId == 'InvoiceIncoming' ? 'InvoiceInProcess' : 'InvoiceIncoming'" />
                            <entity-update value-field="invoice" />
                            <entity-find entity-name="mantle.account.invoice.InvoiceItem"
                                list="items" for-update="true">
                                <econdition field-name="invoiceId" from="invoice.invoiceId" />
                            </entity-find>
                            <iterate list="items" entry="item">
                                <set field="item.amount" from="item.amount.negate()" />
                                <entity-update value-field="item" />
                            </iterate>
                        </if>

                        <if condition="invoice.statusId == 'InvoiceInProcess'">
                            <set field="statusId1" value="InvoiceFinalized" />
                            <set field="statusId2" value="InvoiceSent" />
                            <else>
                                <set field="statusId1" value="InvoiceReceived" />
                                <set field="statusId2" value="InvoiceApproved" />
                            </else>
                        </if>
                        <service-call name="update#mantle.account.invoice.Invoice"
                            in-map="[invoiceId: invoice.invoiceId, statusId: statusId1]" />
                        <set field="updatedCount" from="updatedCount + 1" />
                        <entity-find-one entity-name="mantle.account.invoice.Invoice"
                            value-field="inv">
                            <field-map field-name="invoiceId" from="invoice.invoiceId" />
                        </entity-find-one>
                        <if condition="inv.statusId == statusId1">
                            <service-call name="update#mantle.account.invoice.Invoice"
                                in-map="[invoiceId: invoice.invoiceId, statusId: statusId2]" />
                        </if>
                        <else>
                            <set field="notFoundCount" from="notFoundCount + 1" />
                            <script>System.out.println(">>>Could not find invoice in the ledger,  invoice: ${invoice?.invoiceId}/${invoice.pseudoId} ref: ${invoice.externalId}")</script>
                        </else>
                    </if>
                    <entity-find-one entity-name="mantle.account.invoice.Invoice"
                        value-field="inv">
                        <field-map field-name="invoiceId" from="invoice.invoiceId" />
                    </entity-find-one>
                </iterate>
                <script>System.out.println(">>>${invoices.size()} not approved invoices found ${updatedCount} updated, ${notFoundCount} not found in ledger")</script>
                <set field="limit" from="notFoundCount" />
            </if>
            <!-- payments -->
            <if condition="part == 'completePayments'">
                <entity-find entity-name="mantle.account.payment.Payment"
                    list="payments" limit="limit" offset="start">
                    <econditions combine="or">
                        <econdition field-name="fromPartyId" from="companyPartyId" />
                        <econdition field-name="toPartyId" from="companyPartyId" />
                    </econditions>
                    <econdition field-name="statusId" value="PmntPromised" />
                </entity-find>
                <if condition="!payments">
                    <set field="limitOut" value="-1" />
                    <return />
                </if>
                <script>System.out.println(">>>Closing ${payments?.size()} Payments}")</script>
                <set field="updatedCount" value="0" type="Integer" />
                <set field="notFoundCount" value="0" type="Integer" />
                <iterate list="payments" entry="payment">
                    <!-- check if referenced in the ledger-->
                    <entity-find entity-name="mantle.ledger.transaction.AcctgTrans" list="transList">
                        <econdition field-name="organizationPartyId" from="companyPartyId" />
                        <econdition field-name="paymentId" from="payment.paymentId" />
                    </entity-find>
                    <if condition="transList">
                        <!-- change system date to the transActiondate -->
                        <script>ec.user.setEffectiveTime(transList[0].postedDate)</script>

                        <!-- found, so can be completed -->
                        <service-call name="update#mantle.account.payment.Payment"
                            in-map="[paymentId: payment.paymentId, statusId: 'PmntDelivered']" />
                        <set field="updatedCount" from="updatedCount + 1" />
                        <else>
                            <script>System.out.println(">>>Could not find payment in the ledger, payment: ${payment.paymentId}/${payment.pseudoId} ref: ${payment.paymentRefNum}")</script>
                            <set field="notFoundCount" from="notFoundCount + 1" />
                        </else>
                    </if>
                </iterate>
                <script>System.out.println(">>>${payments.size()} not completed payments found ${updatedCount} updated, ${notFoundCount} not found in ledger")</script>
                <set field="limit" from="notFoundCount" />
            </if>
            <!-- complete invoices and orders -->
            <if condition="part == 'completeInvoicesOrders'">
                <entity-find
                    entity-name="mantle.account.invoice.Invoice"
                    list="invoices" offset="start" limit="limit">
                    <econditions combine="or">
                        <econdition field-name="fromPartyId" from="companyPartyId" />
                        <econdition field-name="toPartyId" from="companyPartyId" />
                    </econditions>
                    <econditions combine="or">
                        <econdition field-name="statusId" value="InvoiceApproved" />
                        <econdition field-name="statusId" value="InvoiceSent" />
                    </econditions>
                </entity-find>
                <if condition="!invoices">
                    <set field="limitOut" value="-1" />
                    <return />
                </if>
                <script>System.out.println(">>>Closing ${invoices?.size()} Invoices and related orders}")</script>
                <set field="updatedCountOrder" value="0" type="Integer" />
                <set field="notFoundCountOrder" value="0" type="Integer" />
                <set field="updatedCount" value="0" type="Integer" />
                <iterate list="invoices" entry="invoice">
                    <!-- change system date to the invoicedate -->
                    <script>ec.user.setEffectiveTime(invoice.invoiceDate)</script>
                    <service-call name="mantle.account.InvoiceServices.get#InvoiceTotal"
                        in-map="[invoiceId:invoice.invoiceId]" out-map="totalOut" />
                    <if condition="totalOut.unpaidTotal &gt; 0.0">
                        <script>System.out.println(">>>Cannot complete invoice, not fully paid: ${invoice.invoiceId}/${invoice.pseudoId} unpaid: ${totalOut.unpaidTotal }")</script>
                        <else>
                            <service-call name="update#mantle.account.invoice.Invoice"
                                in-map="[invoiceId: invoice.invoiceId,
                                statusId: invoice.statusId == 'InvoiceSent'? 'InvoicePmtRecvd' : 'InvoicePmtSent']" />
                            <script>updatedCount++</script>
                        </else>
                    </if>
                    <entity-find entity-name="mantle.order.OrderItemBilling" list="orders">
                        <econdition field-name="invoiceId" from="invoice.invoiceId" />
                    </entity-find>
                    <if condition="orders">
                        <service-call name="update#mantle.order.OrderHeader"
                            in-map="[orderId: orders[0].orderId, statusId: 'OrderApproved']" />
                        <service-call name="update#mantle.order.OrderHeader"
                            in-map="[orderId: orders[0].orderId, statusId: 'OrderCompleted']" />
                        <script>updatedCountOrder++</script>
                        <else>
                            <script>System.out.println(">>>Not found an order for invoice ${invoice.invoiceId}/${invoice.pseudoId}")</script>
                            <script>notFoundCountOrder++</script>
                        </else>
                    </if>
                </iterate>
                <script>System.out.println(">>>${invoices?.size()} not completed invoices found ${updatedCount} updated, ${notFoundCountOrder} related orders not found")</script>
                <set field="limit" from="invoices?.size() - updatedCount" />
            </if>

            <!-- receive incoming shipments-->
            <if condition="part == 'receiveShipments'">
                <entity-find entity-name="mantle.shipment.Shipment" list="shipments"
                    offset="start" limit="limit">
                    <econdition field-name="toPartyId" from="companyPartyId" />
                    <econdition field-name="statusId" value="ShipScheduled" />
                </entity-find>
                <if condition="!shipments">
                    <set field="limitOut" value="-1" />
                    <return />
                </if>
                <set field="updatedCount" value="0" type="Integer" />
                <script>System.out.println(">>>Receiving and Closing incoming ${shipments.size()} shipments")</script>
                <iterate list="shipments" entry="shipment">
                    <!-- change system date to the shipmentdate -->
                    <script>ec.user.setEffectiveTime(shipment.entryDate)</script>
                    <service-call name="growerp.100.FinDocServices100.get#FinDoc"
                        in-map="[finDocId: shipment.shipmentId, docType: 'shipment']"
                        out-map="context" />
                    <service-call name="growerp.100.FinDocServices100.update#FinDoc"
                        in-map="[finDoc: finDocs[0] + [statusId: 'FinDocApproved']]" />
                    <service-call name="growerp.100.FinDocServices100.get#FinDoc"
                        in-map="[finDocId: shipment.shipmentId, docType: 'shipment']"
                        out-map="context" />
                    <service-call name="growerp.100.FinDocServices100.receive#Shipment"
                        in-map="[finDoc: finDocs[0] + [statusId: 'FinDocApproved']]" />
                    <script>updatedCount++</script>
                </iterate>
                <set field="notUpdated" from="shipments?.size() - updatedCount" />
                <script>System.out.println(">>>${shipments?.size()} not completed incomong shipments found, ${updatedCount} updated, ${notUpdated} shipments not updated")</script>
                <set field="limit" from="notUpdated" />
            </if>
            <!-- send outgoing shipments -->
            <if condition="part == 'sendShipments'">
                <entity-find
                    entity-name="mantle.shipment.Shipment" list="shipments"
                    offset="start" limit="limit">
                    <econdition field-name="fromPartyId" from="companyPartyId" />
                    <econdition field-name="statusId" value="ShipScheduled" />
                </entity-find>
                <if condition="!shipments">
                    <set field="limitOut" value="-1" />
                    <return />
                </if>
                <set field="updatedCount" value="0" type="Integer" />
                <script>System.out.println(">>>Sending and Closing outgoing ${shipments.size()} shipments")</script>
                <entity-find entity-name="mantle.facility.Facility" list="facilities">
                    <econdition field-name="ownerPartyId" from="companyPartyId" />
                </entity-find>
                <iterate list="shipments" entry="shipment">
                    <!-- change system date to the shipmentdate -->
                    <script>ec.user.setEffectiveTime(shipment.entryDate)</script>

                    <!-- check for available inventory -->
                    <set field="products" from="[]" />
                    <iterate list="shipment.items" entry="item">
                        <service-call name="mantle.product.AssetServices.get#AvailableInventory"
                            in-map="[productId: item.productId,
                                    facilityId: facilities[0].facilityId]"
                            out-map="context" />
                        <if condition="availableToPromiseTotal &lt; item.quantity">
                            <script>"productId: ${products.add(item.productId)} required: ${item.quantity} available: ${availableToPromiseTotal}"</script>
                        </if>
                    </iterate>
                    <if condition="products.size() == 0">
                        <service-call name="growerp.100.FinDocServices100.get#FinDoc"
                            in-map="[finDocId: shipment.shipmentId, docType: 'shipment']"
                            out-map="context" />
                        <service-call name="growerp.100.FinDocServices100.update#FinDoc"
                            in-map="[finDoc: finDocs[0] + [statusId: 'FinDocApproved']]" />
                        <service-call name="growerp.100.FinDocServices100.update#FinDoc"
                            in-map="[finDoc: finDocs[0] + [statusId: 'FinDocCompleted']]" />
                        <script>updatedCount++</script>
                        <else>
                            <script>System.out.println(">>>Shipment ${shipment.shipmentId} with products ${products} has not enough inventory")</script>
                        </else>
                    </if>
                </iterate>
                <set field="notUpdated" from="shipments?.size() - updatedCount" />
                <script>System.out.println(">>>${shipments?.size()} not completed shipments found, ${updatedCount} updated, ${notUpdated} shipments not updated")</script>
                <set field="limit" from="notUpdated" />
            </if>
            <set field="limitOut" from="limit.toString()" />
        </actions>
    </service>

    <!-- used by the screens and the tests-->
    <service verb="import" noun="Entities">
        <description> Import general entities</description>
        <in-parameters>
            <parameter name="entities" required="true" type="Map" />
            <parameter name="classificationId" />
        </in-parameters>
        <actions>
            <service-call name="growerp.100.GeneralServices100.get#RelatedCompanyAndOwner"
                out-map="relComp" />
            <if condition="entities.companies">
                <iterate list="entities.companies" entry="company">
                    <if condition="company.partyId == '_MOD_'">
                        <entity-find entity-name="growerp.party.OwnerCompanyDetailAndEmployee"
                            list="parties">
                            <econdition field-name="ownerPartyId" from="relComp.ownerPartyId" />
                            <econdition field-name="companyName" operator="like"
                                value="${company.name}%" />
                        </entity-find>
                        <if condition="parties">
                            <set field="company.partyId" from="parties[0].companyPartyId" />
                            <service-call name="growerp.100.PartyServices100.update#Company"
                                in-map="[company: company]" />
                        </if>
                        <else>
                            <service-call name="growerp.100.PartyServices100.create#Company"
                                in-map="[company: company, ownerPartyId: relComp.ownerPartyId]" />
                        </else>
                    </if>
                </iterate>
            </if>
            <if condition="entities.users">
                <iterate list="entities.users" entry="user">
                    <service-call name="growerp.100.PartyServices100.create#User"
                        in-map="[user: user]" />
                </iterate>
            </if>
            <if condition="entities.categories">
                <iterate list="entities.categories" entry="category">
                    <service-call name="growerp.100.CatalogServices100.create#ProductCategory"
                        in-map="[category: category, classificationId: classificationId]" />
                </iterate>
            </if>
            <if condition="entities.products">
                <iterate list="entities.products" entry="product">
                    <!-- check if related category exist using name, if yes use these-->
                    <iterate list="product.categories" entry="category">
                        <entity-find entity-name="mantle.product.category.ProductCategory"
                            list="foundCategories">
                            <econdition field-name="categoryName" from="category.categoryName" />
                            <econdition field-name="ownerPartyId" from="relComp.ownerPartyId" />
                        </entity-find>
                        <if condition="foundCategories">
                            <set field="category.categoryId"
                                from="foundCategories[0].productCategoryId" />
                        </if>
                    </iterate>
                    <service-call name="growerp.100.CatalogServices100.create#Product"
                        out-map="result"
                        in-map="[product: product, classificationId: classificationId]" />
                </iterate>
                <message public="true" type="success">Products Upload completed</message>
            </if>
            <if condition="entities.assets">
                <iterate list="entities.assets" entry="asset">
                    <service-call name="growerp.100.InventoryServices100.create#Asset"
                        in-map="[asset: asset, classificationId: classificationId]" />
                </iterate>
                <message public="true" type="success">Assets Upload completed</message>
            </if>
            <if condition="entities.locations">
                <iterate list="entities.locations" entry="location">
                    <service-call name="growerp.100.InventoryServices100.create#Location"
                        in-map="[location: location]" />
                </iterate>
                <message public="true" type="success">Locations Upload completed</message>
            </if>
            <!-- empty list will remove all accounts-->
            <if condition="entities.glAccounts || entities.glAccounts?.size == 0">
                <!-- delete existing transactions only initial if present-->
                <entity-find entity-name="mantle.ledger.transaction.AcctgTrans" list="transList">
                    <econdition field-name="organizationPartyId" from="relComp.companyPartyId" />
                </entity-find>
                <if condition="transList.size() &gt; 1">
                    <return error="true"
                        message="Can only delete ledger when when not more than the initial settiung of posted balance." />
                </if>
                <if condition="!transList.isEmpty()">
                    <entity-delete-by-condition
                        entity-name="mantle.ledger.transaction.AcctgTransEntry">
                        <econdition field-name="acctgTransId" from="transList[0].acctgTransId" />
                    </entity-delete-by-condition>
                    <entity-delete-by-condition entity-name="mantle.ledger.transaction.AcctgTrans">
                        <econdition field-name="acctgTransId" from="transList[0].acctgTransId" />
                    </entity-delete-by-condition>
                </if>
                <!-- delete existing ledger -->
                <entity-find entity-name="mantle.ledger.account.GlAccountAndOrganization"
                    list="glAccounts">
                    <econdition field-name="organizationPartyId" from="relComp.companyPartyId" />
                    <select-field field-name="glAccountId" />
                </entity-find>
                <entity-delete-by-condition
                    entity-name="mantle.ledger.account.GlAccountOrganization">
                    <econdition field-name="organizationPartyId" from="relComp.companyPartyId" />
                </entity-delete-by-condition>
                <entity-delete-by-condition
                    entity-name="mantle.ledger.account.GlAccount">
                    <econdition field-name="glAccountId" operator="in" from="glAccounts" />
                </entity-delete-by-condition>
                <!-- create new accounts and collect posted balances for new transactions-->
                <set field="transactions" from="[]" />
                <iterate list="entities.glAccounts" entry="newGlAccount">
                    <service-call name="growerp.100.AccountingServices100.create#GlAccount"
                        in-map="[glAccount: newGlAccount]"
                        out-map="createdGlAccount" />
                    <if condition="newGlAccount.postedBalance">
                        <script>transactions.add([
                            isDebit: createdGlAccount.glAccount.isDebit,
                            price: newGlAccount.postedBalance,
                            glAccount: [glAccountId: createdGlAccount.glAccount.glAccountId],
                        ])</script>
                    </if>
                </iterate>
                <!-- create unposted balance in initial transaction-->
                <if condition="!transactions.isEmpty()">
                    <service-call name="growerp.100.FinDocServices100.create#FinDoc"
                        in-map="finDoc: [docType: 'transaction', sales: 'true',
                                description: 'Initial balance',
                                items: transactions]"
                        out-map="context" />
                </if>
                <message public="true" type="success">${entities.glAccounts.size()} Ledger accounts with ${transactions.size()} initial transactions Upload completed</message>
            </if>
        </actions>
    </service>

    <service verb="get" noun="ExportCategories">
        <description>
            Get Categories information into a CSV file attachement
        </description>
        <in-parameters>
            <parameter name="classificationId" />
        </in-parameters>
        <out-parameters>
            <parameter name="fileText" />
        </out-parameters>
        <actions>
            <service-call name="growerp.100.CatalogServices100.get#ProductCategory"
                in-map="[classificationId: classificationId]" out-map="context" />
            <set field="fileText" value="" />
            <script><![CDATA[
                import org.apache.commons.csv.CSVPrinter
                import org.apache.commons.csv.CSVFormat
                import org.apache.commons.csv.CSVRecord
                import org.apache.commons.csv.QuoteMode
                StringBuilder outSb = new StringBuilder()
                CSVPrinter printer = CSVFormat.DEFAULT.withHeader(
                    "name", "description", "image").print(outSb)
                for (Map item in categories) {
                    printer.printRecord(item.categoryName,
                                        item.description,
                                        item.image)}
                fileText = outSb.toString()
            ]]></script>
            <!--log
            message="output in catgories CSV: ${fileText}"/-->
        </actions>
    </service>

    <service verb="get" noun="ExportProducts">
        <description>
            Get Products information into a CSV file attachement
        </description>
        <out-parameters>
            <parameter name="fileText" />
        </out-parameters>
        <actions>
            <script>logger.warn("getting products")</script>
            <service-call name="growerp.100.CatalogServices100.get#Product"
                out-map="context" />
            <set field="fileText" value="" />
            <script><![CDATA[
                import org.apache.commons.csv.CSVPrinter
                import org.apache.commons.csv.CSVFormat
                import org.apache.commons.csv.CSVRecord
                import org.apache.commons.csv.QuoteMode
                StringBuilder outSb = new StringBuilder()
                CSVPrinter printer = CSVFormat.DEFAULT.withHeader(
                    "name", "description", "Product Type Id", "image", "assetClassId","List Price","Price","Use Warehouse","Nbr of Assets","Category1", "Category2", "Category3").print(outSb)
                for (Map item in products) {
                    printer.printRecord(item.productName,
                                        item.description,
                                        item.productTypeId,
                                        item.image,
                                        item.assetClassId,
                                        item.listPrice,
                                        item.price,
                                        item.requireInventory,
                                        item.assetCount,
                                        item.categories[0] ? item.categories[0].categoryName :'',
                                        item.categories[1] ? item.categories[1].categoryName :'',
                                        item.categories[2] ? item.categories[2].categoryName :'',
                                        )}
                fileText = outSb.toString()
            ]]></script>
        </actions>
    </service>

    <service verb="get" noun="ExportCompanyUsers">
        <description>
            Get Company/Users information into a CSV file attachement
        </description>
        <out-parameters>
            <parameter name="fileText" />
        </out-parameters>
        <actions>
            <service-call name="growerp.100.PartyServices100.get#CompanyUser"
                in-map="[export: true, limit: 9999]"
                out-map="context" />
            <script><![CDATA[
                import org.apache.commons.csv.CSVPrinter
                import org.apache.commons.csv.CSVFormat
                import org.apache.commons.csv.CSVRecord
                import org.apache.commons.csv.QuoteMode
                StringBuilder outSb = new StringBuilder()
                CSVPrinter printer = CSVFormat.DEFAULT.withHeader(
                    "Id", "type", "name", "role", "email", "URL", "telephone number",  "address1", "address2", "postalCode", "city", "province/state", "country", "countryId", "companyId", "companyName").print(outSb)
                for (Map item in companiesUsers) {
                    printer.printRecord(item.pseudoId,
                                        item.type,
                                        item.name,
                                        item.role,
                                        item.email,
                                        item.url,
                                        item.telephoneNumber,
                                        item.address?.address1,
                                        item.address?.address2,
                                        item.address?.postalCode,
                                        item.address?.city,
                                        item.address?.province,
                                        item.address?.country,
                                        item.address?.countryId,
                                        item.company?.pseudoId,
                                        item.company?.name,
                                        )}
                fileText = outSb.toString()
            ]]></script>
        </actions>
    </service>

    <service verb="get" noun="ExportGlAccounts">
        <description>
            Get ledger Gl Accounts information into a CSV file attachement
        </description>
        <out-parameters>
            <parameter name="fileText" />
        </out-parameters>
        <actions>
            <service-call name="growerp.100.AccountingServices100.get#GlAccount"
                in-map="[limit: 999]"
                out-map="context" />
            <script><![CDATA[
                import org.apache.commons.csv.CSVPrinter
                import org.apache.commons.csv.CSVFormat
                import org.apache.commons.csv.CSVRecord
                import org.apache.commons.csv.QuoteMode
                StringBuilder outSb = new StringBuilder()
                CSVPrinter printer = CSVFormat.DEFAULT.withHeader(
                    "id", "name", "isDebit", "class", "type","postedBalance").print(outSb)
                for (Map item in glAccounts) {
                    printer.printRecord(item.accountCode,
                                        item.accountName,
                                        item.isDebit,
                                        item.accountClass.description,
                                        item.accountType.description,
                                        item.posteBalance,
                                        )}
                fileText = outSb.toString()
            ]]></script>
        </actions>
    </service>


    <service verb="export" noun="Entities">
        <description> Export general entities</description>
        <in-parameters>
            <parameter name="entityName" required="true" />
            <parameter name="classificationId" /><!-- not needed for gl accounts-->
        </in-parameters>
        <actions>
            <set field="emailAddress" from="ec.user.userAccount.emailAddress" />
            <set field="userAccount" from="ec.user.userAccount" />
            <set field="bodyParameters" from="[classificationId: classificationId]" />
            <if condition="entityName == 'Category'">
                <service-call name="org.moqui.impl.EmailServices.send#EmailTemplate" async="true"
                    in-map="[emailTemplateId: 'GrowerpExportCategories',
                        toAddresses: emailAddress, bodyParameters: bodyParameters]"
                    out-map="context" />
                <message public="true" type="success">A Categories CSV file was sent by email to ${userAccount.emailAddress}.</message>
                <else-if condition="entityName == 'Product'">
                    <service-call name="org.moqui.impl.EmailServices.send#EmailTemplate"
                        async="true"
                        in-map="[emailTemplateId: 'GrowerpExportProducts',
                        toAddresses: emailAddress, bodyParameters: bodyParameters]"
                        out-map="context" />
                    <message public="true" type="success">A Products CSV file was sent by email to ${userAccount.emailAddress}.</message>
                </else-if>
                <else-if condition="entityName == 'GlAccount'">
                    <service-call name="org.moqui.impl.EmailServices.send#EmailTemplate"
                        async="true"
                        in-map="[emailTemplateId: 'GrowerpExportGlAccounts',
                        toAddresses: emailAddress, bodyParameters: bodyParameters]"
                        out-map="context" />
                    <message public="true" type="success">A GlAccount CSV file was sent by email to ${userAccount.emailAddress}.</message>
                </else-if>
                <else-if condition="entityName == 'CompanyUser'">
                    <service-call name="org.moqui.impl.EmailServices.send#EmailTemplate"
                        async="true"
                        in-map="[emailTemplateId: 'GrowerpExportCompanyUsers',
                        toAddresses: emailAddress, bodyParameters: bodyParameters]"
                        out-map="context" />
                    <message public="true" type="success">A Company/User CSV file was sent by email to ${userAccount.emailAddress}.</message>
                </else-if>
                <else>
                    <return error="true"
                        message="Entity name [${entityName}] not supported for export." />
                </else>
            </if>
        </actions>
    </service>

    <service verb="export" noun="Website">
        <out-parameters>
            <parameter name="website" type="Map" />
        </out-parameters>
        <actions>
            <service-call name="growerp.100.WebsiteServices100.get#Website"
                out-map="context" />
            <set field="websiteContent" from="[]" />
            <iterate list="website.websiteContent" entry="wsContent">
                <service-call name="growerp.100.WebsiteServices100.get#WebsiteContent"
                    in-map="path: wsContent.path, text: wsContent.text"
                    out-map="context" />
                <script>
                    websiteContent.add(content)
                </script>
            </iterate>
            <set field="website.websiteContent" from="websiteContent" />
        </actions>
    </service>

    <service verb="import" noun="Website">
        <in-parameters>
            <parameter name="website" type="Map" required="true">
                <parameter name="id" required="true" />
                <parameter name="title" />
                <parameter name="hostName" />
                <parameter name="websiteContent" type="List">
                    <parameter name="content" type="Map">
                        <parameter name="path" />
                        <parameter name="title" /><!-- if path found and title empty, page will be
                        deleted -->
                        <parameter name="text" />
                        <parameter name="seqId" type="Integer" />
                    </parameter>
                </parameter>
                <parameter name="websiteCategories" type="List">
                    <parameter name="websiteCategory" type="Map">
                        <parameter name="categoryId" />
                        <parameter name="categoryName" />
                        <parameter name="products" type="List">
                            <parameter name="product" type="Map">
                                <parameter name="productId" />
                                <parameter name="productName" />
                            </parameter>
                        </parameter>
                    </parameter>
                </parameter>
                <parameter name="productCategories" type="List">
                    <parameter name="productCategory" type="Map">
                        <parameter name="categoryId" />
                    </parameter>
                </parameter>
                <parameter name="colorJson" />
                <parameter name="obsidianName" />
                <parameter name="measurementId" />
            </parameter>
            <parameter name="webContents" type="List">
                <parameter name="path" />
                <parameter name="title" />
                <parameter name="text" />
                <parameter name="image" />
                <parameter name="seqId" type="Integer" />
            </parameter>
        </in-parameters>
        <out-parameters>
            <parameter name="website" />
        </out-parameters>
        <actions>
            <service-call name="growerp.100.WebsiteServices100.update#Website"
                in-map="website: website"
                out-map="context" />
            <iterate list="websiteContents" entry="webSiteContent">
                <service-call name="growerp.100.WebsiteServices100.upload#WebsiteContent"
                    in-map="content: websiteContent"
                    out-map="context" />
            </iterate>
        </actions>
    </service>

</services>