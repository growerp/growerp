<?xml version="1.0" encoding="UTF-8"?>
<!--
This software is in the public domain under CC0 1.0 Universal plus a 
Grant of Patent License.

To the extent possible under law, the author(s) have dedicated all
copyright and related and neighboring rights to this software to the
public domain worldwide. This software is distributed without any
warranty.

You should have received a copy of the CC0 Public Domaicrn Dedication
along with this software (see the LICENSE.md file). If not, see
<http://creativecommons.org/publicdomain/zero/1.0/>.
-->
<services xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:noNamespaceSchemaLocation="http://moqui.org/xsd/service-definition-2.1.xsd">

    <!-- used by the conversion framework in the dart package growerp import client-->
    <service verb="import" noun="ItemTypes">
        <description> Import ItemTypes</description>
        <in-parameters>
            <parameter name="itemTypes" required="true" type="List" />
        </in-parameters>
        <actions>
            <service-call name="growerp.100.GeneralServices100.get#RelatedCompanyAndOwner"
                out-map="context" />
            <!-- delete existing -->
            <entity-delete-by-condition entity-name="mantle.ledger.config.ItemTypeGlAccount">
                <econdition field-name="organizationPartyId" from="companyPartyId" />
            </entity-delete-by-condition>
            <!-- create new -->
            <iterate list="itemTypes" entry="itemType">
                <entity-find entity-name="growerp.ledger.account.GlAccountAndOrganization"
                    list="glAccounts">
                    <econdition field-name="partyId" from="companyPartyId" />
                    <econdition field-name="accountCode" from="itemType.accountCode" />
                </entity-find>
                <if condition="!glAccounts">
                    <log level="error"
                        message="Could not find accountCode: ${itemType.accountCode} for company: $companyPartyId" />
                    <else>
                        <service-call name="create#mantle.ledger.config.ItemTypeGlAccount"
                            in-map="[
                                itemTypeEnumId: itemType.itemTypeId,
                                organizationPartyId: companyPartyId,
                                direction: itemType.direction,
                                glAccountId: glAccounts[0].glAccountId,
                            ]" />
                    </else>
                </if>
            </iterate>
            <if condition="!ec.message.hasError()">
                <message type="success">${itemTypes.size()} itemTypes imported</message>
            </if>
        </actions>
    </service>

    <service verb="import" noun="PaymentTypes">
        <description> Import PaymentTypes</description>
        <in-parameters>
            <parameter name="paymentTypes" required="true" type="List" />
        </in-parameters>
        <actions>
            <service-call name="growerp.100.GeneralServices100.get#RelatedCompanyAndOwner"
                out-map="context" />
            <!-- delete existing -->
            <entity-delete-by-condition entity-name="mantle.ledger.config.PaymentTypeGlAccount">
                <econdition field-name="organizationPartyId" from="companyPartyId" />
            </entity-delete-by-condition>
            <!-- create new -->
            <iterate list="paymentTypes" entry="paymentType">
                <set field="glAccountId" from="null" />
                <if
                    condition="paymentType.accountCode &amp;&amp; !paymentType.accountCode.isEmpty()">
                    <entity-find entity-name="growerp.ledger.account.GlAccountAndOrganization"
                        list="glAccounts">
                        <econdition field-name="partyId" from="companyPartyId" />
                        <econdition field-name="accountCode" from="paymentType.accountCode" />
                    </entity-find>
                    <if condition="!glAccounts">
                        <return error="true"
                            message="Could not find accountCode: ${paymentType.accountCode} for company: $companyPartyId" />
                        <else>
                            <set field="glAccountId" from="glAccounts[0].glAccountId" />
                        </else>
                    </if>
                    <service-call name="create#mantle.ledger.config.PaymentTypeGlAccount"
                        in-map="[   paymentTypeEnumId: paymentType.paymentTypeId,
                                organizationPartyId: companyPartyId,
                                isPayable: paymentType.isPayable == true ? 'Y' : 'N',
                                isApplied: paymentType.isApplied == true ? 'Y' : 'N',
                                glAccountId: glAccountId,
                            ]" />
                </if>
            </iterate>
            <if condition="!ec.message.hasError()">
                <message type="success">${paymentTypes.size()} paymentTypes imported</message>
            </if>
        </actions>
    </service>

    <service verb="import" noun="GlAccounts">
        <description> Import GlAccounts</description>
        <in-parameters>
            <parameter name="glAccounts" required="true" type="List" />
            <parameter name="classificationId" />
        </in-parameters>
        <actions>
            <service-call name="growerp.100.GeneralServices100.get#RelatedCompanyAndOwner"
                out-map="relComp" />
            <!-- delete existing transactions only initial if present-->
            <entity-find entity-name="mantle.ledger.transaction.AcctgTrans" list="transList">
                <econdition field-name="organizationPartyId" from="relComp.companyPartyId" />
            </entity-find>
            <if condition="transList.size() &gt; 1">
                <return error="true"
                    message="Can only delete ledger when when not more than the initial settiung of posted balance." />
            </if>
            <if condition="!transList.isEmpty()">
                <entity-delete-by-condition
                    entity-name="mantle.ledger.transaction.AcctgTransEntry">
                    <econdition field-name="acctgTransId" from="transList[0].acctgTransId" />
                </entity-delete-by-condition>
                <entity-delete-by-condition entity-name="mantle.ledger.transaction.AcctgTrans">
                    <econdition field-name="acctgTransId" from="transList[0].acctgTransId" />
                </entity-delete-by-condition>
            </if>
            <!-- delete existing ledger only if input file has account description and class 
                when not assume an update of the initial posting values-->
            <if
                condition="!glAccounts[0].accountName.isEmpty() &amp;&amp; !glAccounts[0].accountClass.description.isEmpty()">
                <entity-find entity-name="mantle.ledger.account.GlAccountAndOrganization"
                    list="glAccountsOrg">
                    <econdition field-name="organizationPartyId" from="relComp.companyPartyId" />
                    <select-field field-name="glAccountId" />
                </entity-find>
                <entity-delete-by-condition
                    entity-name="mantle.ledger.account.GlAccountOrganization">
                    <econdition field-name="organizationPartyId" from="relComp.companyPartyId" />
                </entity-delete-by-condition>
                <entity-delete-by-condition
                    entity-name="mantle.ledger.account.GlAccount">
                    <econdition field-name="glAccountId" operator="in" from="glAccountsOrg" />
                </entity-delete-by-condition>
                <!-- delete item types-->
                <entity-delete-by-condition entity-name="mantle.ledger.config.ItemTypeGlAccount">
                    <econdition field-name="organizationPartyId" from="relComp.companyPartyId" />
                </entity-delete-by-condition>
                <!-- delete payment types-->
                <entity-delete-by-condition entity-name="mantle.ledger.config.PaymentTypeGlAccount">
                    <econdition field-name="organizationPartyId" from="relComp.companyPartyId" />
                </entity-delete-by-condition>
            </if>
            <!-- create new accounts and collect posted balances for new transactions-->
            <set field="transactions" from="[]" />
            <iterate list="glAccounts" entry="newGlAccount">
                <if condition="newGlAccount.accountCode.isEmpty()">
                    <continue />
                </if>
                <!-- check if glaccount exist update just posted value is present -->
                <entity-find entity-name="mantle.ledger.account.GlAccountAndOrganization"
                    list="glAccountsOrg">
                    <econdition field-name="organizationPartyId" from="relComp.companyPartyId" />
                    <econdition field-name="accountCode" from="newGlAccount.accountCode" />
                </entity-find>
                <if condition="!glAccountsOrg">
                    <service-call name="growerp.100.AccountingServices100.create#GlAccount"
                        in-map="[glAccount: newGlAccount]"
                        out-map="createdGlAccount" />
                    <set field="newGlAccountId" from="createdGlAccount.glAccount.glAccountId" />
                    <set field="isDebit" from="createdGlAccount.glAccount.isDebit" />
                    <else>
                        <set field="newGlAccountId" from="glAccountsOrg[0].glAccountId" />
                        <set field="isDebit" from="glAccountsOrg[0].isDebit == 'Y' ? true : false"
                            type="Boolean" />
                    </else>
                </if>
                <!-- collect posted balances -->
                <if condition="newGlAccount.postedBalance">
                    <set field="isPositive" value="true" type="Boolean" />
                    <if condition="newGlAccount.postedBalance.startsWith('-')">
                        <set field="isPositive" value="false" type="Boolean" />
                    </if>
                    <script>transactions.add([
                        isDebit: isDebit == isPositive 
                            ? isDebit : !isDebit,
                        price: new BigDecimal(newGlAccount.postedBalance.replace('-','')),
                        glAccount: [glAccountId: newGlAccountId],
                        ])</script>
                </if>
            </iterate>
            <!-- create posted balance in initial transaction-->
            <if condition="!transactions.isEmpty()">
                <service-call name="growerp.100.FinDocServices100.create#FinDoc"
                    in-map="finDoc: [docType: 'transaction', sales: 'true', isPosted: true,
                                            description: 'Initial balance',
                                            items: transactions]"
                    out-map="context" />
            </if>
            <!-- recalculate posted summary-->
            <service-call name="growerp.100.AccountingServices100.recalculate#GlAccountOrgSummaries"
                in-map="companyPartyId: relComp.companyPartyId" />
            <if condition="!ec.message.hasError()">
                <message type="success">${glAccounts.size()} glAccounts imported</message>
            </if>
        </actions>
    </service>

    <service verb="import" noun="Companies">
        <in-parameters>
            <parameter name="companies" required="true" type="List" />
            <parameter name="classificationId" />
        </in-parameters>
        <actions>
            <service-call
                name="growerp.100.GeneralServices100.get#RelatedCompanyAndOwner"
                out-map="context" />

            <iterate list="companies" entry="company">
                <!--log
                message="process pseudoId ${company.pseudoId} role: ${company.role}" /-->
                <if condition="company.partyId == '_MOD_'"><!-- used in automated test-->
                    <entity-find entity-name="growerp.party.OwnerCompanyDetailAndEmployee"
                        list="parties">
                        <econdition field-name="ownerPartyId" from="ownerPartyId" />
                        <econdition field-name="companyName" operator="like"
                            value="${company.name}%" />
                    </entity-find>
                    <if condition="!parties.isEmpty()">
                        <set field="company.partyId" from="parties[0].companyPartyId" />
                        <service-call name="growerp.100.PartyServices100.update#Company"
                            in-map="[company: company]" />
                    </if>
                    <else>
                        <if condition="!company.role">
                            <message type="warn">Company id: ${company.pseudoId} ${company.name} not processed, role is missing!\r\n</message>
                            <continue />
                        </if>
                        <if condition="!company.name">
                            <message type="warn">Company id: ${company.pseudoId} ${company.name} name is missing, set to pseudoId!\r\n</message>
                            <set field="company.name" from="company.pseudoId" />
                        </if>
                        <if
                            condition="company.email &amp;&amp; company.email != '' &amp;&amp; !org.apache.commons.validator.routines.EmailValidator.getInstance().isValid(company.email)">
                            <message type="warn">Company id: ${company.pseudoId} ${company.name} email: ${company.email} is not valid!\r\n</message>
                            <set field="company.email" value="" />
                        </if>
                        <!-- main company already exist so need update -->
                        <if condition="company.role == 'OrgInternal'">
                            <entity-find entity-name="growerp.party.OwnerCompanyDetailAndEmployee"
                                list="mainCompanies">
                                <econdition field-name="companyRole" value="OrgInternal" />
                                <econdition field-name="ownerPartyId" from="ownerPartyId" />
                            </entity-find>
                            <if condition="mainCompanies.isEmpty()">
                                <log level="warn"
                                    message="Main company supplied but cannot find within owner: $ownerPartyId" />
                                <else>
                                    <set field="company.partyId"
                                        from="mainCompanies[0].companyPartyId" />
                                    <service-call
                                        name="growerp.100.PartyServices100.update#Company"
                                        in-map="[company: company]" />
                                    <continue />
                                </else>
                            </if>
                        </if>
                        <!-- check if company already exist -->
                        <entity-find entity-name="mantle.party.Party" list="parties">
                            <econdition field-name="pseudoId" from="company.pseudoId" />
                            <econdition field-name="ownerPartyId" from="ownerPartyId" />
                        </entity-find>
                        <if condition="!parties.isEmpty()">
                            <then>
                                <entity-find entity-name="mantle.party.PartyRole" list="roles">
                                    <econdition field-name="partyId" from="parties[0].partyId" />
                                    <econdition field-name="roleTypeId" from="company.role" />
                                </entity-find>
                                <if condition="roles.isEmpty()">
                                    <service-call name="create#mantle.party.PartyRole"
                                        in-map="[   partyId: parties[0].partyId,
                                                        roleTypeId: company.role]" />
                                    <else>
                                        <message type="warn">Company: ${company.name} not processed, pseudoId: ${company.pseudoId} ${company.role} already exist!\r\n</message>
                                    </else>
                                </if>
                            </then>
                            <else>
                                <service-call
                                    name="growerp.100.PartyServices100.create#Company"
                                    in-map="[company: company]" />
                            </else>
                        </if>
                    </else>
                </if>
            </iterate>
            <if condition="!ec.message.hasError()">
                <message type="success">${companies.size()} companies imported</message>
            </if>
        </actions>
    </service>

    <service verb="import" noun="Users">
        <in-parameters>
            <parameter name="users" required="true" type="List" />
        </in-parameters>
        <actions>
            <iterate list="users" entry="user">
                <service-call name="growerp.100.PartyServices100.create#User"
                    in-map="[user: user]" />
            </iterate>
            <if condition="!ec.message.hasError()">
                <message type="success">${users.size()} users imported</message>
            </if>
        </actions>
    </service>

    <service verb="import" noun="Products">
        <in-parameters>
            <parameter name="products" required="true" type="List" />
            <parameter name="classificationId" required="true" />
        </in-parameters>
        <actions>
            <service-call name="growerp.100.GeneralServices100.get#RelatedCompanyAndOwner"
                out-map="relComp" />
            <script>ec.user.setEffectiveTime(Timestamp.valueOf("1999-01-01 00:00:00"))</script>
            <iterate list="products" entry="product">
                <!-- check if related category exist using name, if yes use these-->
                <iterate list="product.categories" entry="category">
                    <entity-find entity-name="mantle.product.category.ProductCategory"
                        list="foundCategories">
                        <econdition field-name="categoryName" from="category.categoryName" />
                        <econdition field-name="ownerPartyId" from="relComp.ownerPartyId" />
                    </entity-find>
                    <if condition="foundCategories">
                        <set field="category.categoryId"
                            from="foundCategories[0].productCategoryId" />
                    </if>
                </iterate>
                <entity-find entity-name="mantle.product.Product" list="products">
                    <econdition field-name="pseudoId" from="product.pseudoId" />
                    <econdition field-name="ownerPartyId" from="relComp.ownerPartyId" />
                </entity-find>
                <if condition="!products">
                    <service-call name="growerp.100.CatalogServices100.create#Product"
                        out-map="result"
                        in-map="[product: product, classificationId: classificationId]" />
                </if>
            </iterate>
            <if condition="!ec.message.hasError()">
                <message type="success">${products.size()} products imported</message>
            </if>
        </actions>
    </service>

    <service verb="import" noun="Categories">
        <in-parameters>
            <parameter name="categories" required="true" type="List" />
            <parameter name="classificationId" />
        </in-parameters>
        <actions>
            <script>ec.user.setEffectiveTime(Timestamp.valueOf("1999-01-01 00:00:00"))</script>
            <iterate list="categories" entry="category">
                <service-call name="growerp.100.CatalogServices100.create#ProductCategory"
                    in-map="[category: category, classificationId: classificationId]" />
            </iterate>
            <if condition="!ec.message.hasError()">
                <message type="success">${categories?.size()} categories imported</message>
            </if>
        </actions>
    </service>

    <service verb="import" noun="Assets">
        <in-parameters>
            <parameter name="assets" required="true" type="List" />
            <parameter name="classificationId" />
        </in-parameters>
        <actions>
            <iterate list="assets" entry="asset">
                <service-call name="growerp.100.InventoryServices100.create#Asset"
                    out-map="result"
                    in-map="[asset: asset, classificationId: classificationId]" />
            </iterate>
            <if condition="!ec.message.hasError()">
                <message type="success">${assets?.size()} assets imported</message>
            </if>
        </actions>
    </service>

    <service verb="import" noun="FinDocs">
        <in-parameters>
            <parameter name="finDocs" required="true" type="List" />
            <parameter name="classificationId" />
        </in-parameters>
        <actions>
            <log
                message="importing ${finDocs[0].sales == true ? 'Sales' : 'Purchase'} ${finDocs[0].docType} ${finDocs?.size()} finDocs" />
            <service-call out-map="context"
                name="growerp.100.GeneralServices100.get#RelatedCompanyAndOwner" />
            <!-- check if we have a timeperiod here just for transactions.....-->
            <if condition="finDocs[0].docType == 'transaction'">
                <log message="looking for date: ${finDocs[0].creationDate.substring(0,10)} 12:00:00" />
                <!-- date-filter does not seem to work here date: 2010-12-31 not found!-->
                <entity-find entity-name="mantle.party.time.TimePeriod" list="periods">
                    <econdition field-name="partyId" from="companyPartyId" />
                    <econdition field-name="fromDate" operator="less-equals"
                        from="Timestamp.valueOf(finDocs[0].creationDate)" />
                    <econdition field-name="thruDate" operator="greater-equals"
                        from="Timestamp.valueOf(finDocs[0].creationDate)" />
                </entity-find>
                <!-- when not yet create all until next year -->
                <if condition="!periods">
                    <log
                        message="Creating time periods starting with ${finDocs[0].creationDate.substring(0,4)} for company $companyPartyId" />
                    <!-- delete existing timeperiods-->
                    <entity-find entity-name="mantle.party.time.TimePeriod" list="periods">
                        <econdition field-name="partyId" from="companyPartyId" />
                        <order-by field-name="-timePeriodId" />
                    </entity-find>
                    <iterate list="periods.timePeriodId" entry="id">
                        <entity-delete-by-condition entity-name="mantle.party.time.TimePeriod">
                            <econdition field-name="partyId" from="companyPartyId" />
                            <econdition field-name="timePeriodId" from="id" />
                        </entity-delete-by-condition>
                    </iterate>
                    <!-- create new yearly, quartely, monthly periods until next year-->
                    <set field="nextYearInt"
                        from="((Calendar) ec.user.nowCalendar).get(Calendar.YEAR) + 1" />
                    <set field="lastYear" from="ec.l10n.format(nextYearInt, '0000')" />

                    <!-- start year from first tranaction ordered by date -->
                    <set field="curYear" from="finDocs[0].creationDate.substring(0,4)" />
                    <set field="prevPeriodId" from="null" />
                    <while condition="curYear &lt;= lastYear">
                        <set field="fromDate"
                            from="ec.l10n.parseDate(curYear + '-01-01', 'yyyy-MM-dd')" />
                        <service-call name="mantle.party.TimeServices.getOrCreate#TimePeriod"
                            out-map="curYearOut"
                            in-map="[partyId:companyPartyId, timePeriodTypeId:'FiscalYear', fromDate:fromDate, previousPeriodId:prevPeriodId]" />
                        <service-call name="mantle.party.TimeServices.get#DescendantPeriods"
                            out-map="quartersOut"
                            in-map="[parentPeriodId:curYearOut.timePeriodId, timePeriodTypeId:'FiscalQuarter', createMissing:true]" />
                        <iterate list="quartersOut.timePeriodList" entry="quarterPeriod">
                            <service-call name="mantle.party.TimeServices.get#DescendantPeriods"
                                out-map="quartersOut"
                                in-map="[parentPeriodId:quarterPeriod.timePeriodId, timePeriodTypeId:'FiscalMonth', createMissing:true]" />
                        </iterate>
                        <set field="prevPeriodId" from="curYearOut.timePeriodId" />
                        <set field="curYear" from="((curYear as int) + 1) as String" />
                    </while>
                    <entity-find-count entity-name="mantle.party.time.TimePeriod"
                        count-field="periods">
                        <econdition field-name="partyId" from="companyPartyId" />
                    </entity-find-count>
                    <log message="${periods} time periods created for company ${companyPartyId}" />
                </if>
            </if>
            <iterate list="finDocs" entry="finDoc">
                <script>ec.user.setEffectiveTime(Timestamp.valueOf(finDoc.creationDate))</script>
                <!-- find partyId of other company-->
                <if condition="!finDoc.otherCompany.pseudoId &amp;&amp; finDoc.otherCompany.name">
                    <set field="finDoc.otherCompany.pseudoId" from="finDoc.otherCompany.name" />
                </if>
                <!-- translate pseudoId to moqui Id -->
                <if condition="finDoc.otherCompany &amp;&amp; finDoc.otherCompany.pseudoId">
                    <entity-find entity-name="mantle.party.Party" list="parties">
                        <econdition field-name="pseudoId" from="finDoc.otherCompany.pseudoId" />
                        <econdition field-name="ownerPartyId" from="ownerPartyId" />
                    </entity-find>
                    <if condition="parties">
                        <!--log
                            message="=====result from: ${finDoc.otherCompany.pseudoId} to ${parties[0].partyId}" /-->
                        <set field="finDoc.otherCompany.partyId" from="parties[0].partyId" />
                        <else-if
                            condition="finDoc.otherCompany.pseudoId &amp;&amp; finDoc.otherCompany.name">
                            <!-- create company -->
                            <if condition="finDoc.sales">
                                <set field="finDoc.otherCompany.role" value="Customer" />
                                <else>
                                    <set field="finDoc.otherCompany.role" value="Supplier" />
                                </else>
                            </if>
                            <service-call name="growerp.100.PartyServices100.create#Company"
                                in-map="[company: finDoc.otherCompany, ownerPartyId: ownerPartyId]"
                                out-map="context" />
                            <set field="finDoc.otherCompany.partyId" from="company.partyId" />
                            <log
                                message="finDocId ${finDoc.pseudoId} company pseudoId: ${finDoc.otherCompany.pseudoId} not found under owner: $ownerPartyId : added" />
                        </else-if>
                        <else>
                            <log level="warn"
                                message="Import finDocId ${finDoc.pseudoId} company pseudoId: ${finDoc.otherCompany.pseudoId} not found under owner: $ownerPartyId : need also name to add" />
                        </else>
                    </if>
                </if>
                <!-- transaction posted-->
                <if condition="finDoc.docType == 'transaction'">
                    <set field="finDoc.isPosted" value="false" type="Boolean" />
                </if>
                <!-- create findoc-->
                <set field="finDoc.statusId" value="FinDocCreated" />
                <service-call name="growerp.100.FinDocServices100.create#FinDoc"
                    in-map="[finDoc: finDoc, classificationId: classificationId]"
                    out-map="resultCreateFindoc" />
                <!-- create references-->
                <if condition="finDoc.docType == 'invoice'">
                    <if condition="finDoc.reference">
                        <!-- find transaction for invoice-->
                        <entity-find entity-name="mantle.ledger.transaction.AcctgTrans"
                            list="transactions" for-update="true">
                            <econdition field-name="organizationPartyId" from="companyPartyId" />
                            <econdition field-name="theirAcctgTransId" from="finDoc.reference" />
                        </entity-find>
                        <if condition="!transactions">
                            <log level="warn"
                                message="Import : could not find ${finDoc.sales?'sales':'purchase'} invoice ${resultCreateFindoc.finDoc.invoiceId} reference ${finDoc.reference}" />
                            <else>
                                <if condition="!transactions[0].invoiceId">
                                    <!-- ok found empty transaction -->
                                    <set field="transactions[0].invoiceId"
                                        from="resultCreateFindoc.finDoc.invoiceId" />
                                    <entity-update value-field="transactions[0]" />
                                    <else>
                                        <log level="warn"
                                            message="Transaction: ${transactions[0].acctgTransId}/${transactions[0].pseudoId} already has invoiceId: ${transactions[0].invoiceId} cannot add ${finDoc.sales?'sales':'purchase'} ${resultCreateFindoc.finDoc.invoiceId} reference: ${finDoc.reference} otherCompany: ${finDoc.otherCompany.partyId} trans other partyId: ${transactions[0].otherPartyId}" />
                                    </else>
                                </if>
                            </else>
                        </if>
                    </if>
                </if>
                <!-- incoming receipts-->
                <if condition="finDoc.docType == 'payment' &amp;&amp; finDoc.sale == true">
                    <!-- find transaction for payment-->
                    <entity-find entity-name="mantle.ledger.transaction.AcctgTrans"
                        list="transactions" for-update="true">
                        <econdition field-name="organizationPartyId" from="companyPartyId" />
                        <econdition field-name="theirAcctgTransId" from="finDoc.reference" />
                        <econdition field-name="otherPartyId" from="finDoc.otherCompany.partyId" />
                    </entity-find>
                    <if condition="!transactions">
                        <log level="warn"
                            message="Import : could not find ${finDoc.sales?'sales':'purchase'} payment ${resultCreateFindoc.finDoc.paymentId} reference ${finDoc.reference}  otherCompany: ${finDoc.otherCompany.partyId} " />
                        <else>
                            <if condition="!transactions[0].paymentId">
                                <!-- ok found empty transaction -->
                                <set field="transactions[0].paymentId"
                                    from="resultCreateFindoc.finDoc.paymentId" />
                                <entity-update value-field="transactions[0]" />
                                <else>
                                    <log level="warn"
                                        message="Transaction: ${transactions[0].acctgTransId}/${transactions[0].pseudoId} already has ${finDoc.sales?'sales':'purchase'} paymentId: ${transactions[0].paymentId} cannot add ${resultCreateFindoc.finDoc.paymentId} reference: ${finDoc.reference} otherCompany: ${finDoc.otherCompany.partyId} trans other partyId: ${transactions[0].otherPartyId}" />
                                </else>
                            </if>
                        </else>
                    </if>
                </if>
                <!-- for payment use check number as reference into the ledger -->
                <if
                    condition="finDoc.docType == 'payment' &amp;&amp; finDoc.paymentMethod?.checkNumber">
                    <!--log
                        message="===looking for tranaction for payment with checknumber:
                    ${finDoc.paymentMethod?.checkNumber}" /-->
                    <entity-find entity-name="mantle.ledger.transaction.AcctgTrans"
                        list="transactions" for-update="true">
                        <econdition field-name="organizationPartyId" from="companyPartyId" />
                        <econdition field-name="theirAcctgTransId"
                            from="finDoc.paymentMethod?.checkNumber" />
                    </entity-find>
                    <if condition="!transactions">
                        <log level="warn"
                            message="Import : could not find ${finDoc.sales?'sales':'purchase'} payment ${resultCreateFindoc.finDoc.paymentId} checknumber ${finDoc.paymentMethod?.checkNumber}" />
                        <else>
                            <if condition="!transactions[0].paymentId">
                                <!-- ok found empty transaction -->
                                <set field="transactions[0].paymentId"
                                    from="resultCreateFindoc.finDoc.paymentId" />
                                <entity-update value-field="transactions[0]" />
                                <else>
                                    <log level="warn"
                                        message="Transaction: ${transactions[0].acctgTransId}/${transactions[0].pseudoId} already has paymentId: ${transactions[0].paymentId} cannot add ${resultCreateFindoc.finDoc.sales?'sales':'purchase'} ${resultCreateFindoc.finDoc.paymentId} checkNr: ${finDoc.paymentMethod?.checkNumber} otherCompany: ${finDoc.otherCompany.partyId} trans: ${transactions[0].otherPartyId}" />
                                </else>
                            </if>
                        </else>
                    </if>
                </if>
                <!-- try to find invoice for payment -->
                <if condition="finDoc.docType == 'payment'">
                    <if condition="finDoc.sales == true">
                        <set field="fromPartyId" from="companyPartyId" />
                        <set field="toPartyId" from="null" />
                        <set field="pseudoId" from="finDoc.classificationId" />
                        <else>
                            <set field="toPartyId" from="companyPartyId" />
                            <set field="fromPartyId" from="null" />
                            <set field="pseudoId" from="finDoc.reference" />
                        </else>
                    </if>
                    <!--log
                        message="===looking for invoice: pseudoId: ${pseudoId} from ${fromPartyId} to: ${toPartyId} refnum:
                    ${paymentRefNum}" /-->
                    <entity-find entity-name="mantle.account.invoice.Invoice" limit="1"
                        list="invoiceFound">
                        <econdition field-name="pseudoId" from="pseudoId" />
                        <econdition field-name="fromPartyId" ignore-if-empty="true" />
                        <econdition field-name="toPartyId" ignore-if-empty="true" />
                    </entity-find>
                    <if condition="invoiceFound">
                        <service-call
                            name="mantle.account.PaymentServices.apply#PaymentForInvoice"
                            in-map="[invoiceId: invoiceFound[0].invoiceId, paymentId: resultCreateFindoc.finDoc.paymentId]" />
                        <else>
                            <log
                                message="could not find an invoice ${pseudoId} to apply for payment: ${resultCreateFindoc.finDoc.paymentId} amount: ${resultCreateFindoc.finDoc.grandTotal}" />
                        </else>
                    </if>
                </if>
                <!-- link invoices to order, so order should be created first -->
                <if condition="finDoc.docType == 'invoice' &amp;&amp; finDoc.classificationId">
                    <set field="pseudoId" from="finDoc.classificationId" />
                    <if condition="finDoc.sales == true">
                        <set field="vendorPartyId" from="companyPartyId" />
                        <set field="customerPartyId" from="null" />
                        <else>
                            <set field="customerPartyId" from="companyPartyId" />
                            <set field="vendorPartyId" from="null" />
                        </else>
                    </if>
                    <!--log
                        message="===looking for order from invoice:${resultCreateFindoc.finDoc.invoiceId} order pseudoId:
                    ${pseudoId} cust ${customerPartyId} vend: ${vendorPartyId}" /-->
                    <entity-find entity-name="mantle.order.OrderHeaderAndPart" limit="1"
                        list="orderFound">
                        <econdition field-name="pseudoId" from="pseudoId" />
                        <econdition field-name="customerPartyId" ignore-if-empty="true" />
                        <econdition field-name="vendorPartyId" ignore-if-empty="true" />
                    </entity-find>
                    <if condition="orderFound">
                        <service-call name="create#mantle.order.OrderItemBilling"
                            in-map="[invoiceId: resultCreateFindoc.finDoc.invoiceId, orderId: orderFound[0].orderId]" />
                        <else>
                            <log
                                message="could not find an order ${pseudoId} from invoice: ${resultCreateFindoc.finDoc.pseudoId}[${resultCreateFindoc.finDoc.invoiceId}]" />
                        </else>
                    </if>
                </if>
                <if condition="finDoc.docType == 'shipment' &amp;&amp; finDoc.reference">
                    <!-- connect shipment to transaction -->
                    <entity-find entity-name="growerp.account.AcctgTransAndCompany"
                        list="transactions" limit="1">
                        <econdition field-name="companyPartyId" from="companyPartyId" />
                        <econdition field-name="theirAcctgTransId" from="finDoc.reference" />
                    </entity-find>
                    <if condition="transactions">
                        <if condition="transactions[0].shipmentId == null">
                            <service-call name="update#mantle.ledger.transaction.AcctgTrans"
                                in-map="transactions[0] + [shipmentId: resultCreateFindoc.finDoc.shipmentId] " />
                            <else>
                                <log
                                    message="transaction already has shipment: ${resultCreateFindoc.finDoc.shipmentId} could not create relation to shipment: ${resultCreateFindoc.finDoc.shipmentId} and reference: ${finDoc.reference}" />
                            </else>
                        </if>
                        <else>
                            <log
                                message="transaction could not be found for shipment: ${resultCreateFindoc.finDoc.shipmentId} and reference: ${finDoc.reference}" />
                        </else>
                    </if>
                </if>
            </iterate>
            <if condition="!ec.message.hasError()">
                <message type="success">${finDocs?.size()} finDocs  ${finDocs[0].docType} imported</message>
            </if>
        </actions>
    </service>

    <service verb="import" noun="FinDocItems" transaction-timeout="3600">
        <in-parameters>
            <parameter name="finDocItems" required="true" type="List" />
            <parameter name="classificationId" required="true" />
        </in-parameters>
        <actions>
            <service-call out-map="context"
                name="growerp.100.GeneralServices100.get#RelatedCompanyAndOwner" />
            <set field="itemsOut" from="[]" />
            <set field="index" value="0" type="Integer" />
            <iterate list="finDocItems" entry="item">
                <if condition="lastItem &amp;&amp; lastItem.pseudoId != item.pseudoId">
                    <script>ec.user.setEffectiveTime(Timestamp.valueOf("${finDoc.creationDate} 00:00:00"))</script>
                    <!-- get current document id-->
                    <service-call name="growerp.100.FinDocServices100.get#FinDoc" out-map="context"
                        in-map="[pseudoId: lastItem.pseudoId, docType: lastItem.docType,
                                classificationId: classificationId]" />
                    <if condition="finDocs.isEmpty()">
                        <!-- cannot find, so not try to add items -->
                        <log
                            message="importing ${lastItem.docType} items could not find company: $companyPartyId and pseudo: ${lastItem.pseudoId}" />
                        <else>
                            <set field="finDoc" from="finDocs[0]" />
                            <!-- add items collected below to finDoc[0] already got below-->
                            <set field="finDoc.items" from="itemsOut" />
                            <if condition="finDoc.docType == 'transaction'">
                                <set field="finDoc.isPosted" value="true" type="Boolean" />
                            </if>
                            <if condition="finDoc.docType == 'shipment' &amp;&amp; finDoc.reference">
                                <service-call
                                    name="growerp.100.ImportExportServices100.get#InvoiceItemsForShipmentQuantities"
                                    in-map="[companyPartyId: companyPartyId, finDoc: finDoc]"
                                    out-map="context" />
                            </if>
                            <service-call name="growerp.100.FinDocServices100.update#FinDoc"
                                in-map="[finDoc: finDoc, classificationId: classificationId]" />
                        </else>
                    </if>
                    <set field="itemsOut" from="[]" />
                </if>
                <if condition="!lastItem || lastItem.pseudoId != item.pseudoId">
                    <!-- find related finDoc header -->
                    <service-call name="growerp.100.FinDocServices100.get#FinDoc"
                        in-map="[pseudoId: item.pseudoId, docType: item.docType]"
                        out-map="context" />
                    <if condition="finDocs.isEmpty()">
                        <log level="error"
                            message="Import ${item.docType} pseudoId: ${item.pseudoId} not found" />
                        <set field="lastItem" from="null" />
                        <continue />
                        <else>
                            <set field="finDoc" from="finDocs[0]" />
                        </else>
                    </if>
                </if>
                <if condition="item.glAccount.accountCode">
                    <!-- find internal item glAccountId from glAccount.accountCode-->
                    <entity-find entity-name="growerp.ledger.account.GlAccountAndOrganization"
                        list="glAccounts">
                        <econdition field-name="partyId" from="companyPartyId" />
                        <econdition field-name="accountCode" from="item.glAccount.accountCode" />
                    </entity-find>
                    <if condition="glAccounts">
                        <set field="item.glAccount.glAccountId" from="glAccounts[0].glAccountId" />
                        <else>
                            <log level="warn"
                                message="id: ${item.pseudoId} could not find item accountCode ${item.glAccount.accountCode} for company: $companyPartyId" />
                        </else>
                    </if>
                    <if condition="finDocs[0].docType == 'transaction'">
                        <if condition="item.isDebit == null">
                            <set field="item.isDebit"
                                from="glAccounts[0].isDebit == 'Y' ? true : false" />
                        </if>
                    </if>
                </if>
                <if condition="!item.product.pseudoId.isEmpty()">
                    <!-- find productId from pseudoProductId -->
                    <service-call name="growerp.100.CatalogServices100.get#Products"
                        out-map="context"
                        in-map="[pseudoId: item.product.pseudoId,
                                classificationId: classificationId,
                                ownerPartyId: ownerPartyId]" />
                    <if condition="!products.isEmpty()"><!-- get services always provide list -->
                        <set field="item.product.productId" from="products[0].productId" />
                        <!-- update prices when on an invoice -->
                        <if condition="item.docType == 'invoice'">
                            <set field="products[0].price" from="item.price" />
                            <set field="products[0].listPrice" from="item.price" />
                            <service-call name="growerp.100.CatalogServices100.update#Product"
                                out-map="context"
                                in-map="[product: products[0], classificationId: classificationId]" />
                        </if>
                        <else>
                            <!-- not found so better add it when not null -->
                            <if condition="item.pseudoProductId != null">
                                <log
                                    message="id: ${item.pseudoId} could not find pseudoProductId ${item.pseudoProductId} for owner: $ownerPartyId, will add it" />
                                <set field="product"
                                    from="[
                                    ownerPartyId: ownerPartyId,
                                    pseudoId: item.pseudoProductId,
                                    productTypeId: 'Physical Good',
                                    productName: item.description,
                                    price: item.price,
                                    listPrice: item.price,
                                    ]" />
                                <service-call name="growerp.100.CatalogServices100.create#Product"
                                    out-map="context"
                                    in-map="[product: product, classificationId: classificationId]" />
                                <set field="item.productId" from="product.productId" />
                            </if>
                        </else>
                    </if>
                </if>
                <!-- item type on orders if missing create some: -->
                <if condition="finDoc.docType == 'order' &amp;&amp; !item.itemType">
                    <log
                        message="id: ${item.pseudoId} no item type for ${item.glAccount.glAccountId} set to ItemExpense" />
                    <set field="item.itemType" from="[itemTypeId: 'ItemExpense']" />
                </if>
                <script>itemsOut.add(item)</script>
                <set field="lastItem" from="item" />
            </iterate>
            <!-- process last record -->
            <if condition="lastItem">
                <script>ec.user.setEffectiveTime(Timestamp.valueOf("${finDoc.creationDate} 00:00:00"))</script>
                <!-- get current document id-->
                <service-call name="growerp.100.FinDocServices100.get#FinDoc" out-map="context"
                    in-map="[pseudoId: lastItem.pseudoId, docType: lastItem.docType,
                            classificationId: classificationId]" />
                <if condition="finDocs.isEmpty()">
                    <!-- cannot find, so not try to add items -->
                    <log message="importing items could not find ${lastItem.pseudoId}" />
                    <else>
                        <set field="finDoc" from="finDocs[0]" />
                        <!-- add items collected below to finDoc[0] already got below-->
                        <set field="finDoc.items" from="itemsOut" />
                        <if condition="finDoc.docType == 'transaction'">
                            <set field="finDoc.isPosted" value="true" type="Boolean" />
                        </if>
                        <if condition="finDoc.docType == 'shipment' &amp;&amp; finDoc.reference">
                            <service-call
                                name="growerp.100.ImportExportServices100.get#InvoiceItemsForShipmentQuantities"
                                in-map="[companyPartyId: companyPartyId, finDoc: finDoc]"
                                out-map="context" />
                        </if>
                        <service-call name="growerp.100.FinDocServices100.update#FinDoc"
                            in-map="[finDoc: finDoc, classificationId: classificationId]" />
                    </else>
                </if>
            </if>

            <!-- end of service result -->
            <if condition="!ec.message.hasError()">
                <message type="success">${finDocItems?.size()} findoc items ${finDocItems[0].docType} imported</message>
            </if>
        </actions>
    </service>

    <service verb="get" noun="InvoiceItemsForShipmentQuantities">
        <in-parameters>
            <parameter name="companyPartyId" />
            <parameter name="finDoc" type="Map" />
        </in-parameters>
        <out-parameters>
            <parameter name="finDoc" type="Map" />
        </out-parameters>
        <actions>
            <!-- looking for invoice of shipment to get quantity -->
            <if condition="finDoc.sales">
                <set field="fromPartyId" from="companyPartyId" />
                <else>
                    <set field="toPartyId" from="companyPartyId" />
                </else>
            </if>
            <!--log
                message="matching invoice externalId on finDoc ref: ${finDoc.reference} with fromPartyId:
            $fromPartyId toPartyId: $toPartyId sales: ${finDoc.sales}" /-->
            <entity-find entity-name="mantle.account.invoice.Invoice"
                list="invoices" limit="1">
                <econdition field-name="externalId" from="finDoc.reference" />
                <econdition field-name="fromPartyId" from="fromPartyId"
                    ignore-if-empty="true" />
                <econdition field-name="toPartyId" from="toPartyId" ignore-if-empty="true" />
            </entity-find>
            <if condition="invoices">
                <!-- connect to invoice/order-->
                <entity-find entity-name="mantle.order.OrderItemBilling" limit="1" list="billings"
                    for-update="true">
                    <econdition field-name="invoiceId" from="invoices[0].invoiceId" />
                </entity-find>
                <if condition="billings">
                    <set field="billings[0].shipmentId" from="finDoc.shipmentId" />
                    <entity-update value-field="billings[0]" />
                </if>
                <!-- find a matching invoice item to get quantity -->
                <entity-find entity-name="mantle.account.invoice.InvoiceItem"
                    list="invoiceItems">
                    <econdition field-name="invoiceId" from="invoices[0].invoiceId" />
                </entity-find>
                <!--log
                message="matching items: ${finDoc.items?.size()}" /-->
                <set field="newShipmentItems" from="[]" />
                <iterate list="finDoc.items" entry="shipmentItem">
                    <set field="quantityUpdated" value="false" type="Boolean" />
                    <iterate list="invoiceItems" entry="invoiceItem">
                        <if
                            condition="shipmentItem.product?.productId &amp;&amp;
                                invoiceItem.product?.productId == shipmentItem.product?.productId">
                            <script>newShipmentItems.add(
                                    shipmentItem + [quantity: invoiceItem.quantity])</script>
                            <set field="quantityUpdated" value="true" type="Boolean" />
                        </if>
                    </iterate>
                    <if condition="quantityUpdated == false">
                        <log
                            message="Could not update shipment # quantity, shipmentId/productId: ${finDoc.shipmentId}/${shipmentItem.productId}  invoiceId/products: ${invoiceId}/${invoiceItems.productId} " />
                    </if>
                </iterate>
                <set field="finDoc.items" from="newShipmentItems" />
                <else>
                    <log
                        message="Could not find related invoice for company: $companyPartyId sales: ${finDoc.sales} shipment: ${finDoc.pseudoId} ref: ${finDoc.reference}" />
                </else>
            </if>
        </actions>
    </service>

    <service verb="finalize" noun="Import">
        <description> Post imported findocs of which the status is not finalized and already have a link
            in the ledger so the status will update but will not change the ledger</description>
        <actions>
            <service-call out-map="context"
                name="growerp.100.GeneralServices100.get#RelatedCompanyAndOwner" />
            <!-- invoices -->
            <entity-find entity-name="mantle.account.invoice.Invoice" for-update="true"
                list="invoices">
                <econditions combine="or">
                    <econdition field-name="fromPartyId" from="companyPartyId" />
                    <econdition field-name="toPartyId" from="companyPartyId" />
                </econditions>
                <econdition field-name="statusId" value="InvoiceInProcess" />
                <econdition field-name="statusId" value="InvoiceIncoming" />
            </entity-find>
            <set field="updatedCount" value="0" type="Integer" />
            <set field="notFoundCount" value="0" type="Integer" />
            <iterate list="invoices" entry="invoice">
                <!-- check if referenced in the ledger-->
                <entity-find entity-name="mantle.ledger.transaction.AcctgTrans" list="transList">
                    <econdition field-name="organizationPartyId" from="companyPartyId" />
                    <econdition field-name="invoiceId" from="invoice.invoiceId" />
                </entity-find>
                <if condition="transList">
                    <if condition="invoice.statusId == 'InvoiceInProcess'">
                        <set field="statusId1" value="InvoiceFinalized" />
                        <set field="statusId2" value="InvoiceSend" />
                        <else>
                            <set field="statusId1" value="InvoiceReceived" />
                            <set field="statusId2" value="InvoiceApproved" />
                        </else>
                    </if>
                    <service-call name="update#mantle.account.invoice.Invoice"
                        in-map="[invoiceId: invoice.invoiceId, statusId: statusId1]" />
                    <service-call name="update#mantle.account.invoice.Invoice"
                        in-map="[invoiceId: invoice.invoiceId, statusId: statusId2]" />
                    <set field="updatedCount" from="updatedCount + 1" />
                    <else>
                        <set field="notFoundCount" from="notFoundCount + 1" />
                    </else>
                </if>
            </iterate>
            <log
                message="${invoices.size()} not completed invoices found ${updatedCount} updated, ${notFoundCount} not found in ledger" />
            <!-- payments -->
            <entity-find entity-name="mantle.account.payment.Payment" for-update="true"
                list="payments">
                <econditions combine="or">
                    <econdition field-name="fromPartyId" from="companyPartyId" />
                    <econdition field-name="toPartyId" from="companyPartyId" />
                </econditions>
                <econdition field-name="statusId" value="PmntPromised" />
            </entity-find>
            <set field="updatedCount" value="0" type="Integer" />
            <set field="notFoundCount" value="0" type="Integer" />
            <iterate list="payments" entry="payment">
                <!-- check if referenced in the ledger-->
                <entity-find entity-name="mantle.ledger.transaction.AcctgTrans" list="transList">
                    <econdition field-name="organizationPartyId" from="companyPartyId" />
                    <econdition field-name="paymentId" from="payment.paymentId" />
                </entity-find>
                <if condition="transList">
                    <set field="payment.statusId" value="PmntConfirmed" />
                    <service-call name="update#mantle.account.payment.Payment"
                        in-map="[paymentId: payment.paymentId, statusId: statusId]" />
                    <set field="updatedCount" from="updatedCount + 1" />
                    <else>
                        <set field="notFoundCount" from="notFoundCount + 1" />
                    </else>
                </if>
            </iterate>
            <log
                message="${payments.size()} not completed payments found ${updatedCount} updated, ${notFoundCount} not found in ledger" />
        </actions>
    </service>

    <!-- used by the screens and the tests-->
    <service verb="import" noun="Entities">
        <description> Import general entities</description>
        <in-parameters>
            <parameter name="entities" required="true" type="Map" />
            <parameter name="classificationId" />
        </in-parameters>
        <actions>
            <service-call name="growerp.100.GeneralServices100.get#RelatedCompanyAndOwner"
                out-map="relComp" />
            <if condition="entities.companies">
                <iterate list="entities.companies" entry="company">
                    <if condition="company.partyId == '_MOD_'">
                        <entity-find entity-name="growerp.party.OwnerCompanyDetailAndEmployee"
                            list="parties">
                            <econdition field-name="ownerPartyId" from="relComp.ownerPartyId" />
                            <econdition field-name="companyName" operator="like"
                                value="${company.name}%" />
                        </entity-find>
                        <if condition="parties">
                            <set field="company.partyId" from="parties[0].companyPartyId" />
                            <service-call name="growerp.100.PartyServices100.update#Company"
                                in-map="[company: company]" />
                        </if>
                        <else>
                            <service-call name="growerp.100.PartyServices100.create#Company"
                                in-map="[company: company, ownerPartyId: relComp.ownerPartyId]" />
                        </else>
                    </if>
                </iterate>
            </if>
            <if condition="entities.users">
                <iterate list="entities.users" entry="user">
                    <service-call name="growerp.100.PartyServices100.create#User"
                        in-map="[user: user]" />
                </iterate>
            </if>
            <if condition="entities.categories">
                <iterate list="entities.categories" entry="category">
                    <service-call name="growerp.100.CatalogServices100.create#ProductCategory"
                        in-map="[category: category, classificationId: classificationId]" />
                </iterate>
            </if>
            <if condition="entities.products">
                <iterate list="entities.products" entry="product">
                    <!-- check if related category exist using name, if yes use these-->
                    <iterate list="product.categories" entry="category">
                        <entity-find entity-name="mantle.product.category.ProductCategory"
                            list="foundCategories">
                            <econdition field-name="categoryName" from="category.categoryName" />
                            <econdition field-name="ownerPartyId" from="relComp.ownerPartyId" />
                        </entity-find>
                        <if condition="foundCategories">
                            <set field="category.categoryId"
                                from="foundCategories[0].productCategoryId" />
                        </if>
                    </iterate>
                    <service-call name="growerp.100.CatalogServices100.create#Product"
                        out-map="result"
                        in-map="[product: product, classificationId: classificationId]" />
                </iterate>
                <message public="true" type="success">Products Upload completed</message>
            </if>
            <if condition="entities.assets">
                <iterate list="entities.assets" entry="asset">
                    <service-call name="growerp.100.InventoryServices100.create#Asset"
                        in-map="[asset: asset, classificationId: classificationId]" />
                </iterate>
                <message public="true" type="success">Assets Upload completed</message>
            </if>
            <if condition="entities.locations">
                <iterate list="entities.locations" entry="location">
                    <service-call name="growerp.100.InventoryServices100.create#Location"
                        in-map="[location: location]" />
                </iterate>
                <message public="true" type="success">Locations Upload completed</message>
            </if>
            <!-- empty list will remove all accounts-->
            <if condition="entities.glAccounts || entities.glAccounts?.size == 0">
                <!-- delete existing transactions only initial if present-->
                <entity-find entity-name="mantle.ledger.transaction.AcctgTrans" list="transList">
                    <econdition field-name="organizationPartyId" from="relComp.companyPartyId" />
                </entity-find>
                <if condition="transList.size() &gt; 1">
                    <return error="true"
                        message="Can only delete ledger when when not more than the initial settiung of posted balance." />
                </if>
                <if condition="!transList.isEmpty()">
                    <entity-delete-by-condition
                        entity-name="mantle.ledger.transaction.AcctgTransEntry">
                        <econdition field-name="acctgTransId" from="transList[0].acctgTransId" />
                    </entity-delete-by-condition>
                    <entity-delete-by-condition entity-name="mantle.ledger.transaction.AcctgTrans">
                        <econdition field-name="acctgTransId" from="transList[0].acctgTransId" />
                    </entity-delete-by-condition>
                </if>
                <!-- delete existing ledger -->
                <entity-find entity-name="mantle.ledger.account.GlAccountAndOrganization"
                    list="glAccounts">
                    <econdition field-name="organizationPartyId" from="relComp.companyPartyId" />
                    <select-field field-name="glAccountId" />
                </entity-find>
                <entity-delete-by-condition
                    entity-name="mantle.ledger.account.GlAccountOrganization">
                    <econdition field-name="organizationPartyId" from="relComp.companyPartyId" />
                </entity-delete-by-condition>
                <entity-delete-by-condition
                    entity-name="mantle.ledger.account.GlAccount">
                    <econdition field-name="glAccountId" operator="in" from="glAccounts" />
                </entity-delete-by-condition>
                <!-- create new accounts and collect posted balances for new transactions-->
                <set field="transactions" from="[]" />
                <iterate list="entities.glAccounts" entry="newGlAccount">
                    <service-call name="growerp.100.AccountingServices100.create#GlAccount"
                        in-map="[glAccount: newGlAccount]"
                        out-map="createdGlAccount" />
                    <if condition="newGlAccount.postedBalance">
                        <script>transactions.add([
                            isDebit: createdGlAccount.glAccount.isDebit,
                            price: newGlAccount.postedBalance,
                            glAccount: [glAccountId: createdGlAccount.glAccount.glAccountId],
                        ])</script>
                    </if>
                </iterate>
                <!-- create unposted balance in initial transaction-->
                <if condition="!transactions.isEmpty()">
                    <service-call name="growerp.100.FinDocServices100.create#FinDoc"
                        in-map="finDoc: [docType: 'transaction', sales: 'true',
                                description: 'Initial balance',
                                items: transactions]"
                        out-map="context" />
                </if>
                <message public="true" type="success">${entities.glAccounts.size()} Ledger accounts with ${transactions.size()} initial transactions Upload completed</message>
            </if>
        </actions>
    </service>

    <service verb="get" noun="ExportCategories">
        <description>
            Get Categories information into a CSV file attachement
        </description>
        <in-parameters>
            <parameter name="classificationId" />
        </in-parameters>
        <out-parameters>
            <parameter name="fileText" />
        </out-parameters>
        <actions>
            <service-call name="growerp.100.CatalogServices100.get#ProductCategories"
                in-map="[classificationId: classificationId]" out-map="context" />
            <set field="fileText" value="" />
            <script><![CDATA[
                import org.apache.commons.csv.CSVPrinter
                import org.apache.commons.csv.CSVFormat
                import org.apache.commons.csv.CSVRecord
                import org.apache.commons.csv.QuoteMode
                StringBuilder outSb = new StringBuilder()
                CSVPrinter printer = CSVFormat.DEFAULT.withHeader(
                    "name", "description", "image").print(outSb)
                for (Map item in categories) {
                    printer.printRecord(item.categoryName,
                                        item.description,
                                        item.image)}
                fileText = outSb.toString()
            ]]></script>
            <!--log
            message="output in catgories CSV: ${fileText}"/-->
        </actions>
    </service>

    <service verb="get" noun="ExportProducts">
        <description>
            Get Products information into a CSV file attachement
        </description>
        <out-parameters>
            <parameter name="fileText" />
        </out-parameters>
        <actions>
            <script>logger.warn("getting products")</script>
            <service-call name="growerp.100.CatalogServices100.get#Products"
                out-map="context" />
            <set field="fileText" value="" />
            <script><![CDATA[
                import org.apache.commons.csv.CSVPrinter
                import org.apache.commons.csv.CSVFormat
                import org.apache.commons.csv.CSVRecord
                import org.apache.commons.csv.QuoteMode
                StringBuilder outSb = new StringBuilder()
                CSVPrinter printer = CSVFormat.DEFAULT.withHeader(
                    "name", "description", "Product Type Id", "image", "assetClassId","List Price","Price","Use Warehouse","Nbr of Assets","Category1", "Category2", "Category3").print(outSb)
                for (Map item in products) {
                    printer.printRecord(item.productName,
                                        item.description,
                                        item.productTypeId,
                                        item.image,
                                        item.assetClassId,
                                        item.listPrice,
                                        item.price,
                                        item.requireInventory,
                                        item.assetCount,
                                        item.categories[0] ? item.categories[0].categoryName :'',
                                        item.categories[1] ? item.categories[1].categoryName :'',
                                        item.categories[2] ? item.categories[2].categoryName :'',
                                        )}
                fileText = outSb.toString()
            ]]></script>
        </actions>
    </service>

    <service verb="get" noun="ExportGlAccounts">
        <description>
            Get ledger Gl Accounts information into a CSV file attachement
        </description>
        <in-parameters>
            <parameter name="classificationId" />
        </in-parameters>
        <out-parameters>
            <parameter name="fileText" />
        </out-parameters>
        <actions>
            <service-call name="growerp.100.AccountingServices100.get#GlAccount"
                in-map="[limit: 999]"
                out-map="context" />
            <set field="fileText" value="" />
            <script><![CDATA[
                import org.apache.commons.csv.CSVPrinter
                import org.apache.commons.csv.CSVFormat
                import org.apache.commons.csv.CSVRecord
                import org.apache.commons.csv.QuoteMode
                StringBuilder outSb = new StringBuilder()
                CSVPrinter printer = CSVFormat.DEFAULT.withHeader(
                    "id", "name", "isDebit", "class", "type","postedBalance").print(outSb)
                for (Map item in glAccountList) {
                    printer.printRecord(item.accountCode,
                                        item.accountName,
                                        item.isDebit,
                                        item.accountClass.description,
                                        item.accountType.description,
                                        item.posteBalance,
                                        )}
                fileText = outSb.toString()
            ]]></script>
        </actions>
    </service>


    <service verb="export" noun="Entities">
        <description> Export general entities</description>
        <in-parameters>
            <parameter name="entityName" required="true" />
            <parameter name="classificationId" required="true" />
        </in-parameters>
        <actions>
            <set field="emailAddress" from="ec.user.userAccount.emailAddress" />
            <set field="userAccount" from="ec.user.userAccount" />
            <set field="bodyParameters" from="[classificationId: classificationId]" />
            <if condition="entityName == 'Category'">
                <service-call name="org.moqui.impl.EmailServices.send#EmailTemplate" async="true"
                    in-map="[emailTemplateId: 'GrowerpExportCategories',
                        toAddresses: emailAddress, bodyParameters: bodyParameters]"
                    out-map="context" />
                <message public="true" type="success">A Categories CSV file was sent by email to ${userAccount.emailAddress}.</message>
            </if>
            <if condition="entityName == 'Product'">
                <service-call name="org.moqui.impl.EmailServices.send#EmailTemplate" async="true"
                    in-map="[emailTemplateId: 'GrowerpExportProducts',
                        toAddresses: emailAddress, bodyParameters: bodyParameters]"
                    out-map="context" />
                <message public="true" type="success">A Products CSV file was sent by email to ${userAccount.emailAddress}.</message>
            </if>
            <if condition="entityName == 'GlAccount'">
                <service-call name="org.moqui.impl.EmailServices.send#EmailTemplate" async="true"
                    in-map="[emailTemplateId: 'GrowerpExportGlAccounts',
                        toAddresses: emailAddress, bodyParameters: bodyParameters]"
                    out-map="context" />
                <message public="true" type="success">A GlAccount CSV file was sent by email to ${userAccount.emailAddress}.</message>
            </if>
        </actions>
    </service>

    <service verb="export" noun="Website">
        <out-parameters>
            <parameter name="website" type="Map" />
        </out-parameters>
        <actions>
            <service-call name="growerp.100.WebsiteServices100.get#Website"
                out-map="context" />
            <set field="websiteContent" from="[]" />
            <iterate list="website.websiteContent" entry="wsContent">
                <service-call name="growerp.100.WebsiteServices100.get#WebsiteContent"
                    in-map="path: wsContent.path, text: wsContent.text"
                    out-map="context" />
                <script>
                    websiteContent.add(content)
                </script>
            </iterate>
            <set field="website.websiteContent" from="websiteContent" />
        </actions>
    </service>

    <service verb="import" noun="Website">
        <in-parameters>
            <parameter name="website" type="Map" required="true">
                <parameter name="id" required="true" />
                <parameter name="title" />
                <parameter name="hostName" />
                <parameter name="websiteContent" type="List">
                    <parameter name="content" type="Map">
                        <parameter name="path" />
                        <parameter name="title" /><!-- if path found and title empty, page will be
                        deleted -->
                        <parameter name="text" />
                        <parameter name="seqId" type="Integer" />
                    </parameter>
                </parameter>
                <parameter name="websiteCategories" type="List">
                    <parameter name="websiteCategory" type="Map">
                        <parameter name="categoryId" />
                        <parameter name="categoryName" />
                        <parameter name="products" type="List" />
                        <parameter name="product" type="Map">
                            <parameter name="productId" />
                            <parameter name="productName" />
                        </parameter>
                    </parameter>
                </parameter>
                <parameter name="productCategories" type="List">
                    <parameter name="productCategory" type="Map">
                        <parameter name="categoryId" />
                    </parameter>
                </parameter>
                <parameter name="colorJson" />
                <parameter name="obsidianName" />
                <parameter name="measurementId" />
            </parameter>
            <parameter name="webContents" type="List">
                <parameter name="path" />
                <parameter name="title" />
                <parameter name="text" />
                <parameter name="image" />
                <parameter name="seqId" type="Integer" />
            </parameter>
        </in-parameters>
        <out-parameters>
            <parameter name="website" />
        </out-parameters>
        <actions>
            <service-call name="growerp.100.WebsiteServices100.update#Website"
                in-map="website: website"
                out-map="context" />
            <iterate list="websiteContents" entry="webSiteContent">
                <service-call name="growerp.100.WebsiteServices100.upload#WebsiteContent"
                    in-map="content: websiteContent"
                    out-map="context" />
            </iterate>
        </actions>
    </service>

</services>