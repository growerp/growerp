<?xml version="1.0" encoding="UTF-8"?>
<!--
This software is in the public domain under CC0 1.0 Universal plus a 
Grant of Patent License.

To the extent possible under law, the author(s) have dedicated all
copyright and related and neighboring rights to this software to the
public domain worldwide. This software is distributed without any
warranty.

You should have received a copy of the CC0 Public Domaicrn Dedication
along with this software (see the LICENSE.md file). If not, see
<http://creativecommons.org/publicdomain/zero/1.0/>.
-->
<services xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:noNamespaceSchemaLocation="http://moqui.org/xsd/service-definition-2.1.xsd">

    <service verb="import" noun="ItemTypes">
        <description> Import ItemTypes</description>
        <in-parameters>
            <parameter name="itemTypes" required="true" type="List" />
        </in-parameters>
        <actions>
            <service-call name="growerp.100.GeneralServices100.get#RelatedCompanyAndOwner"
                out-map="context" />
            <!-- delete existing -->
            <entity-delete-by-condition entity-name="mantle.ledger.config.ItemTypeGlAccount">
                <econdition field-name="organizationPartyId" from="companyPartyId" />
            </entity-delete-by-condition>
            <!-- create new -->
            <iterate list="itemTypes" entry="itemType">
                <entity-find entity-name="growerp.ledger.account.GlAccountAndOrganization"
                    list="glAccounts">
                    <econdition field-name="partyId" from="companyPartyId" />
                    <econdition field-name="accountCode" from="itemType.accountCode" />
                </entity-find>
                <if condition="!glAccounts">
                    <log level="error"
                        message="Could not find accountCode: ${itemType.accountCode} for company: $companyPartyId" />
                    <else>
                        <service-call name="create#mantle.ledger.config.ItemTypeGlAccount"
                            in-map="[
                                itemTypeEnumId: itemType.itemTypeId,
                                organizationPartyId: companyPartyId,
                                direction: itemType.direction,
                                glAccountId: glAccounts[0].glAccountId,
                            ]" />
                    </else>
                </if>
            </iterate>
            <if condition="!ec.message.hasError()">
                <message type="success">${itemTypes.size()} itemTypes imported</message>
            </if>
        </actions>
    </service>

    <service verb="import" noun="PaymentTypes">
        <description> Import PaymentTypes</description>
        <in-parameters>
            <parameter name="itemTypes" required="true" type="List" />
        </in-parameters>
        <actions>
            <service-call name="growerp.100.GeneralServices100.get#RelatedCompanyAndOwner"
                out-map="context" />
            <!-- delete existing -->
            <entity-delete-by-condition entity-name="mantle.ledger.config.PaymentTypeGlAccount">
                <econdition field-name="organizationPartyId" from="companyPartyId" />
            </entity-delete-by-condition>
            <!-- create new -->
            <iterate list="itemTypes" entry="itemType">
                <set field="glAccountId" from="null" />
                <if condition="itemType.accountCode">
                    <entity-find entity-name="growerp.ledger.account.GlAccountAndOrganization"
                        list="glAccounts">
                        <econdition field-name="partyId" from="companyPartyId" />
                        <econdition field-name="accountCode" from="itemType.accountCode" />
                    </entity-find>
                    <if condition="!glAccounts">
                        <log level="error"
                            message="Could not find accountCode: ${itemType.accountCode} for company: $companyPartyId" />
                        <else>
                            <set field="glAccountId" from="glAccounts[0].glAccountId" />
                        </else>
                    </if>
                </if>
                <service-call name="create#mantle.ledger.config.PaymentTypeGlAccount"
                    in-map="[   paymentTypeEnumId: itemType.itemTypeId,
                                organizationPartyId: companyPartyId,
                                isPayable: itemType.isPayable,
                                isApplied: itemType.isApplied,
                                glAccountId: glAccountId,
                            ]" />
            </iterate>
            <if condition="!ec.message.hasError()">
                <message type="success">${itemTypes.size()} itemTypes imported</message>
            </if>
        </actions>
    </service>

    <service verb="import" noun="GlAccounts">
        <description> Import GlAccounts</description>
        <in-parameters>
            <parameter name="glAccounts" required="true" type="List" />
            <parameter name="classificationId" />
        </in-parameters>
        <actions>
            <service-call name="growerp.100.GeneralServices100.get#RelatedCompanyAndOwner"
                out-map="relComp" />
            <!-- delete existing transactions only initial if present-->
            <entity-find entity-name="mantle.ledger.transaction.AcctgTrans" list="transList">
                <econdition field-name="organizationPartyId" from="relComp.companyPartyId" />
            </entity-find>
            <if condition="transList.size() &gt; 1">
                <return error="true"
                    message="Can only delete ledger when when not more than the initial settiung of posted balance." />
            </if>
            <if condition="!transList.isEmpty()">
                <entity-delete-by-condition
                    entity-name="mantle.ledger.transaction.AcctgTransEntry">
                    <econdition field-name="acctgTransId" from="transList[0].acctgTransId" />
                </entity-delete-by-condition>
                <entity-delete-by-condition entity-name="mantle.ledger.transaction.AcctgTrans">
                    <econdition field-name="acctgTransId" from="transList[0].acctgTransId" />
                </entity-delete-by-condition>
            </if>
            <!-- delete existing ledger -->
            <entity-find entity-name="mantle.ledger.account.GlAccountAndOrganization"
                list="glAccountsOrg">
                <econdition field-name="organizationPartyId" from="relComp.companyPartyId" />
                <select-field field-name="glAccountId" />
            </entity-find>
            <entity-delete-by-condition
                entity-name="mantle.ledger.account.GlAccountOrganization">
                <econdition field-name="organizationPartyId" from="relComp.companyPartyId" />
            </entity-delete-by-condition>
            <entity-delete-by-condition
                entity-name="mantle.ledger.account.GlAccount">
                <econdition field-name="glAccountId" operator="in" from="glAccountsOrg" />
            </entity-delete-by-condition>
            <!-- delete item types-->
            <entity-delete-by-condition entity-name="mantle.ledger.config.ItemTypeGlAccount">
                <econdition field-name="organizationPartyId" from="relComp.companyPartyId" />
            </entity-delete-by-condition>
            <!-- delete payment types-->
            <entity-delete-by-condition entity-name="mantle.ledger.config.PaymentTypeGlAccount">
                <econdition field-name="organizationPartyId" from="relComp.companyPartyId" />
            </entity-delete-by-condition>
            <!-- create new accounts and collect posted balances for new transactions-->
            <set field="transactions" from="[]" />
            <iterate list="glAccounts" entry="newGlAccount">
                <service-call name="growerp.100.AccountingServices100.create#GlAccount"
                    in-map="[glAccount: newGlAccount]"
                    out-map="createdGlAccount" />
                <!-- collect posted balances -->
                <if condition="newGlAccount.postedBalance">
                    <set field="isPositive" value="true" type="Boolean" />
                    <if condition="newGlAccount.postedBalance.startsWith('-')">
                        <set field="isPositive" value="false" type="Boolean" />
                    </if>
                    <script>transactions.add([
                        isDebit: createdGlAccount.glAccount.isDebit == isPositive ? createdGlAccount.glAccount.isDebit : !createdGlAccount.glAccount.isDebit,
                        price: new BigDecimal(newGlAccount.postedBalance.replace('-','')),
                        glAccount: [glAccountId: createdGlAccount.glAccount.glAccountId],
                        ])</script>
                </if>
            </iterate>
            <!-- create posted balance in initial transaction-->
            <if condition="!transactions.isEmpty()">
                <service-call name="growerp.100.FinDocServices100.create#FinDoc"
                    in-map="finDoc: [docType: 'transaction', sales: 'true', isPosted: true,
                                            description: 'Initial balance',
                                            items: transactions]"
                    out-map="context" />
            </if>
            <!-- recalculate posted summary-->
            <service-call name="growerp.100.AccountingServices100.recalculate#GlAccountOrgSummaries"
                in-map="companyPartyId: relComp.companyPartyId" />
            <if condition="!ec.message.hasError()">
                <message type="success">${glAccounts.size()} glAccounts imported</message>
            </if>
        </actions>
    </service>

    <service verb="import" noun="Companies">
        <in-parameters>
            <parameter name="companies" required="true" type="List" />
            <parameter name="classificationId" />
        </in-parameters>
        <actions>
            <service-call
                name="growerp.100.GeneralServices100.get#RelatedCompanyAndOwner"
                out-map="context" />

            <iterate list="companies" entry="company">
                <!--log
                message="process pseudoId ${company.pseudoId} role: ${company.role}" /-->
                <if condition="company.partyId == '_MOD_'"><!-- used in automated test-->
                    <entity-find entity-name="growerp.party.OwnerCompanyDetailAndEmployee"
                        list="parties">
                        <econdition field-name="ownerPartyId" from="ownerPartyId" />
                        <econdition field-name="companyName" operator="like"
                            value="${company.name}%" />
                    </entity-find>
                    <if condition="!parties.isEmpty()">
                        <set field="company.partyId" from="parties[0].companyPartyId" />
                        <service-call name="growerp.100.PartyServices100.update#Company"
                            in-map="[company: company]" />
                    </if>
                    <else>
                        <if condition="!company.role">
                            <message type="warn">Company id: ${company.pseudoId} ${company.name} not processed, role is missing!\r\n</message>
                            <continue />
                        </if>
                        <if condition="!company.name">
                            <message type="warn">Company id: ${company.pseudoId} ${company.name} name is missing, set to pseudoId!\r\n</message>
                            <set field="company.name" from="company.pseudoId" />
                        </if>
                        <if
                            condition="company.email &amp;&amp; company.email != '' &amp;&amp; !org.apache.commons.validator.routines.EmailValidator.getInstance().isValid(company.email)">
                            <message type="warn">Company id: ${company.pseudoId} ${company.name} email: ${company.email} is not valid!\r\n</message>
                            <set field="company.email" value="" />
                        </if>
                        <!-- main company already exist so need update -->
                        <if condition="company.role == 'OrgInternal'">
                            <entity-find entity-name="growerp.party.OwnerCompanyDetailAndEmployee"
                                list="mainCompanies">
                                <econdition field-name="companyRole" value="OrgInternal" />
                                <econdition field-name="ownerPartyId" from="ownerPartyId" />
                            </entity-find>
                            <if condition="mainCompanies.isEmpty()">
                                <log level="warn"
                                    message="Main company supplied but cannot find within owner: $ownerPartyId" />
                                <else>
                                    <set field="company.partyId"
                                        from="mainCompanies[0].companyPartyId" />
                                    <service-call
                                        name="growerp.100.PartyServices100.update#Company"
                                        in-map="[company: company]" />
                                    <continue />
                                </else>
                            </if>
                        </if>
                        <!-- check if company already exist -->
                        <entity-find entity-name="mantle.party.Party" list="parties">
                            <econdition field-name="pseudoId" from="company.pseudoId" />
                            <econdition field-name="ownerPartyId" from="ownerPartyId" />
                        </entity-find>
                        <if condition="!parties.isEmpty()">
                            <then>
                                <entity-find entity-name="mantle.party.PartyRole" list="roles">
                                    <econdition field-name="partyId" from="parties[0].partyId" />
                                    <econdition field-name="roleTypeId" from="company.role" />
                                </entity-find>
                                <if condition="roles.isEmpty()">
                                    <service-call name="create#mantle.party.PartyRole"
                                        in-map="[   partyId: parties[0].partyId,
                                                        roleTypeId: company.role]" />
                                    <else>
                                        <message type="warn">Company: ${company.name} not processed, pseudoId: ${company.pseudoId} ${company.role} already exist!\r\n</message>
                                    </else>
                                </if>
                            </then>
                            <else>
                                <service-call
                                    name="growerp.100.PartyServices100.create#Company"
                                    in-map="[company: company]" />
                            </else>
                        </if>
                    </else>
                </if>
            </iterate>
            <if condition="!ec.message.hasError()">
                <message type="success">${companies.size()} companies imported</message>
            </if>
        </actions>
    </service>

    <service verb="import" noun="Users">
        <in-parameters>
            <parameter name="users" required="true" type="List" />
        </in-parameters>
        <actions>
            <iterate list="users" entry="user">
                <service-call name="growerp.100.PartyServices100.create#User"
                    in-map="[user: user]" />
            </iterate>
            <if condition="!ec.message.hasError()">
                <message type="success">${users.size()} users imported</message>
            </if>
        </actions>
    </service>

    <service verb="import" noun="Products">
        <in-parameters>
            <parameter name="products" required="true" type="List" />
            <parameter name="classificationId" required="true" />
        </in-parameters>
        <actions>
            <service-call name="growerp.100.GeneralServices100.get#RelatedCompanyAndOwner"
                out-map="relComp" />
            <script>ec.user.setEffectiveTime(Timestamp.valueOf("1999-01-01 00:00:00"))</script>
            <iterate list="products" entry="product">
                <!-- check if related category exist using name, if yes use these-->
                <iterate list="product.categories" entry="category">
                    <entity-find entity-name="mantle.product.category.ProductCategory"
                        list="foundCategories">
                        <econdition field-name="categoryName" from="category.categoryName" />
                        <econdition field-name="ownerPartyId" from="relComp.ownerPartyId" />
                    </entity-find>
                    <if condition="foundCategories">
                        <set field="category.categoryId"
                            from="foundCategories[0].productCategoryId" />
                    </if>
                </iterate>
                <entity-find entity-name="mantle.product.Product" list="products">
                    <econdition field-name="pseudoId" from="product.pseudoId" />
                    <econdition field-name="ownerPartyId" from="relComp.ownerPartyId" />
                </entity-find>
                <if condition="!products">
                    <service-call name="growerp.100.CatgProdServices100.create#Product"
                        out-map="result"
                        in-map="[product: product, classificationId: classificationId]" />
                </if>
            </iterate>
            <if condition="!ec.message.hasError()">
                <message type="success">${products.size()} products imported</message>
            </if>
        </actions>
    </service>

    <service verb="import" noun="Categories">
        <in-parameters>
            <parameter name="categories" required="true" type="List" />
            <parameter name="classificationId" />
        </in-parameters>
        <actions>
            <script>ec.user.setEffectiveTime(Timestamp.valueOf("1999-01-01 00:00:00"))</script>
            <iterate list="categories" entry="category">
                <service-call name="growerp.100.CatgProdServices100.create#ProductCategory"
                    in-map="[category: category, classificationId: classificationId]" />
            </iterate>
            <if condition="!ec.message.hasError()">
                <message type="success">${categories?.size()} categories imported</message>
            </if>
        </actions>
    </service>

    <service verb="import" noun="FinDocs">
        <in-parameters>
            <parameter name="finDocs" required="true" type="List" />
            <parameter name="classificationId" />
        </in-parameters>
        <actions>
            <log message="importing ${finDocs[0].docType} ${finDocs?.size()} finDocs" />
            <service-call out-map="context"
                name="growerp.100.GeneralServices100.get#RelatedCompanyAndOwner" />
            <!-- check if we have a timeperiod here just for transactions.....-->
            <if condition="finDocs[0].docType == 'transaction'">
                <log message="looking for date: ${finDocs[0].creationDate.substring(0,10)} 12:00:00" />
                <!-- date-filter does not seem to work here date: 2010-12-31 not found!-->
                <entity-find entity-name="mantle.party.time.TimePeriod" list="periods">
                    <econdition field-name="partyId" from="companyPartyId" />
                    <econdition field-name="fromDate" operator="less-equals"
                        from="Timestamp.valueOf(finDocs[0].creationDate)" />
                    <econdition field-name="thruDate" operator="greater-equals"
                        from="Timestamp.valueOf(finDocs[0].creationDate)" />
                </entity-find>
                <!-- when not yet create all until next year -->
                <if condition="!periods">
                    <log
                        message="Creating time periods starting with ${finDocs[0].creationDate.substring(0,4)}" />
                    <!-- delete existing-->
                    <entity-find entity-name="mantle.party.time.TimePeriod" list="periods">
                        <econdition field-name="partyId" from="companyPartyId" />
                        <order-by field-name="-timePeriodId" />
                    </entity-find>
                    <iterate list="periods.timePeriodId" entry="id">
                        <entity-delete-by-condition entity-name="mantle.party.time.TimePeriod">
                            <econdition field-name="partyId" from="companyPartyId" />
                            <econdition field-name="timePeriodId" from="id" />
                        </entity-delete-by-condition>
                    </iterate>
                    <!-- create new yearly, quartely, monthly periods until next year-->
                    <set field="nextYearInt"
                        from="((Calendar) ec.user.nowCalendar).get(Calendar.YEAR) + 1" />
                    <set field="lastYear" from="ec.l10n.format(nextYearInt, '0000')" />

                    <!-- start year from first tranaction ordered by date -->
                    <set field="curYear" from="finDocs[0].creationDate.substring(0,4)" />
                    <set field="prevPeriodId" from="null" />
                    <while condition="curYear &lt;= lastYear">
                        <set field="fromDate"
                            from="ec.l10n.parseDate(curYear + '-01-01', 'yyyy-MM-dd')" />
                        <service-call name="mantle.party.TimeServices.getOrCreate#TimePeriod"
                            out-map="curYearOut"
                            in-map="[partyId:companyPartyId, timePeriodTypeId:'FiscalYear', fromDate:fromDate, previousPeriodId:prevPeriodId]" />
                        <service-call name="mantle.party.TimeServices.get#DescendantPeriods"
                            out-map="quartersOut"
                            in-map="[parentPeriodId:curYearOut.timePeriodId, timePeriodTypeId:'FiscalQuarter', createMissing:true]" />
                        <iterate list="quartersOut.timePeriodList" entry="quarterPeriod">
                            <service-call name="mantle.party.TimeServices.get#DescendantPeriods"
                                out-map="quartersOut"
                                in-map="[parentPeriodId:quarterPeriod.timePeriodId, timePeriodTypeId:'FiscalMonth', createMissing:true]" />
                        </iterate>
                        <set field="prevPeriodId" from="curYearOut.timePeriodId" />
                        <set field="curYear" from="((curYear as int) + 1) as String" />
                    </while>
                    <entity-find-count entity-name="mantle.party.time.TimePeriod"
                        count-field="periods">
                        <econdition field-name="partyId" from="companyPartyId" />
                    </entity-find-count>
                    <log message="${periods} time periods created for company ${companyPartyId}" />
                </if>
            </if>
            <iterate list="finDocs" entry="finDoc">
                <script>ec.user.setEffectiveTime(Timestamp.valueOf(finDoc.creationDate))</script>
                <!-- find partyId of other company-->
                <if condition="!finDoc.otherCompany.pseudoId &amp;&amp; finDoc.otherCompany.name">
                    <set field="finDoc.otherCompany.pseudoId" from="finDoc.otherCompany.name" />
                </if>
                <if condition="finDoc.otherCompany &amp;&amp; finDoc.otherCompany.pseudoId">
                    <entity-find entity-name="mantle.party.Party" list="parties">
                        <econdition field-name="pseudoId" from="finDoc.otherCompany.pseudoId" />
                        <econdition field-name="ownerPartyId" from="ownerPartyId" />
                    </entity-find>
                    <if condition="parties">
                        <set field="finDoc.otherCompany.partyId" from="parties[0].partyId" />
                        <else-if
                            condition="finDoc.otherCompany.pseudoId &amp;&amp; finDoc.otherCompany.name">
                            <!-- create company -->
                            <if condition="finDoc.sales">
                                <set field="finDoc.otherCompany.role" value="Customer" />
                                <else>
                                    <set field="finDoc.otherCompany.role" value="Supplier" />
                                </else>
                            </if>
                            <service-call name="growerp.100.PartyServices100.create#Company"
                                in-map="[company: finDoc.otherCompany, ownerPartyId: ownerPartyId]"
                                out-map="context" />
                            <set field="finDoc.otherCompany.partyId" from="company.partyId" />
                            <log
                                message="finDocId ${finDoc.pseudoId} company pseudoId: ${finDoc.otherCompany.pseudoId} not found under owner: $ownerPartyId : added" />
                        </else-if>
                        <else>
                            <log level="warn"
                                message="finDocId ${finDoc.pseudoId} company pseudoId: ${finDoc.otherCompany.pseudoId} not found under owner: $ownerPartyId : need also name to add" />
                        </else>
                    </if>
                </if>
                <!-- transaction posted-->
                <if condition="finDoc.docType == 'transaction'">
                    <set field="finDoc.isPosted" value="false" type="Boolean" />
                </if>
                <!-- create findoc-->
                <service-call name="growerp.100.FinDocServices100.create#FinDoc"
                    in-map="[finDoc: finDoc, classificationId: classificationId]" out-map="result" />
                <!-- create references-->
                <if condition="finDoc.reference">
                    <if condition="finDoc.docType == 'invoice'">
                        <entity-find entity-name="mantle.ledger.transaction.AcctgTrans"
                            list="transactions" for-update="true">
                            <econdition field-name="organizationPartyId" from="companyPartyId" />
                            <econdition field-name="theirAcctgTransId" from="finDoc.reference" />
                        </entity-find>
                        <if condition="!transactions">
                            <log level="warn"
                                message="could not find invoice ${result.finDoc.invoiceId} reference ${finDoc.reference}" />
                            <else>
                                <if condition="transactions[0].invoiceId">
                                    <log level="warn"
                                        message="Transaction: ${transactions[0].acctgTransId}/${transactions[0].pseudoId} already has invoiceId: ${transactions[0].invoiceId} cannot add ${result.finDoc.invoiceId} reference: ${finDoc.reference}" />
                                    <else>
                                        <set field="transactions[0].invoiceId"
                                            from="result.finDoc.invoiceId" />
                                        <entity-update value-field="transactions[0]" />
                                    </else>
                                </if>
                            </else>
                        </if>
                    </if>
                </if>
            </iterate>
            <if condition="!ec.message.hasError()">
                <message type="success">${finDocs?.size()} finDocs  ${finDocs[0].docType} imported</message>
            </if>
        </actions>
    </service>

    <service verb="import" noun="FinDocItems" transaction-timeout="3600">
        <in-parameters>
            <parameter name="finDocItems" required="true" type="List" />
            <parameter name="classificationId" required="true" />
        </in-parameters>
        <actions>
            <service-call out-map="context"
                name="growerp.100.GeneralServices100.get#RelatedCompanyAndOwner" />
            <set field="itemsOut" from="[]" />
            <log message="importing ${finDocItems[0].docType} ${finDocItems?.size()} finDocItems" />
            <set field="index" value="0" type="Integer" />
            <iterate list="finDocItems" entry="item">
                <!-- log message="${index++}" /-->
                <if condition="lastItem &amp;&amp; lastItem.pseudoId != item.pseudoId">
                    <service-call name="growerp.100.FinDocServices100.get#FinDoc" out-map="context"
                        in-map="[pseudoId: lastItem.pseudoId,docType: lastItem.docType, classificationId: classificationId]" />
                    <script>ec.user.setEffectiveTime(Timestamp.valueOf("${finDoc.creationDate} 00:00:00"))</script>
                    <if condition="!finDocs.isEmpty()">
                        <set field="finDocs[0].items" from="itemsOut" />
                        <if condition="finDocs[0].docType == 'transaction'">
                            <set field="finDocs[0].isPosted" value="true" type="Boolean" />
                        </if>
                        <if condition="finDocs[0].docType == 'payment'">
                            <service-call name="growerp.100.ImportExportServices100.import#Payment"
                                in-map="[finDoc: finDocs[0], classificationId: classificationId]" />
                            <else>
                                <service-call name="growerp.100.FinDocServices100.update#FinDoc"
                                    in-map="[finDoc: finDocs[0], classificationId: classificationId]" />
                            </else>
                        </if>
                        <else>
                            <return error="true"
                                message="Could not find ${item.docType} ${item.pseudoId}!" />
                        </else>
                    </if>
                    <set field="itemsOut" from="[]" />
                </if>
                <if condition="!lastItem || lastItem.pseudoId != item.pseudoId">
                    <!-- find related finDoc header -->
                    <service-call name="growerp.100.FinDocServices100.get#FinDoc"
                        in-map="[pseudoId: item.pseudoId, docType: item.docType]"
                        out-map="context" />
                    <if condition="!finDocs">
                        <log level="error"
                            message="${item.docType} pseudoId: ${item.pseudoId} not found" />
                        <set field="lastItem" from="null" />
                        <continue />
                        <else>
                            <set field="finDoc" from="finDocs[0]" />
                        </else>
                    </if>
                </if>
                <if condition="item.glAccount.accountCode">
                    <!-- find internal item glAccountId from glAccount.accountCode-->
                    <entity-find entity-name="growerp.ledger.account.GlAccountAndOrganization"
                        list="glAccounts">
                        <econdition field-name="partyId" from="companyPartyId" />
                        <econdition field-name="accountCode" from="item.glAccount.accountCode" />
                    </entity-find>
                    <if condition="glAccounts">
                        <set field="item.glAccount.glAccountId" from="glAccounts[0].glAccountId" />
                        <else>
                            <log level="warn"
                                message="id: ${item.pseudoId} could not find item accountCode ${item.glAccount.accountCode} for company: $companyPartyId" />
                        </else>
                    </if>
                </if>
                <if condition="item.pseudoProductId">
                    <!-- find productId from pseudoProductId -->
                    <service-call name="growerp.100.CatgProdServices100.get#Products"
                        out-map="context"
                        in-map="[pseudoId: item.pseudoProductId, classificationId: classificationId, ownerPartyId: ownerPartyId]" />
                    <if condition="!products.isEmpty()"><!-- get services always provide list -->
                        <set field="item.productId" from="products[0].productId" />
                        <!-- update prices when on an invoice -->
                        <if condition="item.docType == 'invoice'">
                            <set field="products[0].price" from="item.price" />
                            <set field="products[0].listPrice" from="item.price" />
                            <service-call name="growerp.100.CatgProdServices100.update#Product"
                                out-map="context"
                                in-map="[product: products[0], classificationId: classificationId]" />
                        </if>
                        <else>
                            <!-- not found so better add it-->
                            <log
                                message="id: ${item.pseudoId} could not find pseudoProductId ${item.pseudoProductId} for owner: $ownerPartyId, will add it" />
                            <set field="product"
                                from="[
                                    ownerPartyId: ownerPartyId,
                                    pseudoId: item.pseudoProductId,
                                    productTypeId: 'Physical Good',
                                    productName: item.description,
                                    price: item.price,
                                    listPrice: item.price,
                                    ]" />
                            <service-call name="growerp.100.CatgProdServices100.create#Product"
                                out-map="context"
                                in-map="[product: product, classificationId: classificationId]" />
                            <set field="item.productId" from="product.productId" />
                        </else>
                    </if>
                </if>
                <!-- item type on orders if missing create some: -->
                <if condition="finDoc.docType == 'order' &amp;&amp; !item.itemType">
                    <log
                        message="id: ${item.pseudoId} no item type for ${item.glAccount.glAccountId} set to ItemExpense" />
                    <set field="item.itemType" from="[itemTypeId: 'ItemExpense']" />
                </if>
                <script>itemsOut.add(item)</script>
                <set field="lastItem" from="item" />
            </iterate>
            <!-- process last record -->
            <if condition="lastItem">
                <service-call name="growerp.100.FinDocServices100.get#FinDoc" out-map="context"
                    in-map="[pseudoId: lastItem.pseudoId,docType: lastItem.docType, classificationId: classificationId]" />
                <if condition="!finDocs.isEmpty()">
                    <set field="finDocs[0].items" from="itemsOut" />
                    <!-- transaction posted-->
                    <if condition="finDocs[0].docType == 'transaction'">
                        <set field="finDocs[0].isPosted" value="true" type="Boolean" />
                    </if>
                    <!-- add findoc items-->
                    <if condition="finDocs[0].docType == 'payment'">
                        <service-call name="growerp.100.ImportExportServices100.import#Payment"
                            in-map="[finDoc: finDocs[0], classificationId: classificationId]" />
                        <else>
                            <service-call name="growerp.100.FinDocServices100.update#FinDoc"
                                in-map="[finDoc: finDocs[0], classificationId: classificationId]" />
                        </else>
                    </if>
                    <else>
                        <return error="true"
                            message="Could not find ${item.docType} ${item.pseudoId}!" />
                    </else>
                </if>
                <!-- if transactions, check latest date and see if previous year period not close
                yet-->

            </if>

            <!-- end of service result -->
            <if condition="!ec.message.hasError()">
                <message type="success">${finDocItems?.size()} findoc items ${finDocItems[0].docType} imported</message>
            </if>
        </actions>
    </service>

    <service verb="import" noun="Payment" transaction-timeout="3600">
        <description>Special import for payment. some other ERP system allow items
            on payments like on a invoice, not in growerp/moqui so we need to make an
            extra invoice for this.
        </description>
        <in-parameters>
            <parameter name="finDoc" required="true" type="Map" />
            <parameter name="classificationId" required="true" />
        </in-parameters>
        <actions>
            <service-call out-map="context"
                name="growerp.100.GeneralServices100.get#RelatedCompanyAndOwner" />
            <service-call name="growerp.100.FinDocServices100.update#FinDoc"
                in-map="[finDoc: finDoc, classificationId: classificationId]"
                out-map="payment" />

            <if condition="!finDoc.reference &amp;&amp; finDoc.items.size() &gt; 1">
                <!-- if no related invoice and items, convert to invoice and create -->
                <service-call name="growerp.100.FinDocServices100.create#FinDoc"
                    in-map="[finDoc: finDoc + [docType: 'invoice', sales: !finDoc.sales]]"
                    out-map="invoice" />
                <service-call
                    name="mantle.account.PaymentServices.apply#InvoicePayment"
                    in-map="[paymentId: payment.finDoc.paymentId,
                            invoiceId: invoice.finDoc.invoiceId]" />
                <else>
                    <!-- reference points to existing transaction which could contain
                        invoiceId-->
                    <entity-find entity-name="mantle.ledger.transaction.AcctgTrans"
                        list="transactions" for-update="true">
                        <econdition field-name="organizationPartyId" from="companyPartyId" />
                        <econdition field-name="theirAcctgTransId" from="finDoc.reference" />
                    </entity-find>
                    <if condition="!transactions">
                        <log level="warn"
                            message="could not find invoice transaction of payment reference ${finDoc.reference}" />
                        <else>
                            <if condition="!transactions[0].invoiceId">
                                <log level="warn"
                                    message="Transaction: ${transactions[0].acctgTransId}/${transactions[0].pseudoId} does not have a related invoiceId: ${finDoc.reference}" />
                                <else>
                                    <!-- connect payment to invoice-->
                                    <service-call
                                        name="mantle.account.PaymentServices.apply#InvoicePayment"
                                        in-map="[paymentId: payment.finDoc.paymentId,
                                                invoiceId: transactions[0].invoiceId]" />
                                </else>
                            </if>
                        </else>
                    </if>

                </else>
            </if>
        </actions>
    </service>

    <!-- depreciated, just used by the screens-->
    <service verb="import" noun="Entities">
        <description> Import general entities</description>
        <in-parameters>
            <parameter name="entities" required="true" type="Map" />
            <parameter name="classificationId" />
        </in-parameters>
        <actions>
            <service-call name="growerp.100.GeneralServices100.get#RelatedCompanyAndOwner"
                out-map="relComp" />
            <if condition="entities.companies">
                <iterate list="entities.companies" entry="company">
                    <if condition="company.partyId == '_MOD_'">
                        <entity-find entity-name="growerp.party.OwnerCompanyDetailAndEmployee"
                            list="parties">
                            <econdition field-name="ownerPartyId" from="relComp.ownerPartyId" />
                            <econdition field-name="companyName" operator="like"
                                value="${company.name}%" />
                        </entity-find>
                        <if condition="parties">
                            <set field="company.partyId" from="parties[0].companyPartyId" />
                            <service-call name="growerp.100.PartyServices100.update#Company"
                                in-map="[company: company]" />
                        </if>
                        <else>
                            <service-call name="growerp.100.PartyServices100.create#Company"
                                in-map="[company: company, ownerPartyId: relComp.ownerPartyId]" />
                        </else>
                    </if>
                </iterate>
            </if>
            <if condition="entities.users">
                <iterate list="entities.users" entry="user">
                    <service-call name="growerp.100.PartyServices100.create#User"
                        in-map="[user: user]" />
                </iterate>
            </if>
            <if condition="entities.categories">
                <iterate list="entities.categories" entry="category">
                    <service-call name="growerp.100.CatgProdServices100.create#ProductCategory"
                        in-map="[category: category, classificationId: classificationId]" />
                </iterate>
            </if>
            <if condition="entities.products">
                <iterate list="entities.products" entry="product">
                    <!-- check if related category exist using name, if yes use these-->
                    <iterate list="product.categories" entry="category">
                        <entity-find entity-name="mantle.product.category.ProductCategory"
                            list="foundCategories">
                            <econdition field-name="categoryName" from="category.categoryName" />
                            <econdition field-name="ownerPartyId" from="relComp.ownerPartyId" />
                        </entity-find>
                        <if condition="foundCategories">
                            <set field="category.categoryId"
                                from="foundCategories[0].productCategoryId" />
                        </if>
                    </iterate>
                    <service-call name="growerp.100.CatgProdServices100.create#Product"
                        out-map="result"
                        in-map="[product: product, classificationId: classificationId]" />
                </iterate>
                <message public="true" type="success">Products Upload completed</message>
            </if>
            <if condition="entities.assets">
                <iterate list="entities.assets" entry="asset">
                    <service-call name="growerp.100.CatgProdServices100.create#Asset"
                        in-map="[asset: asset, classificationId: classificationId]" />
                </iterate>
                <message public="true" type="success">Assets Upload completed</message>
            </if>
            <if condition="entities.locations">
                <iterate list="entities.locations" entry="location">
                    <service-call name="growerp.100.WarehouseServices100.create#Location"
                        in-map="[location: location]" />
                </iterate>
                <message public="true" type="success">Locations Upload completed</message>
            </if>
            <!-- empty list will remove all accounts-->
            <if condition="entities.glAccounts || entities.glAccounts?.size == 0">
                <!-- delete existing transactions only initial if present-->
                <entity-find entity-name="mantle.ledger.transaction.AcctgTrans" list="transList">
                    <econdition field-name="organizationPartyId" from="relComp.companyPartyId" />
                </entity-find>
                <if condition="transList.size() &gt; 1">
                    <return error="true"
                        message="Can only delete ledger when when not more than the initial settiung of posted balance." />
                </if>
                <if condition="!transList.isEmpty()">
                    <entity-delete-by-condition
                        entity-name="mantle.ledger.transaction.AcctgTransEntry">
                        <econdition field-name="acctgTransId" from="transList[0].acctgTransId" />
                    </entity-delete-by-condition>
                    <entity-delete-by-condition entity-name="mantle.ledger.transaction.AcctgTrans">
                        <econdition field-name="acctgTransId" from="transList[0].acctgTransId" />
                    </entity-delete-by-condition>
                </if>
                <!-- delete existing ledger -->
                <entity-find entity-name="mantle.ledger.account.GlAccountAndOrganization"
                    list="glAccounts">
                    <econdition field-name="organizationPartyId" from="relComp.companyPartyId" />
                    <select-field field-name="glAccountId" />
                </entity-find>
                <entity-delete-by-condition
                    entity-name="mantle.ledger.account.GlAccountOrganization">
                    <econdition field-name="organizationPartyId" from="relComp.companyPartyId" />
                </entity-delete-by-condition>
                <entity-delete-by-condition
                    entity-name="mantle.ledger.account.GlAccount">
                    <econdition field-name="glAccountId" operator="in" from="glAccounts" />
                </entity-delete-by-condition>
                <!-- create new accounts and collect posted balances for new transactions-->
                <set field="transactions" from="[]" />
                <iterate list="entities.glAccounts" entry="newGlAccount">
                    <service-call name="growerp.100.AccountingServices100.create#GlAccount"
                        in-map="[glAccount: newGlAccount]"
                        out-map="createdGlAccount" />
                    <if condition="newGlAccount.postedBalance">
                        <script>transactions.add([
                            isDebit: createdGlAccount.glAccount.isDebit,
                            price: newGlAccount.postedBalance,
                            glAccount: [glAccountId: createdGlAccount.glAccount.glAccountId],
                        ])</script>
                    </if>
                </iterate>
                <!-- create unposted balance in initial transaction-->
                <if condition="!transactions.isEmpty()">
                    <service-call name="growerp.100.FinDocServices100.create#FinDoc"
                        in-map="finDoc: [docType: 'transaction', sales: 'true',
                                description: 'Initial balance',
                                items: transactions]"
                        out-map="context" />
                </if>
                <message public="true" type="success">${entities.glAccounts.size()} Ledger accounts with ${transactions.size()} initial transactions Upload completed</message>
            </if>
        </actions>
    </service>

    <service verb="get" noun="ExportCategories">
        <description>
            Get Categories information into a CSV file attachement
        </description>
        <in-parameters>
            <parameter name="classificationId"></parameter>
        </in-parameters>
        <out-parameters>
            <parameter name="fileText" />
        </out-parameters>
        <actions>
            <service-call name="growerp.100.CatgProdServices100.get#ProductCategories"
                in-map="[classificationId: classificationId]" out-map="context" />
            <set field="fileText" value="" />
            <script><![CDATA[
                import org.apache.commons.csv.CSVPrinter
                import org.apache.commons.csv.CSVFormat
                import org.apache.commons.csv.CSVRecord
                import org.apache.commons.csv.QuoteMode
                StringBuilder outSb = new StringBuilder()
                CSVPrinter printer = CSVFormat.DEFAULT.withHeader(
                    "name", "description", "image").print(outSb)
                for (Map item in categories) {
                    printer.printRecord(item.categoryName,
                                        item.description,
                                        item.image)}
                fileText = outSb.toString()
            ]]></script>
            <!--log
            message="output in catgories CSV: ${fileText}"/-->
        </actions>
    </service>

    <service verb="get" noun="ExportProducts">
        <description>
            Get Products information into a CSV file attachement
        </description>
        <out-parameters>
            <parameter name="fileText" />
        </out-parameters>
        <actions>
            <script>logger.warn("getting products")</script>
            <service-call name="growerp.100.CatgProdServices100.get#Products"
                out-map="context" />
            <set field="fileText" value="" />
            <script><![CDATA[
                import org.apache.commons.csv.CSVPrinter
                import org.apache.commons.csv.CSVFormat
                import org.apache.commons.csv.CSVRecord
                import org.apache.commons.csv.QuoteMode
                StringBuilder outSb = new StringBuilder()
                CSVPrinter printer = CSVFormat.DEFAULT.withHeader(
                    "name", "description", "Product Type Id", "image", "assetClassId","List Price","Price","Use Warehouse","Nbr of Assets","Category1", "Category2", "Category3").print(outSb)
                for (Map item in products) {
                    printer.printRecord(item.productName,
                                        item.description,
                                        item.productTypeId,
                                        item.image,
                                        item.assetClassId,
                                        item.listPrice,
                                        item.price,
                                        item.requireInventory,
                                        item.assetCount,
                                        item.categories[0] ? item.categories[0].categoryName :'',
                                        item.categories[1] ? item.categories[1].categoryName :'',
                                        item.categories[2] ? item.categories[2].categoryName :'',
                                        )}
                fileText = outSb.toString()
            ]]></script>
        </actions>
    </service>

    <service verb="get" noun="ExportGlAccounts">
        <description>
            Get ledger Gl Accounts information into a CSV file attachement
        </description>
        <in-parameters>
            <parameter name="classificationId" />
        </in-parameters>
        <out-parameters>
            <parameter name="fileText" />
        </out-parameters>
        <actions>
            <service-call name="growerp.100.AccountingServices100.get#GlAccount"
                in-map="[limit: 999]"
                out-map="context" />
            <set field="fileText" value="" />
            <script><![CDATA[
                import org.apache.commons.csv.CSVPrinter
                import org.apache.commons.csv.CSVFormat
                import org.apache.commons.csv.CSVRecord
                import org.apache.commons.csv.QuoteMode
                StringBuilder outSb = new StringBuilder()
                CSVPrinter printer = CSVFormat.DEFAULT.withHeader(
                    "id", "name", "isDebit", "class", "type","postedBalance").print(outSb)
                for (Map item in glAccountList) {
                    printer.printRecord(item.accountCode,
                                        item.accountName,
                                        item.isDebit,
                                        item.accountClass.description,
                                        item.accountType.description,
                                        item.posteBalance,
                                        )}
                fileText = outSb.toString()
            ]]></script>
        </actions>
    </service>


    <service verb="export" noun="Entities">
        <description> Export general entities</description>
        <in-parameters>
            <parameter name="entityName" required="true" />
            <parameter name="classificationId" required="true" />
        </in-parameters>
        <actions>
            <set field="emailAddress" from="ec.user.userAccount.emailAddress" />
            <set field="userAccount" from="ec.user.userAccount" />
            <set field="bodyParameters" from="[classificationId: classificationId]" />
            <if condition="entityName == 'Category'">
                <service-call name="org.moqui.impl.EmailServices.send#EmailTemplate" async="true"
                    in-map="[emailTemplateId: 'GrowerpExportCategories',
                        toAddresses: emailAddress, bodyParameters: bodyParameters]"
                    out-map="context" />
                <message public="true" type="success">A Categories CSV file was sent by email to ${userAccount.emailAddress}.</message>
            </if>
            <if condition="entityName == 'Product'">
                <service-call name="org.moqui.impl.EmailServices.send#EmailTemplate" async="true"
                    in-map="[emailTemplateId: 'GrowerpExportProducts',
                        toAddresses: emailAddress, bodyParameters: bodyParameters]"
                    out-map="context" />
                <message public="true" type="success">A Products CSV file was sent by email to ${userAccount.emailAddress}.</message>
            </if>
            <if condition="entityName == 'GlAccount'">
                <service-call name="org.moqui.impl.EmailServices.send#EmailTemplate" async="true"
                    in-map="[emailTemplateId: 'GrowerpExportGlAccounts',
                        toAddresses: emailAddress, bodyParameters: bodyParameters]"
                    out-map="context" />
                <message public="true" type="success">A GlAccount CSV file was sent by email to ${userAccount.emailAddress}.</message>
            </if>
        </actions>
    </service>

    <service verb="export" noun="Website">
        <out-parameters>
            <parameter name="website" type="Map" />
        </out-parameters>
        <actions>
            <service-call name="growerp.100.WebsiteServices100.get#Website"
                out-map="context" />
            <set field="websiteContent" from="[]" />
            <iterate list="website.websiteContent" entry="wsContent">
                <service-call name="growerp.100.WebsiteServices100.get#WebsiteContent"
                    in-map="path: wsContent.path, text: wsContent.text"
                    out-map="context" />
                <script>
                    websiteContent.add(content)
                </script>
            </iterate>
            <set field="website.websiteContent" from="websiteContent" />
        </actions>
    </service>

    <service verb="import" noun="Website">
        <in-parameters>
            <parameter name="website" type="Map" required="true">
                <parameter name="id" required="true" />
                <parameter name="title" />
                <parameter name="hostName" />
                <parameter name="websiteContent" type="List">
                    <parameter name="content" type="Map">
                        <parameter name="path" />
                        <parameter name="title" /><!-- if path found and title empty, page will be
                        deleted -->
                        <parameter name="text" />
                        <parameter name="seqId" type="Integer" />
                    </parameter>
                </parameter>
                <parameter name="websiteCategories" type="List">
                    <parameter name="websiteCategory" type="Map">
                        <parameter name="categoryId" />
                        <parameter name="categoryName" />
                        <parameter name="products" type="List" />
                        <parameter name="product" type="Map">
                            <parameter name="productId" />
                            <parameter name="productName" />
                        </parameter>
                    </parameter>
                </parameter>
                <parameter name="productCategories" type="List">
                    <parameter name="productCategory" type="Map">
                        <parameter name="categoryId" />
                    </parameter>
                </parameter>
                <parameter name="colorJson" />
                <parameter name="obsidianName" />
                <parameter name="measurementId" />
            </parameter>
            <parameter name="webContents" type="List">
                <parameter name="path" />
                <parameter name="title" />
                <parameter name="text" />
                <parameter name="image" />
                <parameter name="seqId" type="Integer" />
            </parameter>
        </in-parameters>
        <out-parameters>
            <parameter name="website" />
        </out-parameters>
        <actions>
            <service-call name="growerp.100.WebsiteServices100.update#Website"
                in-map="website: website"
                out-map="context" />
            <iterate list="websiteContents" entry="webSiteContent">
                <service-call name="growerp.100.WebsiteServices100.upload#WebsiteContent"
                    in-map="content: websiteContent"
                    out-map="context" />
            </iterate>
        </actions>
    </service>

</services>