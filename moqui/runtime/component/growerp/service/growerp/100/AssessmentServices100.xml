<?xml version="1.0" encoding="UTF-8"?>
<!--
Assessment Services for GrowERP Landing Page & Assessment System
Service definitions for assessment management and completion
- Supports dual-ID lookup: assessmentId (system-wide) or pseudoId (tenant-unique)
- All services enforce multi-tenant isolation via ownerPartyId
- Implementation: Groovy service classes and REST controllers
-->
<services xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:noNamespaceSchemaLocation="http://moqui.org/xsd/service-definition-3.xsd">

    <!-- ============================================ -->
    <!-- ASSESSMENT SERVICES (6 services) -->
    <!-- ============================================ -->

    <!-- getAssessment: Retrieve single assessment with all related data -->
    <service verb="get" noun="Assessment" authenticate="false">
        <description>Get single assessment by ID or pseudoId with all questions, options, and thresholds. Anonymous users can view assessments.</description>
        <in-parameters>
            <parameter name="assessmentId">
                <description>System-wide unique assessment ID</description>
            </parameter>
            <parameter name="pseudoId">
                <description>Tenant-unique assessment pseudoId</description>
            </parameter>
            <parameter name="ownerPartyId">
                <description>Owner party ID for multi-tenant isolation (optional for anonymous access)</description>
            </parameter>
        </in-parameters>
        <out-parameters>
            <parameter name="assessment" type="Map">
                <description>Assessment object with nested questions, options, and thresholds</description>
                <auto-parameters entity-name="growerp.assessment.Assessment" include="all" />
                <parameter name="assessmentId" />
                <parameter name="pseudoId" />
                <parameter name="assessmentName" />
                <parameter name="description" />
                <parameter name="status" />
                <parameter name="createdDate" type="Timestamp" />
                <parameter name="createdByUserLogin" />
                <parameter name="lastModifiedDate" type="Timestamp" />
                <parameter name="lastModifiedByUserLogin" />
                <parameter name="questions" type="List">
                    <description>List of assessment questions with nested options</description>
                    <parameter name="assessmentQuestionId" />
                    <parameter name="pseudoId" />
                    <parameter name="assessmentId" />
                    <parameter name="questionSequence" type="Integer" />
                    <parameter name="questionType" />
                    <parameter name="questionText" />
                    <parameter name="questionDescription" />
                    <parameter name="isRequired" />
                    <parameter name="defaultOption" />
                    <parameter name="defaultValue" />
                    <parameter name="createdDate" type="Timestamp" />
                    <parameter name="createdByUserLogin" />
                    <parameter name="options" type="List">
                        <description>List of answer options for this question</description>
                        <parameter name="assessmentQuestionOptionId" />
                        <parameter name="pseudoId" />
                        <parameter name="assessmentQuestionId" />
                        <parameter name="assessmentId" />
                        <parameter name="optionSequence" type="Integer" />
                        <parameter name="optionText" />
                        <parameter name="optionScore" type="BigDecimal" />
                        <parameter name="createdDate" type="Timestamp" />
                    </parameter>
                </parameter>
                <parameter name="thresholds" type="List">
                    <description>List of scoring thresholds</description>
                    <parameter name="scoringThresholdId" />
                    <parameter name="pseudoId" />
                    <parameter name="assessmentId" />
                    <parameter name="minScore" type="BigDecimal" />
                    <parameter name="maxScore" type="BigDecimal" />
                    <parameter name="leadStatus" />
                    <parameter name="description" />
                    <parameter name="createdDate" type="Timestamp" />
                    <parameter name="createdByUserLogin" />
                </parameter>
            </parameter>
        </out-parameters>
        <actions>
            <log
                message="=========get assessment serv owner: ${ownerPartyId} asses: ${assessmentId} pseudo: ${pseudoId}" />
            <!-- For anonymous access, ownerPartyId must be provided as parameter -->
            <!-- For authenticated access, get it from user context -->
            <if condition="!ownerPartyId">
                <service-call out-map="context"
                    name="growerp.100.GeneralServices100.get#RelatedCompanyAndOwner" />
            </if>

            <!-- SINGLE ASSESSMENT RETRIEVAL using AssessmentComplete view -->
            <if condition="!assessmentId &amp;&amp; !pseudoId">
                <return error="true" message="Either assessmentId or pseudoId is required" />
            </if>

            <!-- pseudoId requires ownerPartyId for tenant isolation -->
            <if condition="pseudoId &amp;&amp; !ownerPartyId">
                <return error="true" message="ownerPartyId is required when using pseudoId" />
            </if>

            <entity-find entity-name="growerp.assessment.AssessmentComplete" list="completeData">
                <econdition field-name="ownerPartyId" from="ownerPartyId" ignore-if-empty="true" />
                <econdition field-name="assessmentId" from="assessmentId" ignore-if-empty="true" />
                <econdition field-name="pseudoId" from="pseudoId" ignore-if-empty="true" />
                <order-by field-name="questionSequence" />
                <order-by field-name="optionSequence" />
            </entity-find>

            <if condition="!completeData">
                <return error="true" message="Assessment not found" />
            </if>

            <!-- Build assessment structure from view results -->
            <script><![CDATA[
                import groovy.json.JsonOutput
                
                // Get first row for assessment data
                def firstRow = completeData[0]
                
                // Build assessment object
                def assessment = [
                    assessmentId: firstRow.assessmentId,
                    pseudoId: firstRow.assessmentPseudoId,
                    assessmentName: firstRow.assessmentName,
                    description: firstRow.assessmentDescription,
                    status: firstRow.assessmentStatus,
                    createdDate: firstRow.assessmentCreatedDate,
                    createdByUserLogin: firstRow.assessmentCreatedByUserLogin,
                    lastModifiedDate: firstRow.assessmentLastModifiedDate,
                    lastModifiedByUserLogin: firstRow.assessmentLastModifiedByUserLogin
                ]
                
                // Build questions with options and thresholds
                def questionsMap = [:]
                def optionsMap = [:] // Map to deduplicate options by assessmentQuestionOptionId
                def thresholdsMap = [:]
                
                completeData.each { row ->
                    // Process question if present
                    if (row.assessmentQuestionId) {
                        if (!questionsMap.containsKey(row.assessmentQuestionId)) {
                            questionsMap[row.assessmentQuestionId] = [
                                assessmentQuestionId: row.assessmentQuestionId,
                                pseudoId: row.questionPseudoId,
                                assessmentId: row.assessmentId,
                                questionSequence: row.questionSequence,
                                questionType: row.questionType,
                                questionText: row.questionText,
                                questionDescription: row.questionDescription,
                                isRequired: row.isRequired,
                                defaultOption: row.defaultOption,
                                defaultValue: row.defaultValue,
                                createdDate: row.questionCreatedDate,
                                createdByUserLogin: row.questionCreatedByUserLogin,
                                options: []
                            ]
                        }
                        
                        // Add option to question if present - deduplicate by assessmentQuestionOptionId
                        if (row.assessmentQuestionOptionId) {
                            def optionKey = row.assessmentQuestionId + ':' + row.assessmentQuestionOptionId
                            if (!optionsMap.containsKey(optionKey)) {
                                optionsMap[optionKey] = [
                                    assessmentQuestionOptionId: row.assessmentQuestionOptionId,
                                    pseudoId: row.optionPseudoId,
                                    assessmentQuestionId: row.assessmentQuestionId,
                                    assessmentId: row.assessmentId,
                                    optionSequence: row.optionSequence,
                                    optionText: row.optionText,
                                    optionScore: row.optionScore,
                                    createdDate: row.optionCreatedDate
                                ]
                                questionsMap[row.assessmentQuestionId].options.add(optionsMap[optionKey])
                            }
                        }
                    }
                    
                    // Process threshold if present (deduplicate by scoringThresholdId)
                    if (row.scoringThresholdId && !thresholdsMap.containsKey(row.scoringThresholdId)) {
                        thresholdsMap[row.scoringThresholdId] = [
                            scoringThresholdId: row.scoringThresholdId,
                            pseudoId: row.thresholdPseudoId,
                            assessmentId: row.assessmentId,
                            minScore: row.minScore,
                            maxScore: row.maxScore,
                            leadStatus: row.leadStatus,
                            description: row.thresholdDescription,
                            createdDate: row.thresholdCreatedDate,
                            createdByUserLogin: row.thresholdCreatedByUserLogin
                        ]
                    }
                }
                
                // Convert questions map to sorted list
                assessment.questions = questionsMap.values().sort { it.questionSequence }
                
                // Sort options within each question by optionSequence
                assessment.questions.each { question ->
                    question.options = question.options.sort { it.optionSequence }
                }
                
                // Convert thresholds map to sorted list
                assessment.thresholds = thresholdsMap.values().sort { it.minScore }
                
                context.assessment = assessment
                
                // Debug logging
                ec.logger.warn("=== Assessment ${assessment.assessmentId} complete structure ===")
                ec.logger.warn("Assessment name: ${assessment.assessmentName}")
                ec.logger.warn("Questions count: ${assessment.questions?.size()}")
                ec.logger.warn("Thresholds count: ${assessment.thresholds?.size()}")
                if (assessment.questions) {
                    assessment.questions.each { q ->
                        ec.logger.warn("  Question ${q.questionSequence}: ${q.questionText?.take(50)} (${q.options?.size()} options)")
                    }
                }
            ]]></script>

            <log level="info"
                message="Assessment ${assessment.assessmentId}: Loaded ${assessment.questions?.size() ?: 0} questions and ${assessment.thresholds?.size() ?: 0} thresholds" />
        </actions>
    </service>

    <!-- listAssessments: Get all assessments OR single assessment WITHOUT nested data -->
    <service verb="list" noun="Assessments" authenticate="true">
        <description>
            List assessments for maintenance screens WITHOUT nested data (questions/options/thresholds).
            When assessmentId or pseudoId provided: Returns single assessment basic info only.
            When neither provided: Returns paginated list of assessments.
            Results automatically filtered by authenticated user's company.
            For full nested data (taking assessments), use get#Assessment instead.
        </description>
        <in-parameters>
            <parameter name="assessmentId">
                <description>Optional: Get specific assessment by system-wide ID (basic info only)</description>
            </parameter>
            <parameter name="pseudoId">
                <description>Optional: Get specific assessment by tenant-unique pseudoId (basic info only)</description>
            </parameter>
            <parameter name="status">
                <description>Optional status filter: ACTIVE, INACTIVE, DRAFT</description>
            </parameter>
            <parameter name="pageNumber" type="Integer" default-value="1">
                <description>Page number (1-based, only for list mode)</description>
            </parameter>
            <parameter name="pageSize" type="Integer" default-value="20">
                <description>Results per page (only for list mode)</description>
            </parameter>
        </in-parameters>
        <out-parameters>
            <parameter name="assessments" type="List">
                <description>List of assessment objects (basic info only, no nested questions/options/thresholds)</description>
                <parameter name="assessmentId" />
                <parameter name="pseudoId" />
                <parameter name="assessmentName" />
                <parameter name="description" />
                <parameter name="status" />
                <parameter name="createdDate" type="Timestamp" />
                <parameter name="createdByUserLogin" />
                <parameter name="lastModifiedDate" type="Timestamp" />
                <parameter name="lastModifiedByUserLogin" />
            </parameter>
            <parameter name="totalCount" type="Integer">
                <description>Total number of assessments matching filter</description>
            </parameter>
            <parameter name="pageCount" type="Integer">
                <description>Total number of pages</description>
            </parameter>
        </out-parameters>
        <actions>
            <service-call out-map="context"
                name="growerp.100.GeneralServices100.get#RelatedCompanyAndOwner" />
            <if condition="!ownerPartyId">
                <return error="true" message="User not authenticated or no party associated" />
            </if>

            <!-- MODE 1: Get single assessment WITHOUT nested data -->
            <if condition="assessmentId || pseudoId">
                <entity-find entity-name="growerp.assessment.Assessment" list="assessments">
                    <econdition field-name="ownerPartyId" from="ownerPartyId" />
                    <econdition field-name="assessmentId" from="assessmentId" ignore-if-empty="true" />
                    <econdition field-name="pseudoId" from="pseudoId" ignore-if-empty="true" />
                </entity-find>

                <if condition="!assessments">
                    <return error="true" message="Assessment not found or access denied" />
                </if>

                <set field="totalCount" from="1" />
                <set field="pageCount" from="1" />

                <log level="info"
                    message="list#Assessments (single): Loaded assessment ${assessmentId ?: pseudoId} basic info only" />

                <return />
            </if>

            <!-- MODE 2: List all assessments without nested data -->
            <!-- Count total assessments for pagination -->
            <entity-find entity-name="growerp.assessment.Assessment" list="countList">
                <econdition field-name="ownerPartyId" from="ownerPartyId" />
                <econdition field-name="status" from="status" ignore-if-empty="true" />
                <select-field field-name="assessmentId" />
            </entity-find>
            <set field="totalCount" from="countList.size()" />
            <set field="pageCount" from="Math.ceil(totalCount / pageSize)" />

            <!-- Get paginated assessments -->
            <set field="offset" from="(pageNumber - 1) * pageSize" />
            <entity-find entity-name="growerp.assessment.Assessment" list="assessments"
                limit="pageSize" offset="offset">
                <econdition field-name="ownerPartyId" from="ownerPartyId" />
                <econdition field-name="status" from="status" ignore-if-empty="true" />
                <order-by field-name="createdDate" />
            </entity-find>

            <log level="info"
                message="list#Assessments (list): Returned ${assessments.size()} assessments (page ${pageNumber} of ${pageCount})" />
        </actions>
    </service>

    <!-- createAssessment: Create new assessment -->
    <service verb="create" noun="Assessment" authenticate="true">
        <description>Create new assessment within a tenant. Owner automatically derived from authenticated user context.</description>
        <in-parameters>
            <parameter name="assessmentName" type="String" required="true">
                <description>Name of the assessment</description>
            </parameter>
            <parameter name="description">
                <description>Description or instructions for the assessment</description>
            </parameter>
            <parameter name="status" type="String" default-value="ACTIVE">
                <description>Status: ACTIVE, INACTIVE, DRAFT</description>
            </parameter>
        </in-parameters>
        <out-parameters>
            <parameter name="assessmentId" />
            <parameter name="pseudoId" />
            <parameter name="ownerPartyId" />
            <parameter name="assessmentName" />
            <parameter name="description" />
            <parameter name="status" />
            <parameter name="createdDate" type="Long" />
            <parameter name="createdByUserLogin" />
            <parameter name="lastModifiedDate" type="Long" />
            <parameter name="lastModifiedByUserLogin" />
            <parameter name="lastUpdatedStamp" type="Long" />
        </out-parameters>
        <actions>
            <service-call out-map="context"
                name="growerp.100.GeneralServices100.get#RelatedCompanyAndOwner" />
            <if condition="!ownerPartyId">
                <return error="true" message="User not authenticated or no party associated" />
            </if>

            <!-- Generate unique pseudoId within the tenant -->
            <if condition="!pseudoId || pseudoId == ''">
                <service-call name="growerp.100.GeneralServices100.getNext#PseudoId"
                    in-map="[ownerPartyId: ownerPartyId, seqName: 'Assessment']" out-map="context" />
                <set field="pseudoId" from="seqNum" />
            </if>

            <!-- Create the assessment -->
            <service-call name="create#growerp.assessment.Assessment" out-map="createOut">
                <field-map field-name="assessmentName" from="assessmentName" />
                <field-map field-name="description" from="description" />
                <field-map field-name="status" from="status" />
                <field-map field-name="ownerPartyId" from="ownerPartyId" />
                <field-map field-name="pseudoId" from="pseudoId" />
                <field-map field-name="createdByUserLogin" from="ec.user.username" />
                <field-map field-name="createdDate" from="ec.user.nowTimestamp" />
                <field-map field-name="lastModifiedDate" from="ec.user.nowTimestamp" />
                <field-map field-name="lastModifiedByUserLogin" from="ec.user.username" />
            </service-call>

            <set field="assessmentId" from="createOut.assessmentId" />

            <!-- Get the created assessment and return its fields directly -->
            <entity-find-one entity-name="growerp.assessment.Assessment" value-field="assessment">
                <field-map field-name="assessmentId" from="assessmentId" />
            </entity-find-one>

            <!-- Set individual response fields -->
            <set field="assessmentName" from="assessment.assessmentName" />
            <set field="description" from="assessment.description" />
            <set field="status" from="assessment.status" />
            <set field="ownerPartyId" from="assessment.ownerPartyId" />
            <set field="createdDate" from="assessment.createdDate" />
            <set field="createdByUserLogin" from="assessment.createdByUserLogin" />
            <set field="lastModifiedDate" from="assessment.lastModifiedDate" />
            <set field="lastModifiedByUserLogin" from="assessment.lastModifiedByUserLogin" />
            <set field="lastUpdatedStamp" from="assessment.lastUpdatedStamp" />
        </actions>
    </service>

    <!-- updateAssessment: Update existing assessment -->
    <service verb="update" noun="Assessment" authenticate="true">
        <description>Update assessment (name, description, status only). Authorization automatically verified against authenticated user.</description>
        <in-parameters>
            <parameter name="assessmentId" type="String" required="true">
                <description>Assessment ID to update</description>
            </parameter>
            <parameter name="assessmentName">
                <description>New assessment name</description>
            </parameter>
            <parameter name="description">
                <description>New assessment description</description>
            </parameter>
            <parameter name="status">
                <description>New status: ACTIVE, INACTIVE, DRAFT</description>
            </parameter>
        </in-parameters>
        <out-parameters>
            <parameter name="assessmentId">
                <description>Updated assessment ID</description>
            </parameter>
        </out-parameters>
        <actions>
            <service-call out-map="context"
                name="growerp.100.GeneralServices100.get#RelatedCompanyAndOwner" />
            <if condition="!ownerPartyId">
                <return error="true" message="User not authenticated or no party associated" />
            </if>

            <!-- Verify assessment exists and user has access -->
            <entity-find entity-name="growerp.assessment.Assessment" list="assessmentList">
                <econdition field-name="assessmentId" from="assessmentId" />
                <econdition field-name="ownerPartyId" from="ownerPartyId" />
            </entity-find>

            <if condition="!assessmentList">
                <return error="true" message="Assessment not found or access denied" />
            </if>

            <!-- Update the assessment -->
            <set field="updateMap"
                from="[assessmentId: assessmentId, lastModifiedDate: ec.user.nowTimestamp, lastModifiedByUserLogin: ec.user.username]" />
            <if condition="assessmentName">
                <set field="updateMap.assessmentName" from="assessmentName" />
            </if>
            <if condition="description">
                <set field="updateMap.description" from="description" />
            </if>
            <if condition="status">
                <set field="updateMap.status" from="status" />
            </if>

            <service-call name="update#growerp.assessment.Assessment" in-map="updateMap" />
        </actions>
    </service>

    <!-- deleteAssessment: Delete assessment and cascade -->
    <service verb="delete" noun="Assessment" authenticate="true">
        <description>Delete assessment and all related questions, options, thresholds, and results. Authorization automatically verified against authenticated user.</description>
        <in-parameters>
            <parameter name="assessmentId" type="String" required="true">
                <description>Assessment ID to delete</description>
            </parameter>
        </in-parameters>
        <out-parameters>
            <parameter name="deletedCount" type="Integer">
                <description>Total number of records deleted (cascade)</description>
            </parameter>
        </out-parameters>
        <actions>
            <service-call out-map="context"
                name="growerp.100.GeneralServices100.get#RelatedCompanyAndOwner" />
            <if condition="!ownerPartyId">
                <return error="true" message="User not authenticated or no party associated" />
            </if>

            <!-- Verify assessment exists and user has access -->
            <entity-find entity-name="growerp.assessment.Assessment" list="assessmentList">
                <econdition field-name="assessmentId" from="assessmentId" />
                <econdition field-name="ownerPartyId" from="ownerPartyId" />
            </entity-find>

            <if condition="!assessmentList">
                <return error="true" message="Assessment not found or access denied" />
            </if>

            <set field="deletedCount" from="0" />

            <!-- Delete assessment results first -->
            <entity-find entity-name="growerp.assessment.AssessmentResult" list="resultList">
                <econdition field-name="assessmentId" from="assessmentId" />
            </entity-find>
            <iterate list="resultList" entry="result">
                <entity-delete value-field="result" />
                <set field="deletedCount" from="deletedCount + 1" />
            </iterate>

            <!-- Delete scoring thresholds -->
            <entity-find entity-name="growerp.assessment.ScoringThreshold" list="thresholdList">
                <econdition field-name="assessmentId" from="assessmentId" />
            </entity-find>
            <iterate list="thresholdList" entry="threshold">
                <entity-delete value-field="threshold" />
                <set field="deletedCount" from="deletedCount + 1" />
            </iterate>

            <!-- Delete question options -->
            <entity-find entity-name="growerp.assessment.AssessmentQuestionOption" list="optionList">
                <econdition field-name="assessmentId" from="assessmentId" />
            </entity-find>
            <iterate list="optionList" entry="option">
                <entity-delete value-field="option" />
                <set field="deletedCount" from="deletedCount + 1" />
            </iterate>

            <!-- Delete questions -->
            <entity-find entity-name="growerp.assessment.AssessmentQuestion" list="questionList">
                <econdition field-name="assessmentId" from="assessmentId" />
            </entity-find>
            <iterate list="questionList" entry="question">
                <entity-delete value-field="question" />
                <set field="deletedCount" from="deletedCount + 1" />
            </iterate>

            <!-- Delete the assessment itself -->
            <entity-delete value-field="assessmentList[0]" />
            <set field="deletedCount" from="deletedCount + 1" />
        </actions>
    </service>

    <!-- submitAssessment: Submit completed assessment -->
    <service verb="submit" noun="Assessment" authenticate="false">
        <description>Submit assessment answers, capture lead info, calculate score, determine status. Public endpoint - no authentication required. Consolidates score calculation, result creation, and optional user creation.</description>
        <in-parameters>
            <parameter name="assessmentId" type="String" required="true">
                <description>Assessment ID being submitted</description>
            </parameter>
            <parameter name="answersData" type="String" required="true">
                <description>JSON with answers: {questionId: optionId, ...}</description>
            </parameter>
            <parameter name="respondentName" type="String" required="true">
                <description>Lead name from step 1</description>
            </parameter>
            <parameter name="respondentEmail" type="String" required="true">
                <description>Lead email from step 1</description>
            </parameter>
            <parameter name="respondentPhone">
                <description>Lead phone from step 1</description>
            </parameter>
            <parameter name="respondentCompany">
                <description>Lead company from step 1</description>
            </parameter>
            <parameter name="ownerPartyId" type="String">
                <description>Optional owner party ID. If not provided, will be retrieved from assessment. Used for anonymous submissions to specify which company owns the lead.</description>
            </parameter>
        </in-parameters>
        <out-parameters>
            <parameter name="assessmentResultId">
                <description>Created assessment result ID</description>
            </parameter>
            <parameter name="pseudoId">
                <description>Created result tenant-unique ID</description>
            </parameter>
            <parameter name="assessmentId">
                <description>Assessment ID that was submitted</description>
            </parameter>
            <parameter name="score" type="BigDecimal">
                <description>Calculated score from answers</description>
            </parameter>
            <parameter name="leadStatus">
                <description>Determined lead status: Cold, Warm, Hot</description>
            </parameter>
            <parameter name="respondentName">
                <description>Respondent name</description>
            </parameter>
            <parameter name="respondentEmail">
                <description>Respondent email</description>
            </parameter>
            <parameter name="respondentPhone">
                <description>Respondent phone number</description>
            </parameter>
            <parameter name="respondentCompany">
                <description>Respondent company name</description>
            </parameter>
            <parameter name="answersData">
                <description>JSON encoded answers data</description>
            </parameter>
            <parameter name="createdDate">
                <description>Timestamp when submitted</description>
            </parameter>
        </out-parameters>
        <actions>
            <!-- Get assessment to verify it exists -->
            <entity-find-one entity-name="growerp.assessment.Assessment" value-field="assessment">
                <field-map field-name="assessmentId" from="assessmentId" />
            </entity-find-one>

            <if condition="!assessment">
                <return error="true" message="Assessment not found" />
            </if>

            <!-- Use provided ownerPartyId or get from assessment -->
            <if condition="!ownerPartyId">
                <set field="ownerPartyId" from="assessment.ownerPartyId" />
            </if>

            <!-- Parse answers JSON to calculate score inline (instead of separate service call) -->
            <script>
                import groovy.json.JsonSlurper
                def jsonSlurper = new JsonSlurper()
                def answers = jsonSlurper.parseText(answersData)
                context.answers = answers
            </script>

            <set field="totalScore" type="BigDecimal" from="0" />

            <!-- Get all question options and calculate score -->
            <iterate list="answers" entry="answerEntry" key="assessmentQuestionId">
                <set field="assessmentQuestionOptionId" from="answerEntry" />
                <entity-find-one entity-name="growerp.assessment.AssessmentQuestionOption"
                    value-field="option">
                    <field-map field-name="assessmentQuestionOptionId"
                        from="assessmentQuestionOptionId" />
                    <field-map field-name="assessmentQuestionId" from="assessmentQuestionId" />
                    <field-map field-name="assessmentId" from="assessmentId" />
                </entity-find-one>

                <if condition="option?.optionScore">
                    <set field="totalScore" from="totalScore + (option.optionScore as BigDecimal)" />
                </if>
            </iterate>

            <set field="score" from="totalScore" />

            <!-- Determine lead status from thresholds -->
            <entity-find entity-name="growerp.assessment.ScoringThreshold" list="thresholds">
                <econdition field-name="assessmentId" from="assessmentId" />
                <econdition field-name="minScore" operator="less-equals" from="score" />
                <econdition field-name="maxScore" operator="greater-equals" from="score" />
            </entity-find>

            <set field="leadStatus" from="thresholds ? thresholds[0].leadStatus : 'Unknown'" />

            <!-- Always create lead user from respondent info -->
            <script>
                // Parse name into firstName and lastName
                def nameParts = respondentName.trim().split(' ')
                def firstName = nameParts.length > 0 ? nameParts[0] : ''
                def lastName = nameParts.length > 1 ? nameParts[1..-1].join(' ') : ''
                context.firstName = firstName
                context.lastName = lastName
            </script>

            <!-- Check if user already exists with this email address -->
            <entity-find entity-name="mantle.party.contact.ContactMech" list="existingContacts">
                <econdition field-name="infoString" from="respondentEmail" />
                <econdition field-name="contactMechTypeEnumId" value="CmtEmailAddress" />
            </entity-find>

            <if condition="!existingContacts">
                <!-- Create lead user - ignore errors if user creation fails -->
                <service-call name="growerp.100.PartyServices100.create#User" ignore-error="true">
                    <field-map field-name="user"
                        from="[
                        firstName: firstName,
                        lastName: lastName,
                        email: respondentEmail,
                        telephoneNr: respondentPhone,
                        role: 'Lead',
                        userGroupId: 'OTHER'
                    ]" />
                    <field-map field-name="ownerPartyId" from="ownerPartyId" />
                </service-call>
            </if>

            <!-- Generate unique pseudoId for result -->
            <service-call name="growerp.100.GeneralServices100.getNext#PseudoId"
                in-map="[ownerPartyId: ownerPartyId, seqName: 'AssessmentResult']"
                out-map="context" />
            <set field="pseudoId" from="seqNum" />

            <!-- Capture current timestamp -->
            <set field="createdDate" from="ec.user.nowTimestamp" />

            <!-- Create assessment result -->
            <service-call name="create#growerp.assessment.AssessmentResult" out-map="resultOut">
                <field-map field-name="assessmentId" from="assessmentId" />
                <field-map field-name="ownerPartyId" from="ownerPartyId" />
                <field-map field-name="pseudoId" from="pseudoId" />
                <field-map field-name="score" from="score" />
                <field-map field-name="leadStatus" from="leadStatus" />
                <field-map field-name="respondentName" from="respondentName" />
                <field-map field-name="respondentEmail" from="respondentEmail" />
                <field-map field-name="respondentPhone" from="respondentPhone" />
                <field-map field-name="respondentCompany" from="respondentCompany" />
                <field-map field-name="answersData" from="answersData" />
                <field-map field-name="createdDate" from="createdDate" />
            </service-call>

            <!-- Set output parameters - note that assessmentId, score, leadStatus, etc. 
                 are already in context from earlier operations, but we need to ensure
                 all output parameters are explicitly set -->
            <set field="assessmentResultId" from="resultOut.assessmentResultId" />
            <!-- pseudoId, assessmentId, score, leadStatus, respondentName, respondentEmail, 
                 respondentPhone, respondentCompany, answersData, createdDate are already in context -->
        </actions>
    </service>

    <!-- ============================================ -->
    <!-- SCORING SERVICES -->
    <!-- ============================================ -->

    <!-- getThresholds: Get scoring thresholds -->
    <service verb="get" noun="Thresholds" authenticate="true">
        <description>Get scoring thresholds that map scores to lead statuses</description>
        <in-parameters>
            <parameter name="assessmentId" type="String" required="true">
                <description>Assessment ID</description>
            </parameter>
        </in-parameters>
        <out-parameters>
            <parameter name="thresholds" type="List">
                <description>List of thresholds with minScore, maxScore, leadStatus</description>
                <parameter name="thresholdId" />
                <parameter name="pseudoId" />
                <parameter name="assessmentId" />
                <parameter name="minScore" type="BigDecimal" />
                <parameter name="maxScore" type="BigDecimal" />
                <parameter name="leadStatus" />
                <parameter name="description" />
                <parameter name="createdDate" type="Timestamp" />
                <parameter name="createdByUserLogin" />
            </parameter>
        </out-parameters>
        <actions>
            <service-call out-map="context"
                name="growerp.100.GeneralServices100.get#RelatedCompanyAndOwner" />

            <!-- Verify user has access to this assessment -->
            <entity-find entity-name="growerp.assessment.Assessment" list="assessmentList">
                <econdition field-name="assessmentId" from="assessmentId" />
                <econdition field-name="ownerPartyId" from="ownerPartyId" />
            </entity-find>

            <if condition="!assessmentList">
                <return error="true" message="Assessment not found or access denied" />
            </if>

            <!-- Get thresholds for this assessment -->
            <entity-find entity-name="growerp.assessment.ScoringThreshold" list="thresholds">
                <econdition field-name="assessmentId" from="assessmentId" />
                <order-by field-name="minScore" />
            </entity-find>
        </actions>
    </service>

    <!-- updateThresholds: Update or create scoring thresholds -->
    <!-- ============================================ -->
    <!-- THRESHOLD SERVICES -->
    <!-- ============================================ -->

    <!-- getAssessmentThresholds: Get all thresholds for an assessment -->
    <service verb="get" noun="AssessmentThresholds" authenticate="true">
        <description>Get all thresholds for an assessment</description>
        <in-parameters>
            <parameter name="assessmentId" type="String" required="true" />
        </in-parameters>
        <out-parameters>
            <parameter name="thresholds" type="List">
                <description>List of thresholds for the assessment</description>
                <parameter name="thresholdId" />
                <parameter name="pseudoId" />
                <parameter name="assessmentId" />
                <parameter name="minScore" type="BigDecimal" />
                <parameter name="maxScore" type="BigDecimal" />
                <parameter name="leadStatus" />
                <parameter name="description" />
                <parameter name="createdDate" type="Timestamp" />
                <parameter name="createdByUserLogin" />
            </parameter>
        </out-parameters>
        <actions>
            <service-call out-map="context"
                name="growerp.100.GeneralServices100.get#RelatedCompanyAndOwner" />

            <!-- Get thresholds for this assessment -->
            <entity-find entity-name="growerp.assessment.ScoringThreshold" list="thresholds">
                <econdition field-name="assessmentId" from="assessmentId" />
                <order-by field-name="minScore" />
            </entity-find>
        </actions>
    </service>

    <!-- createThreshold: Create new threshold -->
    <service verb="create" noun="Threshold" authenticate="true">
        <description>Create new threshold</description>
        <in-parameters>
            <parameter name="assessmentId" type="String" required="true" />
            <parameter name="minScore" type="BigDecimal" required="true" />
            <parameter name="maxScore" type="BigDecimal" />
            <parameter name="interpretation" type="String" required="true" />
        </in-parameters>
        <out-parameters>
            <parameter name="scoringThresholdId" />
        </out-parameters>
        <actions>
            <service-call out-map="context"
                name="growerp.100.GeneralServices100.get#RelatedCompanyAndOwner" />

            <service-call name="growerp.100.GeneralServices100.getNext#PseudoId"
                in-map="[ownerPartyId: ownerPartyId, seqName: 'ScoringThreshold']"
                out-map="context" />
            <set field="pseudoId" from="seqNum" />

            <service-call name="create#growerp.assessment.ScoringThreshold" out-map="thresholdOut">
                <field-map field-name="assessmentId" from="assessmentId" />
                <field-map field-name="pseudoId" from="pseudoId" />
                <field-map field-name="minScore" from="minScore" />
                <field-map field-name="maxScore" from="maxScore" />
                <field-map field-name="leadStatus" from="interpretation" />
                <field-map field-name="createdDate" from="ec.user.nowTimestamp" />
            </service-call>

            <set field="scoringThresholdId" from="thresholdOut.scoringThresholdId" />
        </actions>
    </service>

    <!-- updateThreshold: Update existing threshold -->
    <service verb="update" noun="Threshold" authenticate="true">
        <description>Update existing threshold</description>
        <in-parameters>
            <parameter name="scoringThresholdId" type="String" required="true" />
            <parameter name="minScore" type="BigDecimal" />
            <parameter name="maxScore" type="BigDecimal" />
            <parameter name="leadStatus" />
        </in-parameters>
        <out-parameters>
            <parameter name="scoringThresholdId" />
        </out-parameters>
        <actions>
            <service-call out-map="context"
                name="growerp.100.GeneralServices100.get#RelatedCompanyAndOwner" />

            <!-- Verify threshold exists -->
            <entity-find entity-name="growerp.assessment.ScoringThreshold" list="thresholdList">
                <econdition field-name="scoringThresholdId" from="scoringThresholdId" />
            </entity-find>

            <if condition="!thresholdList">
                <return error="true" message="Threshold not found" />
            </if>

            <set field="updateMap" from="[scoringThresholdId: scoringThresholdId]" />
            <if condition="minScore">
                <set field="updateMap.minScore" from="minScore" />
            </if>
            <if condition="maxScore">
                <set field="updateMap.maxScore" from="maxScore" />
            </if>
            <if condition="leadStatus">
                <set field="updateMap.leadStatus" from="leadStatus" />
            </if>

            <service-call name="update#growerp.assessment.ScoringThreshold" in-map="updateMap" />
        </actions>
    </service>

    <!-- deleteThreshold: Delete threshold -->
    <service verb="delete" noun="Threshold" authenticate="true">
        <description>Delete threshold</description>
        <in-parameters>
            <parameter name="scoringThresholdId" type="String" required="true" />
        </in-parameters>
        <out-parameters>
            <parameter name="deleted" type="Boolean" />
        </out-parameters>
        <actions>
            <service-call out-map="context"
                name="growerp.100.GeneralServices100.get#RelatedCompanyAndOwner" />

            <!-- Verify threshold exists -->
            <entity-find entity-name="growerp.assessment.ScoringThreshold" list="thresholdList">
                <econdition field-name="scoringThresholdId" from="scoringThresholdId" />
            </entity-find>

            <if condition="!thresholdList">
                <return error="true" message="Threshold not found" />
            </if>

            <!-- Delete the threshold -->
            <entity-delete value-field="thresholdList[0]" />
            <set field="deleted" from="true" />
        </actions>
    </service>

    <!-- updateThresholds: Update scoring thresholds -->
    <service verb="update" noun="Thresholds" authenticate="true">
        <description>Update assessment scoring thresholds</description>
        <in-parameters>
            <parameter name="assessmentId" type="String" required="true" />
            <parameter name="thresholds" type="List" required="true">
                <description>List of thresholds to create or update</description>
                <parameter name="thresholdId" />
                <parameter name="pseudoId" />
                <parameter name="minScore" type="BigDecimal" />
                <parameter name="maxScore" type="BigDecimal" />
                <parameter name="leadStatus" />
                <parameter name="description" />
            </parameter>
        </in-parameters>
        <out-parameters>
            <parameter name="updatedCount" type="Integer" />
        </out-parameters>
        <actions>
            <service-call out-map="context"
                name="growerp.100.GeneralServices100.get#RelatedCompanyAndOwner" />

            <set field="updatedCount" from="0" />
            <iterate list="thresholds" entry="threshold">
                <if condition="threshold.scoringThresholdId">
                    <!-- Update existing threshold -->
                    <service-call name="update#growerp.assessment.ScoringThreshold"
                        in-map="threshold" />
                    <else>
                        <!-- Create new threshold -->
                        <service-call name="growerp.100.GeneralServices100.getNext#PseudoId"
                            in-map="[ownerPartyId: ownerPartyId, seqName: 'ScoringThreshold']"
                            out-map="thresholdIdOut" />
                        <set field="threshold.pseudoId" from="thresholdIdOut.seqNum" />
                        <set field="threshold.assessmentId" from="assessmentId" />
                        <set field="threshold.createdDate" from="ec.user.nowTimestamp" />
                        <service-call name="create#growerp.assessment.ScoringThreshold"
                            in-map="threshold" />
                    </else>
                </if>
                <set field="updatedCount" from="updatedCount + 1" />
            </iterate>
        </actions>
    </service>

    <!-- ============================================ -->
    <!-- QUESTION SERVICES -->
    <!-- ============================================ -->

    <!-- getAssessmentQuestions: Get all questions for an assessment with nested options -->
    <service verb="get" noun="Questions" authenticate="anonymous-all">
        <description>Get all questions for an assessment, with options nested under each question</description>
        <in-parameters>
            <parameter name="assessmentId" type="String" required="true" />
        </in-parameters>
        <out-parameters>
            <parameter name="questions" type="List">
                <description>List of questions with nested options</description>
                <parameter name="assessmentQuestionId" />
                <parameter name="pseudoId" />
                <parameter name="assessmentId" />
                <parameter name="questionSequence" type="Integer" />
                <parameter name="questionType" />
                <parameter name="questionText" />
                <parameter name="questionDescription" />
                <parameter name="isRequired" />
                <parameter name="defaultOption" />
                <parameter name="defaultValue" />
                <parameter name="createdDate" type="Timestamp" />
                <parameter name="createdByUserLogin" />
                <parameter name="options" type="List">
                    <description>List of answer options for this question</description>
                    <parameter name="assessmentQuestionOptionId" />
                    <parameter name="pseudoId" />
                    <parameter name="assessmentQuestionId" />
                    <parameter name="assessmentId" />
                    <parameter name="optionSequence" type="Integer" />
                    <parameter name="optionText" />
                    <parameter name="optionScore" type="BigDecimal" />
                    <parameter name="createdDate" type="Timestamp" />
                </parameter>
            </parameter>
        </out-parameters>
        <actions>
            <log message="=====question and options using QuestionAndOptions view" />
            <service-call out-map="context"
                name="growerp.100.GeneralServices100.get#RelatedCompanyAndOwner" />

            <!-- Verify user has access to this assessment -->
            <entity-find entity-name="growerp.assessment.Assessment" list="assessmentList">
                <econdition field-name="assessmentId" from="assessmentId" />
                <econdition field-name="ownerPartyId" from="ownerPartyId" />
            </entity-find>

            <if condition="!assessmentList">
                <return error="true" message="Assessment not found or access denied" />
            </if>

            <!-- Use QuestionAndOptions view for efficient single-query retrieval -->
            <entity-find entity-name="growerp.assessment.QuestionAndOptions"
                list="questionAndOptionsRows">
                <econdition field-name="assessmentId" from="assessmentId" />
                <order-by field-name="questionSequence" />
                <order-by field-name="optionSequence" />
            </entity-find>

            <!-- Group rows by question and nest options -->
            <script><![CDATA[
                def questionsMap = [:]
                
                questionAndOptionsRows.each { row ->
                    def questionId = row.assessmentQuestionId
                    
                    // Create question entry if not exists
                    if (!questionsMap.containsKey(questionId)) {
                        questionsMap[questionId] = [
                            assessmentQuestionId: row.assessmentQuestionId,
                            pseudoId: row.pseudoId,
                            assessmentId: row.assessmentId,
                            questionSequence: row.questionSequence,
                            questionType: row.questionType,
                            questionText: row.questionText,
                            questionDescription: row.questionDescription,
                            isRequired: row.isRequired,
                            defaultOption: row.defaultOption,
                            defaultValue: row.defaultValue,
                            createdDate: row.createdDate,
                            createdByUserLogin: row.createdByUserLogin,
                            options: []
                        ]
                    }
                    
                    // Add option if present (LEFT JOIN may have null options)
                    if (row.optionId) {
                        questionsMap[questionId].options.add([
                            assessmentQuestionOptionId: row.optionId,
                            pseudoId: row.optionPseudoId,
                            assessmentQuestionId: row.assessmentQuestionId,
                            assessmentId: row.assessmentId,
                            optionSequence: row.optionSequence,
                            optionText: row.optionText,
                            optionScore: row.optionScore,
                            createdDate: row.optionCreatedDate
                        ])
                    }
                }
                
                // Convert to sorted list
                questions = questionsMap.values().sort { it.questionSequence }
            ]]></script>
        </actions>
    </service>

    <!-- getQuestion: Get question details -->
    <service verb="get" noun="Question" authenticate="false">
        <description>Get question by ID or list all questions for an assessment. When questionId provided, returns single question. When not provided, returns list of all questions for the assessment. Public endpoint - accessible without authentication.</description>
        <in-parameters>
            <parameter name="assessmentId" type="String" required="true">
                <description>Assessment ID - required for list context</description>
            </parameter>
            <parameter name="questionId">
                <description>Question ID - optional, when provided returns single question</description>
            </parameter>
            <parameter name="start" type="Integer" default="0">
                <description>Start index for pagination (used in list mode)</description>
            </parameter>
            <parameter name="limit" type="Integer" default="100">
                <description>Maximum number of results (used in list mode)</description>
            </parameter>
        </in-parameters>
        <out-parameters>
            <parameter name="question" type="Map">
                <description>Single question object (when questionId provided)</description>
                <parameter name="questionId" />
                <parameter name="pseudoId" />
                <parameter name="assessmentId" />
                <parameter name="questionSequence" type="Integer" />
                <parameter name="questionType" />
                <parameter name="questionText" />
                <parameter name="questionDescription" />
                <parameter name="isRequired" />
                <parameter name="defaultOption" />
                <parameter name="defaultValue" />
                <parameter name="createdDate" type="Timestamp" />
                <parameter name="createdByUserLogin" />
            </parameter>
            <parameter name="questions" type="List">
                <description>List of questions (when no questionId provided)</description>
                <parameter name="questionId" />
                <parameter name="pseudoId" />
                <parameter name="assessmentId" />
                <parameter name="questionSequence" type="Integer" />
                <parameter name="questionType" />
                <parameter name="questionText" />
                <parameter name="questionDescription" />
                <parameter name="isRequired" />
                <parameter name="defaultOption" />
                <parameter name="defaultValue" />
                <parameter name="createdDate" type="Timestamp" />
                <parameter name="createdByUserLogin" />
            </parameter>
            <parameter name="questionCount" type="Long">
                <description>Total count of questions for this assessment</description>
            </parameter>
        </out-parameters>
        <actions>
            <!-- Check if this is a single question request or list request -->
            <if condition="questionId">
                <!-- SINGLE QUESTION RETRIEVAL -->
                <entity-find-one entity-name="growerp.assessment.AssessmentQuestion"
                    value-field="question">
                    <field-map field-name="questionId" from="questionId" />
                    <field-map field-name="assessmentId" from="assessmentId" />
                </entity-find-one>

                <if condition="!question">
                    <return error="true" message="Question not found" />
                </if>

                <else>
                    <!-- LIST QUESTIONS FOR ASSESSMENT -->
                    <entity-find entity-name="growerp.assessment.AssessmentQuestion"
                        list="questions"
                        limit="limit" offset="start">
                        <econdition field-name="assessmentId" from="assessmentId" />
                        <order-by field-name="questionSequence" />
                    </entity-find>

                    <entity-find-count entity-name="growerp.assessment.AssessmentQuestion"
                        count-field="questionCount">
                        <econdition field-name="assessmentId" from="assessmentId" />
                    </entity-find-count>
                </else>
            </if>
        </actions>
    </service>

    <!-- createQuestion: Create new question -->
    <service verb="create" noun="Question" authenticate="true">
        <description>Create new question</description>
        <in-parameters>
            <parameter name="assessmentId" type="String" required="true" />
            <parameter name="questionText" type="String" required="true">
                <description>Question Text</description>
            </parameter>
            <parameter name="questionType" type="String" default-value="MULTIPLE_CHOICE" />
            <parameter name="questionSequence" type="Integer" />
            <parameter name="isRequired" type="String" default-value="Y" />
        </in-parameters>
        <out-parameters>
            <parameter name="questionId" />
        </out-parameters>
        <actions>
            <!-- Validate required fields -->
            <if condition="!questionText || questionText.trim().isEmpty()">
                <return error="true" message="Question text is required and cannot be empty" />
            </if>

            <service-call out-map="context"
                name="growerp.100.GeneralServices100.get#RelatedCompanyAndOwner" />

            <service-call name="growerp.100.GeneralServices100.getNext#PseudoId"
                in-map="[ownerPartyId: ownerPartyId, seqName: 'AssessmentQuestion']"
                out-map="context" />
            <set field="pseudoId" from="seqNum" />
            <set field="questionId" from="seqNum" />

            <service-call name="create#growerp.assessment.AssessmentQuestion" out-map="questionOut">
                <field-map field-name="questionId" from="questionId" />
                <field-map field-name="assessmentId" from="assessmentId" />
                <field-map field-name="pseudoId" from="pseudoId" />
                <field-map field-name="questionText" from="questionText" />
                <field-map field-name="questionType" from="questionType" />
                <field-map field-name="questionSequence" from="questionSequence" />
                <field-map field-name="isRequired" from="isRequired" />
                <field-map field-name="createdDate" from="ec.user.nowTimestamp" />
                <field-map field-name="createdByUserLogin" from="ec.user.username" />
            </service-call>

            <set field="questionId" from="questionOut.questionId" />
        </actions>
    </service>

    <!-- updateQuestion: Update existing question -->
    <service verb="update" noun="Question" authenticate="true">
        <description>Update existing question</description>
        <in-parameters>
            <parameter name="assessmentId" type="String" required="true" />
            <parameter name="questionId" type="String" required="true" />
            <parameter name="questionText" />
            <parameter name="questionType" />
            <parameter name="questionSequence" type="Integer" />
            <parameter name="isRequired" />
        </in-parameters>
        <out-parameters>
            <parameter name="questionId" />
        </out-parameters>
        <actions>
            <service-call out-map="context"
                name="growerp.100.GeneralServices100.get#RelatedCompanyAndOwner" />

            <!-- Verify question exists and user has access -->
            <entity-find entity-name="growerp.assessment.AssessmentQuestion" list="questionList">
                <econdition field-name="questionId" from="questionId" />
                <econdition field-name="assessmentId" from="assessmentId" />
            </entity-find>

            <if condition="!questionList">
                <return error="true" message="Question not found" />
            </if>

            <set field="updateMap" from="[questionId: questionId, assessmentId: assessmentId]" />
            <if condition="questionText">
                <set field="updateMap.questionText" from="questionText" />
            </if>
            <if condition="questionType">
                <set field="updateMap.questionType" from="questionType" />
            </if>
            <if condition="questionSequence">
                <set field="updateMap.questionSequence" from="questionSequence" />
            </if>
            <if condition="isRequired">
                <set field="updateMap.isRequired" from="isRequired" />
            </if>

            <service-call name="update#growerp.assessment.AssessmentQuestion" in-map="updateMap" />
        </actions>
    </service>

    <!-- deleteQuestion: Delete question and its options -->
    <service verb="delete" noun="Question" authenticate="true">
        <description>Delete question and all its options</description>
        <in-parameters>
            <parameter name="assessmentId" type="String" required="true" />
            <parameter name="questionId" type="String" required="true" />
        </in-parameters>
        <out-parameters>
            <parameter name="deletedCount" type="Integer" />
        </out-parameters>
        <actions>
            <service-call out-map="context"
                name="growerp.100.GeneralServices100.get#RelatedCompanyAndOwner" />

            <!-- Verify question exists -->
            <entity-find entity-name="growerp.assessment.AssessmentQuestion" list="questionList">
                <econdition field-name="questionId" from="questionId" />
                <econdition field-name="assessmentId" from="assessmentId" />
            </entity-find>

            <if condition="!questionList">
                <return error="true" message="Question not found" />
            </if>

            <set field="deletedCount" from="0" />

            <!-- Delete question options first -->
            <entity-find entity-name="growerp.assessment.AssessmentQuestionOption" list="optionList">
                <econdition field-name="questionId" from="questionId" />
                <econdition field-name="assessmentId" from="assessmentId" />
            </entity-find>
            <iterate list="optionList" entry="option">
                <entity-delete value-field="option" />
                <set field="deletedCount" from="deletedCount + 1" />
            </iterate>

            <!-- Delete the question -->
            <entity-delete value-field="questionList[0]" />
            <set field="deletedCount" from="deletedCount + 1" />
        </actions>
    </service>

    <!-- ============================================ -->
    <!-- OPTION SERVICES -->
    <!-- ============================================ -->

    <!-- getAssessmentQuestionOptions: Get all options for a question -->
    <service verb="get" noun="AssessmentQuestionOptions" authenticate="true">
        <description>Get all options for a question</description>
        <in-parameters>
            <parameter name="assessmentId" type="String" required="true" />
            <parameter name="questionId" type="String" required="true" />
        </in-parameters>
        <out-parameters>
            <parameter name="options" type="List">
                <description>List of options for the question</description>
                <parameter name="optionId" />
                <parameter name="pseudoId" />
                <parameter name="questionId" />
                <parameter name="assessmentId" />
                <parameter name="optionSequence" type="Integer" />
                <parameter name="optionText" />
                <parameter name="optionScore" type="BigDecimal" />
                <parameter name="createdDate" type="Timestamp" />
            </parameter>
        </out-parameters>
        <actions>
            <service-call out-map="context"
                name="growerp.100.GeneralServices100.get#RelatedCompanyAndOwner" />

            <!-- Get options for this question -->
            <entity-find entity-name="growerp.assessment.AssessmentQuestionOption" list="options">
                <econdition field-name="questionId" from="questionId" />
                <econdition field-name="assessmentId" from="assessmentId" />
                <order-by field-name="optionSequence" />
            </entity-find>
        </actions>
    </service>

    <!-- getOption: Get option details -->
    <service verb="get" noun="Option" authenticate="false">
        <description>Get option by ID or list all options for a question. When optionId provided, returns single option. When not provided, returns list of all options for the question. Public endpoint - accessible without authentication.</description>
        <in-parameters>
            <parameter name="assessmentId" type="String" required="true">
                <description>Assessment ID - required for context</description>
            </parameter>
            <parameter name="questionId" type="String" required="true">
                <description>Question ID - required for context</description>
            </parameter>
            <parameter name="optionId">
                <description>Option ID - optional, when provided returns single option</description>
            </parameter>
            <parameter name="start" type="Integer" default="0">
                <description>Start index for pagination (used in list mode)</description>
            </parameter>
            <parameter name="limit" type="Integer" default="100">
                <description>Maximum number of results (used in list mode)</description>
            </parameter>
        </in-parameters>
        <out-parameters>
            <parameter name="option" type="Map">
                <description>Single option object (when optionId provided)</description>
                <parameter name="optionId" />
                <parameter name="pseudoId" />
                <parameter name="questionId" />
                <parameter name="assessmentId" />
                <parameter name="optionSequence" type="Integer" />
                <parameter name="optionText" />
                <parameter name="optionScore" type="BigDecimal" />
                <parameter name="createdDate" type="Timestamp" />
            </parameter>
            <parameter name="options" type="List">
                <description>List of options (when no optionId provided)</description>
                <parameter name="optionId" />
                <parameter name="pseudoId" />
                <parameter name="questionId" />
                <parameter name="assessmentId" />
                <parameter name="optionSequence" type="Integer" />
                <parameter name="optionText" />
                <parameter name="optionScore" type="BigDecimal" />
                <parameter name="createdDate" type="Timestamp" />
            </parameter>
            <parameter name="optionCount" type="Long">
                <description>Total count of options for this question</description>
            </parameter>
        </out-parameters>
        <actions>
            <!-- Check if this is a single option request or list request -->
            <if condition="optionId">
                <!-- SINGLE OPTION RETRIEVAL -->
                <entity-find-one entity-name="growerp.assessment.AssessmentQuestionOption"
                    value-field="option">
                    <field-map field-name="optionId" from="optionId" />
                    <field-map field-name="questionId" from="questionId" />
                    <field-map field-name="assessmentId" from="assessmentId" />
                </entity-find-one>

                <if condition="!option">
                    <return error="true" message="Option not found" />
                </if>

                <else>
                    <!-- LIST OPTIONS FOR QUESTION -->
                    <entity-find entity-name="growerp.assessment.AssessmentQuestionOption"
                        list="options"
                        limit="limit" offset="start">
                        <econdition field-name="questionId" from="questionId" />
                        <econdition field-name="assessmentId" from="assessmentId" />
                        <order-by field-name="optionSequence" />
                    </entity-find>

                    <entity-find-count entity-name="growerp.assessment.AssessmentQuestionOption"
                        count-field="optionCount">
                        <econdition field-name="questionId" from="questionId" />
                        <econdition field-name="assessmentId" from="assessmentId" />
                    </entity-find-count>
                </else>
            </if>
        </actions>
    </service>

    <!-- createOption: Create new option -->
    <service verb="create" noun="Option" authenticate="true">
        <description>Create new option</description>
        <in-parameters>
            <parameter name="assessmentId" type="String" required="true" />
            <parameter name="questionId" type="String" required="true" />
            <parameter name="optionText" type="String" required="true" />
            <parameter name="optionScore" type="BigDecimal" required="true" />
            <parameter name="optionSequence" type="Integer" />
        </in-parameters>
        <out-parameters>
            <parameter name="optionId" />
        </out-parameters>
        <actions>
            <service-call out-map="context"
                name="growerp.100.GeneralServices100.get#RelatedCompanyAndOwner" />

            <service-call name="growerp.100.GeneralServices100.getNext#PseudoId"
                in-map="[ownerPartyId: ownerPartyId, seqName: 'AssessmentQuestionOption']"
                out-map="context" />
            <set field="pseudoId" from="seqNum" />
            <set field="optionId" from="seqNum" />

            <service-call name="create#growerp.assessment.AssessmentQuestionOption"
                out-map="optionOut">
                <field-map field-name="optionId" from="optionId" />
                <field-map field-name="assessmentId" from="assessmentId" />
                <field-map field-name="questionId" from="questionId" />
                <field-map field-name="pseudoId" from="pseudoId" />
                <field-map field-name="optionText" from="optionText" />
                <field-map field-name="optionScore" from="optionScore" />
                <field-map field-name="optionSequence" from="optionSequence" />
                <field-map field-name="createdDate" from="ec.user.nowTimestamp" />
            </service-call>

            <set field="optionId" from="optionOut.optionId" />
        </actions>
    </service>

    <!-- updateOption: Update existing option -->
    <service verb="update" noun="Option" authenticate="true">
        <description>Update existing option</description>
        <in-parameters>
            <parameter name="assessmentId" type="String" required="true" />
            <parameter name="questionId" type="String" required="true" />
            <parameter name="optionId" type="String" required="true" />
            <parameter name="optionText" />
            <parameter name="optionScore" type="BigDecimal" />
            <parameter name="optionSequence" type="Integer" />
        </in-parameters>
        <out-parameters>
            <parameter name="optionId" />
        </out-parameters>
        <actions>
            <service-call out-map="context"
                name="growerp.100.GeneralServices100.get#RelatedCompanyAndOwner" />

            <!-- Verify option exists -->
            <entity-find entity-name="growerp.assessment.AssessmentQuestionOption" list="optionList">
                <econdition field-name="optionId" from="optionId" />
                <econdition field-name="questionId" from="questionId" />
                <econdition field-name="assessmentId" from="assessmentId" />
            </entity-find>

            <if condition="!optionList">
                <return error="true" message="Option not found" />
            </if>

            <set field="updateMap"
                from="[optionId: optionId, questionId: questionId, assessmentId: assessmentId]" />
            <if condition="optionText">
                <set field="updateMap.optionText" from="optionText" />
            </if>
            <if condition="optionScore">
                <set field="updateMap.optionScore" from="optionScore" />
            </if>
            <if condition="optionSequence">
                <set field="updateMap.optionSequence" from="optionSequence" />
            </if>

            <service-call name="update#growerp.assessment.AssessmentQuestionOption"
                in-map="updateMap" />
        </actions>
    </service>

    <!-- deleteOption: Delete option -->
    <service verb="delete" noun="Option" authenticate="true">
        <description>Delete option</description>
        <in-parameters>
            <parameter name="assessmentId" type="String" required="true" />
            <parameter name="questionId" type="String" required="true" />
            <parameter name="optionId" type="String" required="true" />
        </in-parameters>
        <out-parameters>
            <parameter name="deleted" type="Boolean" />
        </out-parameters>
        <actions>
            <service-call out-map="context"
                name="growerp.100.GeneralServices100.get#RelatedCompanyAndOwner" />

            <!-- Verify option exists -->
            <entity-find entity-name="growerp.assessment.AssessmentQuestionOption" list="optionList">
                <econdition field-name="optionId" from="optionId" />
                <econdition field-name="questionId" from="questionId" />
                <econdition field-name="assessmentId" from="assessmentId" />
            </entity-find>

            <if condition="!optionList">
                <return error="true" message="Option not found" />
            </if>

            <!-- Delete the option -->
            <entity-delete value-field="optionList[0]" />
            <set field="deleted" from="true" />
        </actions>
    </service>

    <!-- ============================================ -->
    <!-- RESULT SERVICES -->
    <!-- ============================================ -->

    <!-- getResult: Get assessment result -->
    <service verb="get" noun="Result" authenticate="false">
        <description>Get assessment result (allows anonymous users)</description>
        <in-parameters>
            <parameter name="assessmentId" type="String" required="true" />
            <parameter name="resultId" type="String" required="true" />
        </in-parameters>
        <out-parameters>
            <parameter name="result" type="Map">
                <description>Assessment result object</description>
                <parameter name="resultId" />
                <parameter name="pseudoId" />
                <parameter name="assessmentId" />
                <parameter name="score" type="BigDecimal" />
                <parameter name="leadStatus" />
                <parameter name="respondentName" />
                <parameter name="respondentEmail" />
                <parameter name="respondentPhone" />
                <parameter name="respondentCompany" />
                <parameter name="answersData" />
                <parameter name="createdDate" type="Timestamp" />
            </parameter>
        </out-parameters>
        <actions>
            <!-- Don't require owner lookup for anonymous result retrieval -->
            <entity-find-one entity-name="growerp.assessment.AssessmentResult" value-field="result">
                <field-map field-name="resultId" from="resultId" />
                <field-map field-name="assessmentId" from="assessmentId" />
            </entity-find-one>
        </actions>
    </service>

    <!-- createResult: Create assessment result -->
    <!-- ============================================ -->
    <!-- RESULT SERVICES -->
    <!-- ============================================ -->

    <!-- getAssessmentResults: Get all results (leads) for an assessment with their total scores -->
    <service verb="get" noun="AssessmentResults" authenticate="true">
        <description>Get all leads (assessment respondents) for an assessment with their total scores. Returns list of leads with overall score and status, not individual question results.</description>
        <in-parameters>
            <parameter name="assessmentId" type="String" required="true">
                <description>Assessment ID to fetch results for</description>
            </parameter>
            <parameter name="start" type="Integer" default="0">
                <description>Start index for pagination</description>
            </parameter>
            <parameter name="limit" type="Integer" default="50">
                <description>Maximum number of results per page</description>
            </parameter>
        </in-parameters>
        <out-parameters>
            <parameter name="results" type="List">
                <description>List of leads with their assessment results (total score and status)</description>
                <parameter name="assessmentResultId" />
                <parameter name="pseudoId">
                    <description>Unique result ID within tenant</description>
                </parameter>
                <parameter name="respondentName">
                    <description>Lead name</description>
                </parameter>
                <parameter name="respondentEmail">
                    <description>Lead email</description>
                </parameter>
                <parameter name="respondentPhone">
                    <description>Lead phone number</description>
                </parameter>
                <parameter name="respondentCompany">
                    <description>Lead company</description>
                </parameter>
                <parameter name="score" type="BigDecimal">
                    <description>Total assessment score (0-100)</description>
                </parameter>
                <parameter name="leadStatus">
                    <description>Lead qualification status (e.g., Cold, Warm, Hot)</description>
                </parameter>
                <parameter name="answersData" type="List">
                    <description>List of answers with question and option text enriched</description>
                    <parameter name="questionId" />
                    <parameter name="questionText" />
                    <parameter name="questionSequence" type="Integer" />
                    <parameter name="optionId" />
                    <parameter name="optionText" />
                    <parameter name="optionScore" type="BigDecimal" />
                </parameter>
                <parameter name="createdDate" type="Timestamp">
                    <description>When the assessment was submitted</description>
                </parameter>
            </parameter>
        </out-parameters>
        <actions>
            <service-call out-map="context"
                name="growerp.100.GeneralServices100.get#RelatedCompanyAndOwner" />

            <!-- Get results for this assessment with pagination -->
            <entity-find entity-name="growerp.assessment.AssessmentResult" list="rawResults"
                limit="limit" offset="start">
                <econdition field-name="assessmentId" from="assessmentId" />
                <econdition field-name="ownerPartyId" from="ownerPartyId" />
                <select-field field-name="assessmentResultId" />
                <select-field field-name="pseudoId" />
                <select-field field-name="respondentName" />
                <select-field field-name="respondentEmail" />
                <select-field field-name="respondentPhone" />
                <select-field field-name="respondentCompany" />
                <select-field field-name="score" />
                <select-field field-name="leadStatus" />
                <select-field field-name="answersData" />
                <select-field field-name="createdDate" />
                <order-by field-name="-createdDate" />
            </entity-find>

            <!-- Process each result to enrich answersData with question and option text -->
            <set field="results" from="[]" />
            <iterate list="rawResults" entry="result">
                <set field="enrichedResult"
                    from="[
                    assessmentResultId: result.assessmentResultId,
                    pseudoId: result.pseudoId,
                    respondentName: result.respondentName,
                    respondentEmail: result.respondentEmail,
                    respondentPhone: result.respondentPhone,
                    respondentCompany: result.respondentCompany,
                    score: result.score,
                    leadStatus: result.leadStatus,
                    createdDate: result.createdDate
                ]" />

                <!-- Decode and enrich answersData -->
                <if condition="result.answersData">
                    <script><![CDATA[
                        def slurper = new groovy.json.JsonSlurper()
                        def answersMap = slurper.parseText(result.answersData)
                        def enrichedAnswers = []
                        
                        answersMap.each { questionId, optionId ->
                            // Get question details
                            def question = ec.entity.find("growerp.assessment.AssessmentQuestion")
                                .condition("assessmentQuestionId", questionId)
                                .one()
                            
                            // Get option details
                            def option = ec.entity.find("growerp.assessment.AssessmentQuestionOption")
                                .condition("assessmentQuestionOptionId", optionId)
                                .one()
                            
                            enrichedAnswers.add([
                                questionId: questionId,
                                questionText: question?.questionText ?: "Question ${questionId}",
                                questionSequence: question?.questionSequence ?: 0,
                                optionId: optionId,
                                optionText: option?.optionText ?: optionId,
                                optionScore: option?.optionScore ?: 0
                            ])
                        }
                        
                        // Sort by question sequence
                        enrichedAnswers.sort { it.questionSequence }
                        
                        enrichedResult.answersData = enrichedAnswers
                    ]]></script>
                    <else>
                        <set field="enrichedResult.answersData" from="[]" />
                    </else>
                </if>

                <script>results.add(enrichedResult)</script>
            </iterate>
        </actions>
    </service>

    <!-- getAllAssessmentResults: Get all assessment results across all assessments -->
    <service verb="get" noun="AllAssessmentResults" authenticate="true">
        <description>Get all assessment results across all assessments</description>
        <in-parameters>
            <parameter name="start" type="Integer" default="0" />
            <parameter name="limit" type="Integer" default="20" />
        </in-parameters>
        <out-parameters>
            <parameter name="results" type="List">
                <description>List of all assessment results</description>
                <parameter name="resultId" />
                <parameter name="pseudoId" />
                <parameter name="assessmentId" />
                <parameter name="score" type="BigDecimal" />
                <parameter name="leadStatus" />
                <parameter name="respondentName" />
                <parameter name="respondentEmail" />
                <parameter name="respondentPhone" />
                <parameter name="respondentCompany" />
                <parameter name="answersData" />
                <parameter name="createdDate" type="Timestamp" />
            </parameter>
            <parameter name="resultCount" type="Integer" />
        </out-parameters>
        <actions>
            <service-call out-map="context"
                name="growerp.100.GeneralServices100.get#RelatedCompanyAndOwner" />

            <!-- Get results -->
            <entity-find entity-name="growerp.assessment.AssessmentResult" list="results"
                offset="start" limit="limit">
                <econdition field-name="ownerPartyId" from="ownerPartyId" />
                <order-by field-name="-createdDate" />
            </entity-find>

            <!-- Enrich results with assessment details -->
            <iterate list="results" entry="result">
                <entity-find-one entity-name="growerp.assessment.Assessment"
                    value-field="assessment">
                    <field-map field-name="assessmentId" from="result.assessmentId" />
                </entity-find-one>
                <if condition="assessment">
                    <set field="result.assessmentName" from="assessment.assessmentName" />
                    <set field="result.assessmentDescription" from="assessment.description" />
                </if>
            </iterate>

            <!-- Set result count for compatibility -->
            <set field="resultCount" from="results.size()" />
        </actions>
    </service>

    <!-- getAllAssessmentResults: Get all assessment results across all assessments -->
    <service verb="get" noun="AllAssessmentResults" authenticate="true">
        <description>Get all assessment results across all assessments. Requires authentication.</description>
        <in-parameters>
            <parameter name="start" type="Integer" default="0">
                <description>Start index for pagination</description>
            </parameter>
            <parameter name="limit" type="Integer" default="100">
                <description>Maximum number of results</description>
            </parameter>
            <parameter name="status">
                <description>Optional filter by status</description>
            </parameter>
        </in-parameters>
        <out-parameters>
            <parameter name="assessmentResults" type="List">
                <description>List of all assessment results</description>
                <parameter name="resultId" />
                <parameter name="pseudoId" />
                <parameter name="assessmentId" />
                <parameter name="score" type="BigDecimal" />
                <parameter name="leadStatus" />
                <parameter name="respondentName" />
                <parameter name="respondentEmail" />
                <parameter name="respondentPhone" />
                <parameter name="respondentCompany" />
                <parameter name="answersData" />
                <parameter name="createdDate" type="Timestamp" />
            </parameter>
            <parameter name="assessmentResultCount" type="Long">
                <description>Total count of all results</description>
            </parameter>
        </out-parameters>
        <actions>
            <!-- Verify user is authenticated -->
            <service-call out-map="context"
                name="growerp.100.GeneralServices100.get#RelatedCompanyAndOwner" />
            <if condition="!ownerPartyId">
                <return error="true" message="User not authenticated or no party associated" />
            </if>

            <!-- Get all results for user's company -->
            <entity-find entity-name="growerp.assessment.AssessmentResult" list="assessmentResults"
                limit="limit" offset="start">
                <econdition field-name="ownerPartyId" from="ownerPartyId" />
                <order-by field-name="-createdDate" />
            </entity-find>
            <entity-find-count entity-name="growerp.assessment.AssessmentResult"
                count-field="assessmentResultCount">
                <econdition field-name="ownerPartyId" from="ownerPartyId" />
            </entity-find-count>
        </actions>
    </service>

</services>