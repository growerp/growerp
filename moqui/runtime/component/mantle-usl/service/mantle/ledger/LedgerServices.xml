<?xml version="1.0" encoding="UTF-8"?>
<!--
This software is in the public domain under CC0 1.0 Universal plus a 
Grant of Patent License.

To the extent possible under law, the author(s) have dedicated all
copyright and related and neighboring rights to this software to the
public domain worldwide. This software is distributed without any
warranty.

You should have received a copy of the CC0 Public Domain Dedication
along with this software (see the LICENSE.md file). If not, see
<http://creativecommons.org/publicdomain/zero/1.0/>.
-->
<services xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://moqui.org/xsd/service-definition-3.xsd">

    <service verb="create" noun="GlAccount" type="entity-auto">
        <in-parameters>
            <auto-parameters entity-name="mantle.ledger.account.GlAccount"/>
            <parameter name="glAccountId" default="accountCode"/>
            <parameter name="accountCode" required="true"><matches regexp="\d*" message="Enter digits only, masking is added on display"/></parameter>
            <parameter name="accountName" required="true"/>
            <parameter name="glAccountClassEnumId" required="true"/>
            <parameter name="glResourceTypeEnumId" default-value="GlrtMoney"/>
        </in-parameters>
        <out-parameters><parameter name="glAccountId"/></out-parameters>
    </service>

    <service verb="init" noun="PartyAccountingConfiguration">
        <in-parameters>
            <parameter name="sourcePartyId" required="true"/>
            <parameter name="organizationPartyId" required="true"/>
            <auto-parameters entity-name="mantle.ledger.config.PartyAcctgPreference" include="nonpk"/>
            <parameter name="startYear" format="0000"><description>If specified creates fiscal time periods (year, quarter, month) starting that
                year and through the following year, otherwise starts now and creates current and next year, quarter, and month</description></parameter>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="mantle.ledger.config.PartyAcctgPreference" value-field="existingPartyAcctgPreference">
                <field-map field-name="organizationPartyId"/>
            </entity-find-one>
            <if condition="existingPartyAcctgPreference">
                <return message="Party [${organizationPartyId}] already has a PartyAcctgPreference record, so not initializing accounting configuration."/>
            </if>

            <!-- create an error Journal mantle.ledger.transaction.GlJournal -->
            <entity-find-one entity-name="mantle.party.Organization" value-field="organization">
                <field-map field-name="partyId" from="organizationPartyId"/></entity-find-one>
            <set field="errorGlJournalId" value="${organizationPartyId}Error"/>
            <service-call name="create#mantle.ledger.transaction.GlJournal"
                    in-map="[organizationPartyId:organizationPartyId, glJournalId:errorGlJournalId,
                        glJournalTypeEnumId:'GLJRNL_ERROR', isPosted:'N',
                        glJournalName:('Error Journal for ' + (organization?.organizationName ?: organizationPartyId))]"/>

            <!-- copy the mantle.ledger.config.PartyAcctgPreference -->
            <entity-find-one entity-name="mantle.ledger.config.PartyAcctgPreference" value-field="sourcePartyAcctgPreference">
                <field-map field-name="organizationPartyId" from="sourcePartyId"/>
            </entity-find-one>
            <if condition="!sourcePartyAcctgPreference"><return error="true" message="Could not find PartyAcctgPreference for source party [${sourcePartyId}]"/></if>
            <set field="partyAcctgPreference" from="sourcePartyAcctgPreference.cloneValue()"/>
            <entity-set value-field="partyAcctgPreference" include="nonpk" set-if-empty="false"/>
            <service-call name="create#mantle.ledger.config.PartyAcctgPreference"
                    in-map="partyAcctgPreference + [organizationPartyId:organizationPartyId, errorGlJournalId:errorGlJournalId]"/>

            <!-- copy mantle.ledger.account.GlAccountOrganization -->
            <entity-find entity-name="mantle.ledger.account.GlAccountOrganization" list="recordList">
                <econdition field-name="organizationPartyId" from="sourcePartyId"/></entity-find>
            <iterate list="recordList" entry="record"><set field="record.organizationPartyId" from="organizationPartyId"/>
                <entity-create value-field="record"/></iterate>

            <!-- copy mantle.ledger.config.AssetTypeGlAccount -->
            <entity-find entity-name="mantle.ledger.config.AssetTypeGlAccount" list="recordList">
                <econdition field-name="organizationPartyId" from="sourcePartyId"/></entity-find>
            <iterate list="recordList" entry="record">
                <set field="record.organizationPartyId" from="organizationPartyId"/>
                <set field="record.assetTypeGlAccountId" from="null"/>
                <entity-sequenced-id-primary value-field="record"/>
                <entity-create value-field="record"/>
            </iterate>

            <!-- copy mantle.ledger.config.GlAccountTypeDefault -->
            <entity-find entity-name="mantle.ledger.config.GlAccountTypeDefault" list="recordList">
                <econdition field-name="organizationPartyId" from="sourcePartyId"/></entity-find>
            <iterate list="recordList" entry="record"><set field="record.organizationPartyId" from="organizationPartyId"/>
                <entity-create value-field="record"/></iterate>

            <!-- copy mantle.ledger.config.InvoiceTypeTransType -->
            <entity-find entity-name="mantle.ledger.config.InvoiceTypeTransType" list="recordList">
                <econdition field-name="organizationPartyId" from="sourcePartyId"/></entity-find>
            <iterate list="recordList" entry="record"><set field="record.organizationPartyId" from="organizationPartyId"/>
                <entity-create value-field="record"/></iterate>

            <!-- copy mantle.ledger.config.ItemTypeGlAccount -->
            <entity-find entity-name="mantle.ledger.config.ItemTypeGlAccount" list="recordList">
                <econdition field-name="organizationPartyId" from="sourcePartyId"/></entity-find>
            <iterate list="recordList" entry="record"><set field="record.organizationPartyId" from="organizationPartyId"/>
                <entity-create value-field="record"/></iterate>

            <!-- copy mantle.ledger.config.PaymentTypeGlAccount -->
            <entity-find entity-name="mantle.ledger.config.PaymentTypeGlAccount" list="recordList">
                <econdition field-name="organizationPartyId" from="sourcePartyId"/></entity-find>
            <iterate list="recordList" entry="record"><set field="record.organizationPartyId" from="organizationPartyId"/>
                <entity-create value-field="record"/></iterate>

            <!-- copy mantle.ledger.config.PaymentInstrumentGlAccount -->
            <entity-find entity-name="mantle.ledger.config.PaymentInstrumentGlAccount" list="recordList">
                <econdition field-name="organizationPartyId" from="sourcePartyId"/></entity-find>
            <iterate list="recordList" entry="record"><set field="record.organizationPartyId" from="organizationPartyId"/>
                <entity-create value-field="record"/></iterate>

            <!-- copy mantle.ledger.config.FinancialAccountTypeGlAccount -->
            <entity-find entity-name="mantle.ledger.config.FinancialAccountTypeGlAccount" list="recordList">
                <econdition field-name="organizationPartyId" from="sourcePartyId"/></entity-find>
            <iterate list="recordList" entry="record"><set field="record.organizationPartyId" from="organizationPartyId"/>
                <entity-create value-field="record"/></iterate>
            <!-- copy mantle.ledger.config.FinancialAccountReasonGlAccount -->
            <entity-find entity-name="mantle.ledger.config.FinancialAccountReasonGlAccount" list="recordList">
                <econdition field-name="organizationPartyId" from="sourcePartyId"/></entity-find>
            <iterate list="recordList" entry="record"><set field="record.organizationPartyId" from="organizationPartyId"/>
                <entity-create value-field="record"/></iterate>

            <!-- TODO: CreditCardTypeGlAccount, GlAccountTypePartyDefault, ProductCategoryGlAccount, ProductGlAccount, TaxAuthorityGlAccount, VarianceReasonGlAccount -->

            <!-- setup mantle.party.time.TimePeriod for FiscalMonth, FiscalQuarter, FiscalYear -->
            <if condition="startYear"><then>
                <set field="nextYearInt" from="((Calendar) ec.user.nowCalendar).get(Calendar.YEAR) + 1"/>
                <set field="lastYear" from="ec.l10n.format(nextYearInt, '0000')"/>

                <set field="curYear" from="startYear"/>
                <set field="prevPeriodId" from="null"/>
                <while condition="curYear &lt;= lastYear">
                    <set field="fromDate" from="ec.l10n.parseDate(curYear + '-01-01', 'yyyy-MM-dd')"/>
                    <service-call name="mantle.party.TimeServices.getOrCreate#TimePeriod" out-map="curYearOut"
                            in-map="[partyId:organizationPartyId, timePeriodTypeId:'FiscalYear', fromDate:fromDate, previousPeriodId:prevPeriodId]"/>
                    <service-call name="mantle.party.TimeServices.get#DescendantPeriods" out-map="quartersOut"
                            in-map="[parentPeriodId:curYearOut.timePeriodId, timePeriodTypeId:'FiscalQuarter', createMissing:true]"/>
                    <iterate list="quartersOut.timePeriodList" entry="quarterPeriod">
                        <service-call name="mantle.party.TimeServices.get#DescendantPeriods" out-map="quartersOut"
                                in-map="[parentPeriodId:quarterPeriod.timePeriodId, timePeriodTypeId:'FiscalMonth', createMissing:true]"/>
                    </iterate>

                    <set field="prevPeriodId" from="curYearOut.timePeriodId"/>
                    <set field="curYear" from="((curYear as int) + 1) as String"/>
                </while>
            </then><else>
                <service-call name="mantle.ledger.LedgerServices.check#NextFiscalTimePeriods"
                        in-map="[organizationPartyId:organizationPartyId]"/>
            </else></if>
        </actions>
    </service>

    <service verb="find" noun="PartyAcctgPreference">
        <description>Get the PartyAcctgPreference record for the specified organizationPartyId and if not found find
            record for ancestor organization(s).</description>
        <in-parameters><parameter name="organizationPartyId" required="true"/></in-parameters>
        <out-parameters><parameter name="partyAcctgPreference" type="EntityValue"/></out-parameters>
        <actions>
            <entity-find-one entity-name="mantle.ledger.config.PartyAcctgPreference" value-field="partyAcctgPreference" cache="true">
                <field-map field-name="organizationPartyId"/></entity-find-one>

            <if condition="!partyAcctgPreference">
                <entity-find entity-name="mantle.party.PartyRelationship" list="partyRelationshipList" cache="true">
                    <date-filter/>
                    <econdition field-name="fromPartyId" from="organizationPartyId"/>
                    <econdition field-name="relationshipTypeEnumId" value="PrtOrgRollup"/>
                    <econdition field-name="fromRoleTypeId" value="OrgInternal"/>
                    <econdition field-name="toRoleTypeId" value="OrgInternal"/>
                </entity-find>
                <if condition="partyRelationshipList">
                    <service-call name="mantle.ledger.LedgerServices.find#PartyAcctgPreference" out-map="context"
                            in-map="[organizationPartyId:partyRelationshipList[0].toPartyId]"/>
                </if>
            </if>
        </actions>
    </service>
    <service verb="find" noun="RootGlAccountClassEnum">
        <in-parameters><parameter name="glAccountClassEnumId"/></in-parameters>
        <out-parameters>
            <parameter name="rootGlAccountClassEnumId"/>
            <parameter name="ancestorClassEnumIdSet" type="Set"/>
            <parameter name="isContra"><description>From Enumeration.optionIndicator, Y if contra</description></parameter>
        </out-parameters>
        <actions>
            <entity-find-one entity-name="moqui.basic.Enumeration" value-field="enumValue" cache="true">
                <field-map field-name="enumId" from="glAccountClassEnumId"/></entity-find-one>
            <set field="isContra" from="enumValue.optionIndicator ?: 'N'"/>

            <set field="ancestorClassEnumIdSet" from="new HashSet([glAccountClassEnumId])"/>
            <if condition="enumValue.parentEnumId"><then>
                <service-call name="mantle.ledger.LedgerServices.find#RootGlAccountClassEnum" out-map="nestOut"
                        in-map="[glAccountClassEnumId:enumValue.parentEnumId]"/>
                <set field="rootGlAccountClassEnumId" from="nestOut.rootGlAccountClassEnumId"/>
                <script>ancestorClassEnumIdSet.addAll(nestOut.ancestorClassEnumIdSet)</script>
            </then><else>
                <set field="rootGlAccountClassEnumId" from="glAccountClassEnumId"/>
            </else></if>
        </actions>
    </service>
    <service verb="set" noun="GlAccountFlags">
        <description>Called by EECA rule on create and update of GlAccount.
            If isDebit or isTemporary are not set determine based on class and save them on the entityValue to be persisted.</description>
        <in-parameters>
            <parameter name="entityValue" type="Map"/>
        </in-parameters>
        <actions>
            <service-call name="mantle.ledger.LedgerServices.find#RootGlAccountClassEnum" out-map="context"
                    in-map="[glAccountClassEnumId:entityValue.glAccountClassEnumId]"/>

            <if condition="isContra == 'Y'"><then>
                <set field="entityValue.isDebit" from="'DEBIT'.equals(rootGlAccountClassEnumId) ? 'N' : 'Y'"/>
            </then><else>
                <set field="entityValue.isDebit" from="'DEBIT'.equals(rootGlAccountClassEnumId) ? 'Y' : 'N'"/>
            </else></if>
            <set field="entityValue.isTemporary" value="N"/>
            <set field="tempAccountClasses" from="['REVENUE', 'COST_OF_SALES', 'INCOME', 'EXPENSE', 'NON_OP_EXPENSE']"/>
            <iterate list="tempAccountClasses" entry="tempAccountClass">
                <if condition="ancestorClassEnumIdSet.contains(tempAccountClass)">
                    <set field="entityValue.isTemporary" value="Y"/><break/></if>
            </iterate>
        </actions>
    </service>
    <service verb="set" noun="MissingGlAccountFlags">
        <actions>
            <entity-find entity-name="mantle.ledger.account.GlAccount" list="glAccountList">
                <econditions combine="or"><econdition field-name="isDebit" operator="is-not-null"/>
                    <econdition field-name="isTemporary" operator="is-not-null"/></econditions>
            </entity-find>
            <iterate list="glAccountList" entry="glAccount">
                <service-call name="mantle.ledger.LedgerServices.find#RootGlAccountClassEnum"
                        out-map="rootOut" out-map-add-to-existing="false"
                        in-map="[glAccountClassEnumId:glAccount.glAccountClassEnumId]"/>

                <if condition="rootOut.isContra == 'Y'"><then>
                    <set field="entityValue.isDebit" from="'DEBIT'.equals(rootOut.rootGlAccountClassEnumId) ? 'N' : 'Y'"/>
                </then><else>
                    <set field="entityValue.isDebit" from="'DEBIT'.equals(rootOut.rootGlAccountClassEnumId) ? 'Y' : 'N'"/>
                </else></if>
                <set field="glAccount.isTemporary" value="N"/>
                <set field="tempAccountClasses" from="['REVENUE', 'COST_OF_SALES', 'INCOME', 'EXPENSE', 'NON_OP_EXPENSE']"/>
                <iterate list="tempAccountClasses" entry="tempAccountClass">
                    <if condition="rootOut.ancestorClassEnumIdSet.contains(tempAccountClass)">
                        <set field="glAccount.isTemporary" value="Y"/><break/></if>
                </iterate>
                <entity-update value-field="glAccount"/>
            </iterate>
        </actions>
    </service>
    <service verb="expand" noun="ParentOrganizationList">
        <in-parameters><parameter name="organizationPartyId" required="true"/></in-parameters>
        <out-parameters><parameter name="orgPartyIdList" type="List"/></out-parameters>
        <actions>
            <set field="orgPartyIdList" from="[organizationPartyId]"/>

            <entity-find entity-name="mantle.party.PartyRelationship" list="partyRelationshipList" cache="true">
                <date-filter/>
                <econdition field-name="fromPartyId" from="organizationPartyId"/>
                <econdition field-name="relationshipTypeEnumId" value="PrtOrgRollup"/>
                <econdition field-name="fromRoleTypeId" value="OrgInternal"/>
                <econdition field-name="toRoleTypeId" value="OrgInternal"/>
            </entity-find>
            <iterate list="partyRelationshipList" entry="partyRelationship">
                <service-call name="mantle.ledger.LedgerServices.expand#ParentOrganizationList" out-map="expandResult"
                        in-map="[organizationPartyId:partyRelationship.toPartyId]"/>
                <script>orgPartyIdList.addAll(expandResult.orgPartyIdList)</script>
            </iterate>
        </actions>
    </service>
    <service verb="expand" noun="ChildOrganizationList">
        <in-parameters>
            <parameter name="organizationPartyId" required="true"/>
            <parameter name="onlyWithNoAcctgPreference" type="Boolean" default="false"/>
        </in-parameters>
        <out-parameters><parameter name="orgPartyIdList" type="List"/></out-parameters>
        <actions>
            <entity-find-one entity-name="mantle.ledger.config.PartyAcctgPreference" value-field="partyAcctgPreference" cache="true">
                <field-map field-name="organizationPartyId"/></entity-find-one>
            <if condition="onlyWithNoAcctgPreference &amp;&amp; partyAcctgPreference"><then>
                <set field="orgPartyIdList" from="[]"/>
            </then><else>
                <set field="orgPartyIdList" from="[organizationPartyId]"/>
            </else></if>

            <entity-find entity-name="mantle.party.PartyRelationship" list="partyRelationshipList" cache="true">
                <date-filter/>
                <econdition field-name="toPartyId" from="organizationPartyId"/>
                <econdition field-name="relationshipTypeEnumId" value="PrtOrgRollup"/>
                <econdition field-name="fromRoleTypeId" value="OrgInternal"/>
                <econdition field-name="toRoleTypeId" value="OrgInternal"/>
            </entity-find>
            <iterate list="partyRelationshipList" entry="partyRelationship">
                <if condition="onlyWithNoAcctgPreference">
                    <entity-find-one entity-name="mantle.ledger.config.PartyAcctgPreference" value-field="partyAcctgPreference" cache="true">
                        <field-map field-name="organizationPartyId" from="partyRelationship.fromPartyId"/></entity-find-one>
                    <if condition="partyAcctgPreference"><continue/></if>
                </if>
                <service-call name="mantle.ledger.LedgerServices.expand#ChildOrganizationList" out-map="expandResult"
                        in-map="[organizationPartyId:partyRelationship.fromPartyId, onlyWithNoAcctgPreference:onlyWithNoAcctgPreference]"/>
                <script>orgPartyIdList.addAll(expandResult.orgPartyIdList)</script>
            </iterate>
        </actions>
    </service>

    <service verb="get" noun="DefaultGlAccountByType">
        <in-parameters>
            <parameter name="glAccountTypeEnumId" required="true"/>
            <parameter name="organizationPartyId" required="true"/>
            <!-- <parameter name="acctgTransTypeEnumId" required="true"/> -->
            <!-- <parameter name="otherPartyId"/> -->
        </in-parameters>
        <out-parameters>
            <parameter name="glAccountId"/>
        </out-parameters>
        <actions>
            <entity-find entity-name="mantle.ledger.config.GlAccountTypeDefault" list="glAccountTypeDefaultList" cache="true">
                <econdition field-name="organizationPartyId"/>
                <econdition field-name="glAccountTypeEnumId"/>
            </entity-find>
            <set field="glAccountId" from="glAccountTypeDefaultList.first?.glAccountId"/>

            <if condition="!glAccountId">
                <entity-find entity-name="mantle.party.PartyRelationship" list="partyRelationshipList" cache="true">
                    <date-filter/>
                    <econdition field-name="fromPartyId" from="organizationPartyId"/>
                    <econdition field-name="relationshipTypeEnumId" value="PrtOrgRollup"/>
                    <econdition field-name="fromRoleTypeId" value="OrgInternal"/>
                    <econdition field-name="toRoleTypeId" value="OrgInternal"/>
                </entity-find>
                <if condition="partyRelationshipList">
                    <service-call name="mantle.ledger.LedgerServices.get#DefaultGlAccountByType" out-map="context"
                            in-map="[organizationPartyId:partyRelationshipList[0].toPartyId,
                                glAccountTypeEnumId:glAccountTypeEnumId]"/>
                </if>
            </if>
        </actions>
    </service>

    <!-- ============================================================ -->
    <!-- ========== Manual Accounting Transaction Services ========== -->
    <!-- ============================================================ -->

    <service verb="create" noun="AcctgTrans">
        <in-parameters>
            <auto-parameters entity-name="mantle.ledger.transaction.AcctgTrans" include="nonpk">
                <exclude field-name="reversedByAcctgTransId"/><exclude field-name="reverseOfAcctgTransId"/>
                <exclude field-name="isPosted"/><exclude field-name="postedDate"/></auto-parameters>
            <parameter name="acctgTransTypeEnumId" required="true"/>
            <parameter name="organizationPartyId" required="true"/>
            <parameter name="transactionDate" type="Timestamp" default="ec.user.nowTimestamp"/>
            <parameter name="amountUomId"><description>Defaults to PartyAcctgPreference.baseCurrencyUomId</description></parameter>
            <parameter name="glFiscalTypeEnumId" default-value="GLFT_ACTUAL"/>
        </in-parameters>
        <out-parameters><parameter name="acctgTransId"/></out-parameters>
        <actions>
            <if condition="!amountUomId">
                <service-call name="mantle.ledger.LedgerServices.find#PartyAcctgPreference" out-map="context"
                        in-map="[organizationPartyId:organizationPartyId]"/>
                <set field="amountUomId" from="partyAcctgPreference?.baseCurrencyUomId ?: 'USD'"/>
            </if>
            <set field="isPosted" value="N"/>
            <service-call name="create#mantle.ledger.transaction.AcctgTrans" in-map="context" out-map="context"/>
        </actions>
    </service>
    <service verb="update" noun="AcctgTrans">
        <in-parameters>
            <parameter name="acctgTransId" required="true"/>
            <auto-parameters entity-name="mantle.ledger.transaction.AcctgTrans" include="nonpk">
                <exclude field-name="reversedByAcctgTransId"/><exclude field-name="reverseOfAcctgTransId"/>
                <exclude field-name="isPosted"/><exclude field-name="postedDate"/></auto-parameters>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="mantle.ledger.transaction.AcctgTrans" value-field="acctgTrans" for-update="true"/>
            <if condition="acctgTrans.isPosted == 'Y'"><return error="true" message="Cannot update transaction ${acctgTransId}, already posted."/></if>
            <service-call name="update#mantle.ledger.transaction.AcctgTrans" in-map="context" out-map="context"/>
        </actions>
    </service>
    <service verb="update" noun="AcctgTransPosted">
        <in-parameters>
            <parameter name="acctgTransId" required="true"/>
            <auto-parameters entity-name="mantle.ledger.transaction.AcctgTrans" include="nonpk">
                <exclude field-name="transactionDate"/><exclude field-name="amountUomId"/><exclude field-name="glFiscalTypeEnumId"/>
                <exclude field-name="reversedByAcctgTransId"/><exclude field-name="reverseOfAcctgTransId"/>
                <exclude field-name="isPosted"/><exclude field-name="postedDate"/></auto-parameters>
        </in-parameters>
        <actions>
            <service-call name="update#mantle.ledger.transaction.AcctgTrans" in-map="context" out-map="context"/>
        </actions>
    </service>
    <service verb="delete" noun="AcctgTrans">
        <in-parameters><parameter name="acctgTransId" required="true"/></in-parameters>
        <actions>
            <entity-find-one entity-name="mantle.ledger.transaction.AcctgTrans" value-field="acctgTrans" for-update="true"/>

            <if condition="acctgTrans.isPosted == 'Y'">
                <return error="true" message="Not deleting transaction ${acctgTransId}, transaction is posted"/></if>

            <!-- if this transaction reverses another clear its reference to this -->
            <if condition="acctgTrans.reverseOfAcctgTransId">
                <entity-find-one entity-name="mantle.ledger.transaction.AcctgTrans" value-field="revOfAcctgTrans" for-update="true">
                    <field-map field-name="acctgTransId" from="acctgTrans.reverseOfAcctgTransId"/></entity-find-one>
                <set field="revOfAcctgTrans.reversedByAcctgTransId" from="null"/>
                <entity-update value-field="revOfAcctgTrans"/>
            </if>
            <!-- delete entries -->
            <entity-delete-by-condition entity-name="mantle.ledger.transaction.AcctgTransEntry">
                <econdition field-name="acctgTransId"/></entity-delete-by-condition>
            <!-- delete the TX -->
            <entity-delete value-field="acctgTrans"/>
        </actions>
    </service>

    <service verb="create" noun="AcctgTransEntry">
        <in-parameters>
            <parameter name="acctgTransId" required="true"/>
            <parameter name="acctgTrans" type="EntityValue"/>
            <auto-parameters entity-name="mantle.ledger.transaction.AcctgTransEntry" include="nonpk"/>
            <parameter name="debitCreditFlag" required="true"/>
            <parameter name="amount" type="BigDecimal" required="true"/>
            <!-- allow setting this to be deferred <parameter name="glAccountId" required="true"/> -->
            <parameter name="reconcileStatusId" default-value="AterNot"/>
            <parameter name="isSummary" default-value="N"/>
        </in-parameters>
        <out-parameters><parameter name="acctgTransEntrySeqId"/></out-parameters>
        <actions>
            <if condition="!acctgTrans"><entity-find-one entity-name="mantle.ledger.transaction.AcctgTrans" value-field="acctgTrans" for-update="true"/></if>
            <if condition="acctgTrans.isPosted == 'Y'"><return error="true" message="Cannot create entry for transaction [${acctgTransId}], already posted."/></if>
            <if condition="amount &lt; 0">
                <!-- if negative abs the amount and reverse the debit/credit flag -->
                <set field="amount" from="amount.abs()"/>
                <set field="debitCreditFlag" from="debitCreditFlag == 'D' ? 'C' : 'D'"/>
            </if>
            <service-call name="create#mantle.ledger.transaction.AcctgTransEntry" in-map="context" out-map="context"/>
        </actions>
    </service>
    <service verb="update" noun="AcctgTransEntry">
        <in-parameters>
            <parameter name="acctgTransId" required="true"/>
            <parameter name="acctgTransEntrySeqId" required="true"/>
            <auto-parameters entity-name="mantle.ledger.transaction.AcctgTransEntry" include="nonpk"/>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="mantle.ledger.transaction.AcctgTrans" value-field="acctgTrans" for-update="true"/>
            <if condition="acctgTrans.isPosted == 'Y'"><return error="true" message="Cannot update entry for transaction [${acctgTransId}], already posted."/></if>
            <service-call name="update#mantle.ledger.transaction.AcctgTransEntry" in-map="context"/>
        </actions>
    </service>
    <service verb="delete" noun="AcctgTransEntry">
        <in-parameters>
            <parameter name="acctgTransId" required="true"/>
            <parameter name="acctgTransEntrySeqId" required="true"/>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="mantle.ledger.transaction.AcctgTrans" value-field="acctgTrans" for-update="true"/>
            <if condition="acctgTrans.isPosted == 'Y'"><return error="true" message="Cannot delete entry for transaction [${acctgTransId}], already posted."/></if>
            <service-call name="delete#mantle.ledger.transaction.AcctgTransEntry" in-map="context"/>
        </actions>
    </service>

    <!-- ================================================= -->
    <!-- ========== AcctgTrans Posting Services ========== -->
    <!-- ================================================= -->

    <service verb="calculate" noun="AcctgTransTrialBalance">
        <description>Add up debits and credits for an AcctgTrans and get the difference.</description>
        <in-parameters><parameter name="acctgTransId" required="true"/></in-parameters>
        <out-parameters>
            <parameter name="debitTotal" type="BigDecimal"/>
            <parameter name="creditTotal" type="BigDecimal"/>
            <parameter name="debitCreditDifference" type="BigDecimal"/>
        </out-parameters>
        <actions>
            <entity-find entity-name="mantle.ledger.transaction.AcctgTransEntry" list="acctgTransEntryList">
                <econdition field-name="acctgTransId"/>
                <order-by field-name="acctgTransEntrySeqId"/>
            </entity-find>
            <set field="debitTotal" from="0.0"/>
            <set field="creditTotal" from="0.0"/>
            <iterate entry="acctgTransEntry" list="acctgTransEntryList">
                <if condition="acctgTransEntry.debitCreditFlag == 'D'"><then>
                    <set field="debitTotal" from="debitTotal + (acctgTransEntry.amount ?: 0.0)"/>
                </then><else>
                    <set field="creditTotal" from="creditTotal + (acctgTransEntry.amount ?: 0.0)"/>
                </else></if>
            </iterate>

            <set field="debitCreditDifference" from="debitTotal - creditTotal"/>
        </actions>
    </service>
    <service verb="post" noun="AcctgTrans">
        <description>Posts an Accounting Transaction (AcctgTrans) after verifying it is ready for posting (with
            verify#AcctgTrans service).</description>
        <in-parameters>
            <parameter name="acctgTransId" required="true"/>
            <parameter name="verifyOnly" type="Boolean" default="false"/>
            <parameter name="forcePost" type="Boolean" default="false">
                <description>Post the transaction even if period closed</description></parameter>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="mantle.ledger.transaction.AcctgTrans" value-field="acctgTrans" for-update="true"/>
            <entity-find entity-name="mantle.ledger.transaction.AcctgTransEntry" list="acctgTransEntryList">
                <econdition field-name="acctgTransId"/><order-by field-name="acctgTransEntrySeqId"/></entity-find>

            <!-- make sure the AcctgTrans has not already been posted -->
            <if condition="acctgTrans.isPosted == 'Y'">
                <return message="Transaction ${acctgTransId} already posted, not posting"/></if>

            <set field="useErrorJournal" from="false"/>

            <!-- check the scheduled posting date, but only if it's set -->
            <if condition="acctgTrans.scheduledPostingDate != null &amp;&amp; ec.user.nowTimestamp.before(acctgTrans.scheduledPostingDate)">
                <message type="danger">Not posting transaction ${acctgTransId}, before scheduled posting date.</message>
                <set field="useErrorJournal" from="true"/>
            </if>

            <!-- check trial balance -->
            <service-call name="mantle.ledger.LedgerServices.calculate#AcctgTransTrialBalance" out-map="context"
                    in-map="[acctgTransId:acctgTransId]"/>
            <if condition="debitTotal != creditTotal">
                <message type="danger">Not posting transaction ${acctgTransId}, credit total ${creditTotal} and debit total ${debitTotal} not equal.</message>
                <set field="useErrorJournal" from="true"/>
            </if>

            <!-- get GlAccount records, make sure accounts allow posting -->
            <set field="glAccountIdList" from="new LinkedList(new HashSet(acctgTransEntryList*.glAccountId)).sort()"/>
            <set field="glAccountById" from="new LinkedHashMap()"/>
            <iterate list="glAccountIdList" entry="glAccountId">
                <entity-find-one entity-name="mantle.ledger.account.GlAccount" value-field="glAccount" cache="true">
                    <field-map field-name="glAccountId" from="glAccountId"/></entity-find-one>
                <script>glAccountById.put(glAccountId, glAccount)</script>

                <if condition="glAccount.disallowPosting == 'Y'">
                    <message type="danger">GL Account ${glAccount.glAccountId} does not allow posting</message>
                    <log message="In AcctgTrans ${acctgTransId} GL Account ${glAccount.glAccountId} does not allow posting"/>
                    <set field="useErrorJournal" from="true"/>
                </if>
            </iterate>

            <service-call name="mantle.ledger.LedgerServices.find#PartyAcctgPreference" out-map="context"
                          in-map="[organizationPartyId:acctgTrans.organizationPartyId]"/>
            <set field="doRealTimeGlSummary" from="partyAcctgPreference?.realTimeGlSummary == 'Y'"/>

            <if condition="useErrorJournal">
                <if condition="partyAcctgPreference?.errorGlJournalId"><then>
                    <service-call name="update#mantle.ledger.transaction.AcctgTrans"
                                  in-map="[acctgTransId:acctgTransId, glJournalId:partyAcctgPreference.errorGlJournalId]"/>
                    <message type="warning">Accounting transaction ${acctgTransId} has been saved in Error Journal ${partyAcctgPreference.errorGlJournalId}.</message>
                    <return/>
                </then><else>
                    <!-- if no errorGlJournalId return error -->
                    <return error="true" message="No error journal, returning error instead"/>
                </else></if>
            </if>

            <!-- get current period(s) and check if closed (also include parent organizations) -->
            <service-call name="mantle.ledger.LedgerServices.get#OrganizationFiscalTimePeriods" out-map="context"
                    in-map="[organizationPartyId:acctgTrans.organizationPartyId, filterDate:acctgTrans.transactionDate]"/>
            <if condition="!timePeriodList">
                <message>Not posting transaction ${acctgTransId}, could not find time period for organization ${acctgTrans.organizationPartyId} at ${ec.l10n.format(acctgTrans.transactionDate, null)}.</message>
                <set field="useErrorJournal" from="true"/>
            </if>
            <iterate entry="timePeriod" list="timePeriodList">
                <!-- make sure the TimePeriod isn't closed -->
                <if condition="timePeriod.isClosed == 'Y' &amp;&amp; !(acctgTrans.acctgTransTypeEnumId in ['AttPeriodClosing', 'AttNetIncomeClosing'])">
                    <if condition="forcePost"><then>
                        <!-- check permission, danger messages and error journal if no permission -->
                        <if condition="!ec.user.hasPermission('GL_POST_CLOSED')">
                            <message type="danger">Not posting transaction ${acctgTransId}, time period closed ${ec.resource.expand('TimePeriodNameTemplate','',timePeriod)}.</message>
                            <message type="danger">Ignoring force post because user does not have permission.</message>
                            <set field="useErrorJournal" from="true"/>
                            <break/>
                        </if>
                    </then><else>
                        <message type="danger">Not posting transaction ${acctgTransId}, time period closed ${ec.resource.expand('TimePeriodNameTemplate','',timePeriod)}.</message>
                        <set field="useErrorJournal" from="true"/>
                        <break/>
                    </else></if>
                </if>
            </iterate>

            <!-- make sure the glAccountId and amount fields are set -->
            <iterate entry="acctgTransEntry" list="acctgTransEntryList">
                <if condition="!acctgTransEntry.glAccountId">
                    <message type="warning">Accounting transaction entry ${acctgTransId}:${acctgTransEntry.acctgTransEntrySeqId} has no glAccountId.</message>
                    <set field="useErrorJournal" from="true"/>
                </if>
                <if condition="acctgTransEntry.amount == null">
                    <message type="warning">Accounting transaction entry ${acctgTransId}:${acctgTransEntry.acctgTransEntrySeqId} has no amount.</message>
                    <set field="useErrorJournal" from="true"/>
                </if>
            </iterate>

            <if condition="verifyOnly">
                <if condition="useErrorJournal || ec.message.hasError()"><then>
                    <message type="danger">Accounting transaction ${acctgTransId} has issues and may not be posted.</message>
                </then><else>
                    <message type="success">Accounting transaction ${acctgTransId} is verified for posting.</message>
                </else></if>
                <return/>
            </if>

            <if condition="useErrorJournal || ec.message.hasError()">
                <service-call name="mantle.ledger.LedgerServices.find#PartyAcctgPreference" out-map="context"
                        in-map="[organizationPartyId:acctgTrans.organizationPartyId]"/>
                <if condition="partyAcctgPreference?.errorGlJournalId"><then>
                    <service-call name="update#mantle.ledger.transaction.AcctgTrans"
                            in-map="[acctgTransId:acctgTransId, glJournalId:partyAcctgPreference.errorGlJournalId]"/>
                    <message type="warning">Accounting transaction ${acctgTransId} has been saved in Error Journal ${partyAcctgPreference.errorGlJournalId}.</message>
                    <script>ec.message.clearErrors()</script>
                    <return/>
                </then><else>
                    <!-- if no errorGlJournalId return with messages/errors -->
                    <return/>
                </else></if>
            </if>

            <check-errors/>

            <!-- do the actual posting: set isPosted to Y and postedDate to now on AcctgTrans, use the EntityValue we already found -->
            <set field="acctgTrans.isPosted" value="Y"/>
            <set field="acctgTrans.postedDate" from="ec.user.nowTimestamp"/>
            <entity-update value-field="acctgTrans"/>

            <!-- only update GlAccountOrganization and GlAccountOrgTimePeriod if realTimeGlSummary == Y; there is now a job that
                periodically updates these records to simplify GL posting and avoid lock contention and conflicts -->
            <if condition="doRealTimeGlSummary">
                <service-call name="mantle.ledger.LedgerServices.update#GlAccountOrgSummariesForTx"
                        in-map="[acctgTransId:acctgTransId, timePeriodList:timePeriodList, isUnpost:false]"/>
            </if>
        </actions>
    </service>

    <service verb="unpost" noun="AcctgTrans">
        <description>Un-posts a posted Accounting Transaction (AcctgTrans)</description>
        <in-parameters>
            <parameter name="acctgTransId" required="true"/>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="mantle.ledger.transaction.AcctgTrans" value-field="acctgTrans" for-update="true"/>

            <!-- make sure the AcctgTrans has not already been posted -->
            <if condition="acctgTrans.isPosted != 'Y'">
                <return message="Transaction ${acctgTransId} not posted, not un-posting"/></if>

            <service-call name="mantle.ledger.LedgerServices.find#PartyAcctgPreference" out-map="context"
                    in-map="[organizationPartyId:acctgTrans.organizationPartyId]"/>
            <set field="doRealTimeGlSummary" from="partyAcctgPreference?.realTimeGlSummary == 'Y'"/>

            <!-- get relevant period(s) for transaction and check if closed (also include parent organizations) -->
            <service-call name="mantle.ledger.LedgerServices.get#OrganizationFiscalTimePeriods" out-map="context"
                    in-map="[organizationPartyId:acctgTrans.organizationPartyId, filterDate:acctgTrans.transactionDate]"/>
            <if condition="!timePeriodList">
                <message error="true">Not un-posting transaction ${acctgTransId}, could not find time period for organization ${acctgTrans.organizationPartyId} at ${ec.l10n.format(acctgTrans.transactionDate, null)}.</message></if>
            <iterate list="timePeriodList" entry="timePeriod">
                <!-- make sure the TimePeriod isn't closed -->
                <if condition="timePeriod.isClosed == 'Y' &amp;&amp; !(acctgTrans.acctgTransTypeEnumId in ['AttPeriodClosing', 'AttNetIncomeClosing'])">
                    <message error="true">Not un-posting transaction ${acctgTransId}, time period closed ${ec.resource.expand('TimePeriodNameTemplate','',timePeriod)}.</message></if>
            </iterate>

            <!-- only update GlAccountOrganization and GlAccountOrgTimePeriod if realTimeGlSummary == Y; there is now a job that
                periodically updates these records to simplify GL posting and avoid lock contention and conflicts -->
            <if condition="doRealTimeGlSummary">
                <service-call name="mantle.ledger.LedgerServices.update#GlAccountOrgSummariesForTx"
                        in-map="[acctgTransId:acctgTransId, timePeriodList:timePeriodList, isUnpost:true]"/>
            </if>

            <check-errors/>

            <!-- do the actual posting: set isPosted to Y and postedDate to now on AcctgTrans, use the EntityValue we already found -->
            <set field="acctgTrans.isPosted" value="N"/>
            <set field="acctgTrans.postedDate" from="null"/>
            <entity-update value-field="acctgTrans"/>
        </actions>
    </service>

    <service verb="update" noun="GlAccountOrgSummariesForTx">
        <in-parameters>
            <parameter name="acctgTransId" required="true"/>
            <parameter name="isUnpost" type="Boolean" default="false"/>
            <parameter name="timePeriodList" type="List"><parameter name="timePeriod" type="Map"/></parameter>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="mantle.ledger.transaction.AcctgTrans" value-field="acctgTrans"/>
            <entity-find entity-name="mantle.ledger.transaction.AcctgTransEntry" list="acctgTransEntryList">
                <econdition field-name="acctgTransId"/><order-by field-name="acctgTransEntrySeqId"/></entity-find>

            <set field="glAccountIdList" from="new LinkedList(new HashSet(acctgTransEntryList*.glAccountId)).sort()"/>
            <set field="glAccountById" from="new LinkedHashMap()"/>
            <iterate list="glAccountIdList" entry="glAccountId">
                <entity-find-one entity-name="mantle.ledger.account.GlAccount" value-field="glAccount" cache="true">
                    <field-map field-name="glAccountId" from="glAccountId"/></entity-find-one>
                <script>glAccountById.put(glAccountId, glAccount)</script>
            </iterate>

            <!-- get relevant period(s) for transaction -->
            <if condition="!timePeriodList">
                <service-call name="mantle.ledger.LedgerServices.get#OrganizationFiscalTimePeriods" out-map="context"
                        in-map="[organizationPartyId:acctgTrans.organizationPartyId, filterDate:acctgTrans.transactionDate]"/>
                <if condition="!timePeriodList"><return message="Not un-posting transaction ${acctgTransId}, could not find time period for organization ${acctgTrans.organizationPartyId} at ${ec.l10n.format(acctgTrans.transactionDate, null)}"/></if>
            </if>

            <set field="subsequentPeriodListArray" from="new ArrayList()"/>
            <iterate entry="timePeriod" list="timePeriodList">
                <!-- get any existing subsequent time periods to update those as well -->
                <script>
                    List subsequentPeriodIds = []
                    subsequentPeriodListArray.add(subsequentPeriodIds)
                    String curSubPeriodId = timePeriod.timePeriodId
                    while (curSubPeriodId) {
                        Map subNextResult = ec.service.sync().name("mantle.party.TimeServices.get#NextTimePeriod")
                                .parameter("timePeriodId", curSubPeriodId).call()
                        curSubPeriodId = subNextResult.nextTimePeriodId
                        if (curSubPeriodId) subsequentPeriodIds.add(curSubPeriodId)
                    }
                </script>
            </iterate>

            <!-- get and lock the GlAccountOrganization (for update); iterate over glAccountList which is sorted for consistent lock order (avoid deadlocks) -->
            <set field="glAccountOrganizationById" from="[:]"/>
            <iterate list="glAccountIdList" entry="glAccountId">
                <entity-find-one entity-name="mantle.ledger.account.GlAccountOrganization" value-field="glAccountOrganization" for-update="true">
                    <field-map field-name="glAccountId"/><field-map field-name="organizationPartyId" from="acctgTrans.organizationPartyId"/></entity-find-one>
                <if condition="glAccountOrganization == null">
                    <!-- lock on the GlAccount since we can't on the GlAccountOrganization we are creating, and then query again to see if exists -->
                    <entity-find-one entity-name="mantle.ledger.account.GlAccount" value-field="glAccount" for-update="true"/>
                    <entity-find-one entity-name="mantle.ledger.account.GlAccountOrganization" value-field="glAccountOrganization" for-update="true">
                        <field-map field-name="glAccountId"/><field-map field-name="organizationPartyId" from="acctgTrans.organizationPartyId"/></entity-find-one>
                    <if condition="glAccountOrganization == null">
                        <entity-make-value entity-name="mantle.ledger.account.GlAccountOrganization" value-field="glAccountOrganization"
                                map="[glAccountId:glAccountId, organizationPartyId:acctgTrans.organizationPartyId]"/>
                        <entity-create value-field="glAccountOrganization"/>
                    </if>
                </if>
                <script>glAccountOrganizationById.put(glAccountId, glAccountOrganization)</script>
            </iterate>

            <!-- for each entry update posted balance -->
            <set field="isPeriodClosing" from="acctgTrans.acctgTransTypeEnumId == 'AttNetIncomeClosing'"/>
            <iterate list="acctgTransEntryList" entry="acctgTransEntry">
                <set field="glAccountOrganization" from="glAccountOrganizationById.get(acctgTransEntry.glAccountId)"/>

                <!-- Debits add to debit accounts and subtract from credit accounts. Credits add to credit accounts and subtract from debit accounts. -->
                <set field="postingAmount" from="0.0"/>
                <!-- have already iterated through the entry list once, all GlAccount records should be there -->
                <set field="glAccount" from="glAccountById.get(acctgTransEntry.glAccountId)"/>

                <if condition="glAccount.isDebit.equals('Y')"><then>
                    <set field="postingAmount" from="acctgTransEntry.debitCreditFlag == 'D' ? acctgTransEntry.amount : -acctgTransEntry.amount"/>
                </then><else>
                    <set field="postingAmount" from="acctgTransEntry.debitCreditFlag == 'D' ? -acctgTransEntry.amount : acctgTransEntry.amount"/>
                </else></if>
                <if condition="isUnpost"><set field="postingAmount" from="-postingAmount"/></if>

                <!-- FUTURE: do anything with RESOURCE or potentially other root GL account classes? -->

                <set field="glAccountOrganization.postedBalance" from="(glAccountOrganization.postedBalance ?: 0.0) + postingAmount"/>
                <set field="glAccountOrganization.balanceLastUpdated" from="ec.user.nowTimestamp"/>
                <entity-update value-field="glAccountOrganization"/>

                <!-- create or update GlAccountOrgTimePeriod records -->
                <iterate list="timePeriodList" entry="timePeriod">
                    <entity-find-one entity-name="mantle.ledger.account.GlAccountOrgTimePeriod" value-field="glAccountOrgTimePeriod" for-update="true">
                        <field-map field-name="glAccountId" from="acctgTransEntry.glAccountId"/>
                        <field-map field-name="organizationPartyId" from="acctgTrans.organizationPartyId"/>
                        <field-map field-name="timePeriodId" from="timePeriod.timePeriodId"/>
                    </entity-find-one>
                    <if condition="glAccountOrgTimePeriod == null">
                        <!-- lock on the GlAccountOrganization since we can't on the GlAccountOrgTimePeriod we are creating, and then query again to see if exists -->
                        <entity-find-one entity-name="mantle.ledger.account.GlAccountOrganization" value-field="glAccountOrgTemp" for-update="true">
                            <field-map field-name="glAccountId" from="acctgTransEntry.glAccountId"/>
                            <field-map field-name="organizationPartyId" from="acctgTrans.organizationPartyId"/>
                        </entity-find-one>
                        <entity-find-one entity-name="mantle.ledger.account.GlAccountOrgTimePeriod" value-field="glAccountOrgTimePeriod" for-update="true">
                            <field-map field-name="glAccountId" from="acctgTransEntry.glAccountId"/>
                            <field-map field-name="organizationPartyId" from="acctgTrans.organizationPartyId"/>
                            <field-map field-name="timePeriodId" from="timePeriod.timePeriodId"/>
                        </entity-find-one>
                        <if condition="glAccountOrgTimePeriod == null">
                            <entity-make-value entity-name="mantle.ledger.account.GlAccountOrgTimePeriod" value-field="glAccountOrgTimePeriod"
                                    map="[glAccountId:acctgTransEntry.glAccountId,  organizationPartyId:acctgTrans.organizationPartyId,
                                           timePeriodId:timePeriod.timePeriodId, beginningBalance:0.0, postedDebits:0.0, postedCredits:0.0,
                                           postedDebitsNoClosing:0.0, postedCreditsNoClosing:0.0, endingBalance:0.0]"/>
                        </if>
                    </if>

                    <set field="dcTransEntryAmount" from="isUnpost ? -acctgTransEntry.amount : acctgTransEntry.amount"/>
                    <if condition="acctgTransEntry.debitCreditFlag == 'D'"><then>
                        <set field="glAccountOrgTimePeriod.postedDebits" from="(glAccountOrgTimePeriod.postedDebits ?: 0.0) + dcTransEntryAmount"/>
                        <if condition="!isPeriodClosing"><set field="glAccountOrgTimePeriod.postedDebitsNoClosing"
                                from="(glAccountOrgTimePeriod.postedDebitsNoClosing ?: 0.0) + dcTransEntryAmount"/></if>
                    </then><else>
                        <set field="glAccountOrgTimePeriod.postedCredits" from="(glAccountOrgTimePeriod.postedCredits ?: 0.0) + dcTransEntryAmount"/>
                        <if condition="!isPeriodClosing"><set field="glAccountOrgTimePeriod.postedCreditsNoClosing"
                                from="(glAccountOrgTimePeriod.postedCreditsNoClosing ?: 0.0) + dcTransEntryAmount"/></if>
                    </else></if>

                    <set field="glAccountOrgTimePeriod.endingBalance" from="(glAccountOrgTimePeriod.endingBalance ?: 0.0) + postingAmount"/>

                    <set field="glAccountOrgTimePeriod.balanceLastUpdated" from="ec.user.nowTimestamp"/>
                    <entity-create value-field="glAccountOrgTimePeriod" or-update="true"/>

                    <!-- update period begin and end balances on posting, not just on closing (recalc and reset on period close) -->
                    <set field="subsequentPeriodList" from="subsequentPeriodListArray.get(timePeriod_index)"/>
                    <set field="lastGlAccountOrgTimePeriod" from="glAccountOrgTimePeriod"/>
                    <!-- NOTE: this iterate block very similar to one in recalculate#GlAccountOrgTimePeriodAmounts, perhaps refactor into service -->
                    <iterate list="subsequentPeriodList" entry="subsequentPeriodId">
                        <!-- for each GlAccountOrgTimePeriod record for current period, set beginning balance for next period
                            (creating new records if they don't exist) -->
                        <entity-find-one entity-name="mantle.ledger.account.GlAccountOrgTimePeriod" value-field="nextGlAccountOrgTimePeriod" for-update="true">
                            <field-map field-name="glAccountId" from="acctgTransEntry.glAccountId"/>
                            <field-map field-name="organizationPartyId" from="timePeriod.partyId"/>
                            <field-map field-name="timePeriodId" from="subsequentPeriodId"/>
                        </entity-find-one>
                        <if condition="nextGlAccountOrgTimePeriod == null">
                            <entity-make-value entity-name="mantle.ledger.account.GlAccountOrgTimePeriod" value-field="nextGlAccountOrgTimePeriod"
                                    map="[glAccountId:glAccountOrgTimePeriod.glAccountId,  organizationPartyId:timePeriod.partyId,
                                            timePeriodId:subsequentPeriodId, beginningBalance:0.0, postedDebits:0.0, postedCredits:0.0,
                                            postedDebitsNoClosing:0.0, postedCreditsNoClosing:0.0, endingBalance:0.0]"/>
                        </if>
                        <!-- add endingBalance to both just in case something has already been posted and added to next endingBalance -->
                        <set field="nextGlAccountOrgTimePeriod.endingBalance"
                                from="((nextGlAccountOrgTimePeriod.endingBalance ?: 0.0) - (nextGlAccountOrgTimePeriod.beginningBalance ?: 0.0)) +
                                    lastGlAccountOrgTimePeriod.endingBalance"/>
                        <!-- set next beginningBalance from current endingBalance; do after set next endingBalance because it uses next beginningBalance if there is a value -->
                        <set field="nextGlAccountOrgTimePeriod.beginningBalance" from="lastGlAccountOrgTimePeriod.endingBalance"/>

                        <set field="nextGlAccountOrgTimePeriod.balanceLastUpdated" from="ec.user.nowTimestamp"/>
                        <entity-create value-field="nextGlAccountOrgTimePeriod" or-update="true"/>

                        <set field="lastGlAccountOrgTimePeriod" from="nextGlAccountOrgTimePeriod"/>
                    </iterate>
                </iterate>
            </iterate>
        </actions>
    </service>

    <service verb="post" noun="ReverseAcctgTrans">
        <description>Create a new transaction that is the reverse of the original (for each entry debits to credit and
            vice versa, transaction date set to now, etc).Clones the original transaction so new one will be associated
            with the same invoice, payment, etc.</description>
        <in-parameters>
            <parameter name="acctgTransId" required="true"/>
            <parameter name="deleteIfNotPosted" type="Boolean" default="false"/>
            <parameter name="createOnly" type="Boolean" default="false"/>
        </in-parameters>
        <out-parameters><parameter name="acctgTransId" required="true"/></out-parameters>
        <actions>
            <entity-find-one entity-name="mantle.ledger.transaction.AcctgTrans" value-field="acctgTrans" for-update="true"/>

            <if condition="acctgTrans.isPosted != 'Y'"><if condition="deleteIfNotPosted"><then>
                <service-call name="mantle.ledger.LedgerServices.delete#AcctgTrans" in-map="[acctgTransId:acctgTransId]"/>
                <return message="Deleted unposted transaction ${acctgTransId} instead of creating new reverse transaction"/>
            </then><else>
                <return error="true" message="Not reversing transaction ${acctgTransId}, transaction is not posted"/>
            </else></if></if>

            <if condition="acctgTrans.reversedByAcctgTransId">
                <return error="true" message="Not reversing transaction ${acctgTransId}, already reversed by transaction ${acctgTrans.reversedByAcctgTransId}"/></if>

            <entity-find entity-name="mantle.ledger.transaction.AcctgTransEntry" list="acctgTransEntryList">
                <econdition field-name="acctgTransId"/><order-by field-name="acctgTransEntrySeqId"/></entity-find>

            <set field="reverseAcctgTrans" from="acctgTrans.clone()"/>
            <set field="reverseAcctgTrans.acctgTransId" from="null"/>
            <entity-sequenced-id-primary value-field="reverseAcctgTrans"/>
            <set field="reverseAcctgTrans.reverseOfAcctgTransId" from="acctgTransId"/>
            <!-- don't do this! use same transactionDate as original, if posting fails then it can be updated manually: <set field="reverseAcctgTrans.transactionDate" from="ec.user.nowTimestamp"/> -->
            <set field="reverseAcctgTrans.isPosted" value="N"/>
            <entity-create value-field="reverseAcctgTrans"/>

            <set field="reverseAcctgTransId" from="reverseAcctgTrans.acctgTransId"/>

            <set field="useErrorJournal" from="false"/>
            <iterate list="acctgTransEntryList" entry="acctgTransEntry">
                <set field="reverseAcctgTransEntry" from="acctgTransEntry.clone()"/>
                <set field="reverseAcctgTransEntry.acctgTransId" from="reverseAcctgTransId"/>
                <set field="reverseAcctgTransEntry.reconcileStatusId" value="AterNot"/>
                <set field="reverseAcctgTransEntry.debitCreditFlag"
                        from="reverseAcctgTransEntry.debitCreditFlag == 'C' ? 'D' : 'C'"/>
                <entity-create value-field="reverseAcctgTransEntry"/>

                <if condition="!reverseAcctgTransEntry.glAccountId"><set field="useErrorJournal" from="true"/></if>
            </iterate>

            <message>Created GL transaction ${reverseAcctgTransId} to reverse transaction ${acctgTransId}</message>

            <if condition="useErrorJournal"><then>
                <!-- put in the error journal for the org -->
                <service-call name="mantle.ledger.LedgerServices.find#PartyAcctgPreference" out-map="context"
                        in-map="[organizationPartyId:acctgTrans.organizationPartyId]"/>
                <if condition="partyAcctgPreference?.errorGlJournalId">
                    <service-call name="update#mantle.ledger.transaction.AcctgTrans"
                            in-map="[acctgTransId:reverseAcctgTrans.acctgTransId,
                                glJournalId:partyAcctgPreference.errorGlJournalId]"/>
                </if>
            </then><else-if condition="!createOnly">
                <!-- call the post service -->
                <service-call name="mantle.ledger.LedgerServices.post#AcctgTrans" in-map="[acctgTransId:reverseAcctgTransId]"/>
                <message>Posted transaction ${reverseAcctgTransId}</message>
            </else-if></if>

            <set field="acctgTrans.reversedByAcctgTransId" from="reverseAcctgTransId"/>
            <entity-update value-field="acctgTrans"/>

            <set field="acctgTransId" from="reverseAcctgTransId"/>
        </actions>
    </service>
    <service verb="move" noun="AcctgTransEntry">
        <description>Move a transaction entry from one account to another by posting a transaction reversing the original
            for just the given entry and redoing the original transaction in the other account. Clones the original
            transaction so new one will be associated with the same invoice, payment, etc.</description>
        <in-parameters>
            <parameter name="acctgTransId" required="true"/>
            <parameter name="acctgTransEntrySeqId" required="true"/>
            <parameter name="glAccountId" required="true"/>
        </in-parameters>
        <out-parameters><parameter name="acctgTransId" required="true"/></out-parameters>
        <actions>
            <entity-find-one entity-name="mantle.ledger.transaction.AcctgTrans" value-field="acctgTrans"/>
            <entity-find-one entity-name="mantle.ledger.transaction.AcctgTransEntry" value-field="acctgTransEntry"/>

            <if condition="acctgTrans.isPosted != 'Y'">
                <return error="true" message="Not moving transaction entry [${acctgTransId}:${acctgTransEntrySeqId}], transaction is not posted"/></if>
            <if condition="acctgTransEntry.glAccountId == glAccountId">
                <return message="Not moving transaction entry [${acctgTransId}:${acctgTransEntrySeqId}], entry is already posted to account ${glAccountId}"/></if>

            <set field="reverseAcctgTrans" from="acctgTrans.clone()"/>
            <set field="reverseAcctgTrans.acctgTransId" from="null"/>
            <entity-sequenced-id-primary value-field="reverseAcctgTrans"/>
            <!-- don't do this! use same transactionDate as original, if posting fails then it can be updated manually: <set field="reverseAcctgTrans.transactionDate" from="ec.user.nowTimestamp"/> -->
            <set field="reverseAcctgTrans.isPosted" value="N"/>
            <entity-create value-field="reverseAcctgTrans"/>

            <set field="reverseAcctgTransId" from="reverseAcctgTrans.acctgTransId"/>

            <!-- reverse the original entry -->
            <set field="reverseAcctgTransEntry" from="acctgTransEntry.clone()"/>
            <set field="reverseAcctgTransEntry.acctgTransId" from="reverseAcctgTransId"/>
            <set field="reverseAcctgTransEntry.reconcileStatusId" value="AterNot"/>
            <set field="reverseAcctgTransEntry.debitCreditFlag"
                    from="reverseAcctgTransEntry.debitCreditFlag == 'C' ? 'D' : 'C'"/>
            <entity-create value-field="reverseAcctgTransEntry"/>

            <!-- create new entry in new account -->
            <set field="newAcctgTransEntry" from="acctgTransEntry.clone()"/>
            <set field="newAcctgTransEntry.acctgTransId" from="reverseAcctgTransId"/>
            <set field="newAcctgTransEntry.reconcileStatusId" value="AterNot"/>
            <set field="newAcctgTransEntry.glAccountId" from="glAccountId"/>
            <set field="newAcctgTransEntry.acctgTransEntrySeqId" from="null"/>
            <entity-sequenced-id-secondary value-field="newAcctgTransEntry"/>
            <entity-create value-field="newAcctgTransEntry"/>

            <!-- call the post service -->
            <service-call name="mantle.ledger.LedgerServices.post#AcctgTrans" in-map="[acctgTransId:reverseAcctgTransId]"/>

            <set field="acctgTransId" from="reverseAcctgTransId"/>
        </actions>
    </service>

    <!-- =================================================== -->
    <!-- ========== Financial TimePeriod Services ========== -->
    <!-- =================================================== -->

    <service verb="get" noun="OrganizationFiscalTimePeriods">
        <in-parameters>
            <parameter name="organizationPartyId" required="true"/>
            <parameter name="filterDate" type="Timestamp"/>
            <parameter name="timePeriodTypeId"/>
            <parameter name="term"/>
        </in-parameters>
        <out-parameters><parameter name="timePeriodList" type="List"/></out-parameters>
        <actions>
            <!-- NOTE: this one is not recursive, should really have TimePeriod associated with root parent org so just one will match -->
            <set field="filterSqlDate" from="filterDate != null ? new java.sql.Date(filterDate.time) : null"/>
            <entity-find entity-name="mantle.party.time.TimePeriodAndType" list="timePeriodList">
                <!-- doesn't work as needed with date fields (only date-time): <date-filter valid-date="filterSqlDate" ignore-if-empty="true"/> -->
                <econdition field-name="fromDate" operator="less-equals" from="filterSqlDate" ignore-if-empty="true"/>
                <econdition field-name="thruDate" operator="greater-equals" from="filterSqlDate" ignore-if-empty="true"/>
                <econdition field-name="periodPurposeEnumId" value="Fiscal" ignore="timePeriodTypeId"/>
                <econdition field-name="partyId" from="organizationPartyId"/>
                <econdition field-name="timePeriodTypeId" ignore-if-empty="true"/>
                <econdition field-name="periodName" operator="like" value="%${term}%" ignore-case="true" ignore="!term"/>
            </entity-find>

            <if condition="!timePeriodList">
                <!-- see if a parent org has time periods, if so create for current org based on them -->
                <entity-find entity-name="mantle.party.PartyRelationship" list="partyRelationshipList" cache="true">
                    <date-filter/>
                    <econdition field-name="fromPartyId" from="organizationPartyId"/>
                    <econdition field-name="relationshipTypeEnumId" value="PrtOrgRollup"/>
                    <econdition field-name="fromRoleTypeId" value="OrgInternal"/>
                    <econdition field-name="toRoleTypeId" value="OrgInternal"/>
                </entity-find>
                <if condition="partyRelationshipList">
                    <service-call name="mantle.ledger.LedgerServices.get#OrganizationFiscalTimePeriods" out-map="parentPeriodsOut"
                            in-map="[organizationPartyId:partyRelationshipList[0].toPartyId, filterDate:filterDate, timePeriodTypeId:timePeriodTypeId, term:term]"/>
                    <set field="parentOrgPeriodList" from="parentPeriodsOut.timePeriodList"/>

                    <!-- if periods are from a parent org, create clone for this org -->
                    <set field="timePeriodList" from="[]"/>
                    <!-- go through periods largest to smallest to set parent -->
                    <set field="timePeriodTypeIdList" from="['FiscalYear', 'FiscalQuarter', 'FiscalMonth', 'FiscalBiWeek', 'FiscalWeek']"/>
                    <set field="parentPeriodId" from="null"/>
                    <iterate list="timePeriodTypeIdList" entry="timePeriodTypeId">
                        <filter-map-list list="parentOrgPeriodList" to-list="matchPeriodList">
                            <field-map field-name="timePeriodTypeId"/></filter-map-list>

                        <if condition="matchPeriodList">
                            <set field="parentOrgPeriod" from="matchPeriodList[0]"/>
                            <service-call name="mantle.party.TimeServices.getOrCreate#TimePeriod" out-map="createTpOut"
                                    in-map="[partyId:organizationPartyId, timePeriodTypeId:parentOrgPeriod.timePeriodTypeId,
                                        fromDate:parentOrgPeriod.fromDate, parentPeriodId:parentPeriodId]"/>
                            <if condition="!createTpOut.timePeriodId">
                                <return error="true" message="Get or create TimePeriod returned null value for partyId ${partyId}, timePeriodTypeId ${parentOrgPeriod.timePeriodTypeId}, fromDate ${parentOrgPeriod.fromDate}"/></if>
                            <entity-find-one entity-name="mantle.party.time.TimePeriod" value-field="timePeriod">
                                <field-map field-name="timePeriodId" from="createTpOut.timePeriodId"/></entity-find-one>
                            <set field="parentPeriodId" from="createTpOut.timePeriodId"/>

                            <if condition="!timePeriodTypeId || timePeriodTypeId == timePeriod.timePeriodTypeId">
                                <script>timePeriodList.add(timePeriod)</script></if>
                        </if>
                    </iterate>
                </if>
            </if>
            <if condition="!timePeriodList">
                <!-- still no time periods for current org, use check#NextFiscalTimePeriods to create -->
                <service-call name="mantle.ledger.LedgerServices.check#NextFiscalTimePeriods"
                        in-map="[organizationPartyId:organizationPartyId, basisDate:filterSqlDate]"/>
                <entity-find entity-name="mantle.party.time.TimePeriodAndType" list="timePeriodList">
                    <econdition field-name="fromDate" operator="less-equals" from="filterSqlDate" ignore-if-empty="true"/>
                    <econdition field-name="thruDate" operator="greater-equals" from="filterSqlDate" ignore-if-empty="true"/>
                    <econdition field-name="periodPurposeEnumId" value="Fiscal" ignore="timePeriodTypeId"/>
                    <econdition field-name="partyId" from="organizationPartyId"/>
                    <econdition field-name="timePeriodTypeId" ignore-if-empty="true"/>
                </entity-find>
            </if>
        </actions>
    </service>
    <service verb="check" noun="NextFiscalTimePeriods">
        <description>
            Ensure that at least current and next TimePeriods exist for FiscalMonth, FiscalQuarter (3 months), FiscalYear.
            If no time periods exist for current date look for most recent and create next.
            If still no time periods exist creates fiscal time periods based on calendar (ie fiscal year matches calendar year).
            If time periods do exist but not next time periods, adds next time period starting next day after current.
            This should be run once per month to ensure the next time period exists.
        </description>
        <in-parameters>
            <parameter name="organizationPartyId" required="true"/>
            <parameter name="basisDate" type="java.sql.Date" default="new java.sql.Date(ec.user.nowTimestamp.time)"/>
        </in-parameters>
        <actions>
            <script>basisCal = ec.user.getCalendarSafe(); basisCal.setTime(basisDate)</script>
            <entity-find-one entity-name="mantle.party.Organization" value-field="organization">
                <field-map field-name="partyId" from="organizationPartyId"/></entity-find-one>

            <!-- start with FiscalYear and go down so we have parentPeriodId -->
            <entity-find entity-name="mantle.party.time.TimePeriod" list="currentYearList">
                <econdition field-name="fromDate" operator="less-equals" from="basisDate"/>
                <econdition field-name="thruDate" operator="greater-equals" from="basisDate"/>
                <econdition field-name="partyId" from="organizationPartyId"/>
                <econdition field-name="timePeriodTypeId" value="FiscalYear"/>
            </entity-find>
            <if condition="!currentYearList"><then>
                <entity-find entity-name="mantle.party.time.TimePeriod" list="recentPeriodList">
                    <econdition field-name="partyId" from="organizationPartyId"/>
                    <econdition field-name="timePeriodTypeId" value="FiscalYear"/>
                    <order-by field-name="-fromDate"/>
                </entity-find>
                <if condition="recentPeriodList"><then>
                    <!-- If no current year exists look for most recent and create next until we have current -->
                    <set field="recentPeriod" from="recentPeriodList[0]"/>
                    <while condition="recentPeriod.thruDate &lt; basisDate">
                        <service-call name="mantle.party.TimeServices.create#TimePeriod" out-map="createTpOut"
                                in-map="[previousPeriodId:recentPeriod.timePeriodId]"/>
                        <entity-find-one entity-name="mantle.party.time.TimePeriod" value-field="recentPeriod">
                            <field-map field-name="timePeriodId" from="createTpOut.timePeriodId"/></entity-find-one>
                    </while>
                    <set field="yearPeriodId" from="recentPeriod.timePeriodId"/>
                </then><else>
                    <!-- no current year... assume fiscal year is calendar year and create one automatically -->
                    <script>yearFromCal = basisCal.clone(); yearFromCal.set(Calendar.DAY_OF_YEAR, 1)</script>
                    <service-call name="mantle.party.TimeServices.create#TimePeriod" out-map="createTpOut"
                            in-map="[partyId:organizationPartyId, timePeriodTypeId:'FiscalYear',
                                fromDate:new java.sql.Date(yearFromCal.getTimeInMillis())]"/>
                    <set field="yearPeriodId" from="createTpOut.timePeriodId"/>
                </else></if>
            </then><else>
                <set field="yearPeriodId" from="currentYearList[0].timePeriodId"/>
            </else></if>

            <!-- current quarter -->
            <entity-find entity-name="mantle.party.time.TimePeriod" list="currentQuarterList">
                <econdition field-name="fromDate" operator="less-equals" from="basisDate"/>
                <econdition field-name="thruDate" operator="greater-equals" from="basisDate"/>
                <econdition field-name="partyId" from="organizationPartyId"/>
                <econdition field-name="timePeriodTypeId" value="FiscalQuarter"/>
            </entity-find>
            <if condition="!currentQuarterList"><then>
                <entity-find entity-name="mantle.party.time.TimePeriod" list="recentPeriodList">
                    <econdition field-name="partyId" from="organizationPartyId"/>
                    <econdition field-name="timePeriodTypeId" value="FiscalQuarter"/>
                    <order-by field-name="-fromDate"/>
                </entity-find>
                <if condition="recentPeriodList"><then>
                    <!-- If no current quarter exists look for most recent and create next until we have current -->
                    <set field="recentPeriod" from="recentPeriodList[0]"/>
                    <while condition="recentPeriod.thruDate &lt; basisDate">
                        <service-call name="mantle.party.TimeServices.create#TimePeriod" out-map="createTpOut"
                                in-map="[previousPeriodId:recentPeriod.timePeriodId]"/>
                        <entity-find-one entity-name="mantle.party.time.TimePeriod" value-field="recentPeriod">
                            <field-map field-name="timePeriodId" from="createTpOut.timePeriodId"/></entity-find-one>
                    </while>
                    <set field="quarterPeriodId" from="recentPeriod.timePeriodId"/>
                </then><else>
                    <!-- no current quarter... assume fiscal year is calendar year with 4 3-month quarters and create one automatically -->
                    <script>quarterNumber = (int) (basisCal.get(Calendar.MONTH)/3)</script>
                    <script>quarterFromCal = basisCal.clone(); quarterFromCal.set(Calendar.MONTH, (quarterNumber * 3)); quarterFromCal.set(Calendar.DAY_OF_MONTH, 1)</script>
                    <service-call name="mantle.party.TimeServices.create#TimePeriod" out-map="createTpOut"
                            in-map="[partyId:organizationPartyId, timePeriodTypeId:'FiscalQuarter',
                                parentPeriodId:yearPeriodId, periodNum:(quarterNumber + 1),
                                fromDate:new java.sql.Date(quarterFromCal.getTimeInMillis())]"/>
                    <set field="quarterPeriodId" from="createTpOut.timePeriodId"/>
                </else></if>
            </then><else>
                <set field="quarterPeriodId" from="currentQuarterList[0].timePeriodId"/>
            </else></if>

            <!-- current month -->
            <entity-find entity-name="mantle.party.time.TimePeriod" list="currentMonthList">
                <econdition field-name="fromDate" operator="less-equals" from="basisDate"/>
                <econdition field-name="thruDate" operator="greater-equals" from="basisDate"/>
                <econdition field-name="partyId" from="organizationPartyId"/>
                <econdition field-name="timePeriodTypeId" value="FiscalMonth"/>
            </entity-find>
            <if condition="!currentMonthList"><then>
                <entity-find entity-name="mantle.party.time.TimePeriod" list="recentPeriodList">
                    <econdition field-name="partyId" from="organizationPartyId"/>
                    <econdition field-name="timePeriodTypeId" value="FiscalMonth"/>
                    <order-by field-name="-fromDate"/>
                </entity-find>
                <if condition="recentPeriodList"><then>
                    <!-- If no current quarter exists look for most recent and create next until we have current -->
                    <set field="recentPeriod" from="recentPeriodList[0]"/>
                    <while condition="recentPeriod.thruDate &lt; basisDate">
                        <service-call name="mantle.party.TimeServices.create#TimePeriod" out-map="createTpOut"
                                in-map="[previousPeriodId:recentPeriod.timePeriodId]"/>
                        <entity-find-one entity-name="mantle.party.time.TimePeriod" value-field="recentPeriod">
                            <field-map field-name="timePeriodId" from="createTpOut.timePeriodId"/></entity-find-one>
                    </while>
                    <set field="monthPeriodId" from="recentPeriod.timePeriodId"/>
                </then><else>
                    <!-- no current month... assume fiscal year is calendar year and create one automatically -->
                    <script>monthNumber = basisCal.get(Calendar.MONTH)</script>
                    <script>monthFromCal = basisCal.clone(); monthFromCal.set(Calendar.DAY_OF_MONTH, 1)</script>
                    <service-call name="mantle.party.TimeServices.create#TimePeriod" out-map="createTpOut"
                            in-map="[partyId:organizationPartyId, timePeriodTypeId:'FiscalMonth',
                                parentPeriodId:quarterPeriodId, periodNum:(monthNumber + 1),
                                fromDate:new java.sql.Date(monthFromCal.getTimeInMillis())]"/>
                    <set field="monthPeriodId" from="createTpOut.timePeriodId"/>
                </else></if>
            </then><else>
                <set field="monthPeriodId" from="currentMonthList[0].timePeriodId"/>
            </else></if>

            <!-- next year -->
            <!-- based on current year see if next exists and if not add one starting the day after and one year long -->
            <service-call name="mantle.party.TimeServices.getOrCreate#NextTimePeriod" out-map="nextYearOut"
                    in-map="[timePeriodId:yearPeriodId]"/>
            <set field="nextYearPeriodId" from="nextYearOut.nextTimePeriodId"/>

            <!-- next quarter, may be in current or next year -->
            <service-call name="mantle.party.TimeServices.getOrCreate#NextTimePeriod" out-map="nextQuarterOut"
                    in-map="[timePeriodId:quarterPeriodId]"/>
            <set field="nextQuarterPeriodId" from="nextQuarterOut.nextTimePeriodId"/>

            <!-- next month, may be in current or next quarter -->
            <service-call name="mantle.party.TimeServices.getOrCreate#NextTimePeriod" out-map="nextMonthOut"
                    in-map="[timePeriodId:monthPeriodId]"/>
            <set field="nextMonthPeriodId" from="nextMonthOut.nextTimePeriodId"/>
        </actions>
    </service>

    <service verb="close" noun="FinancialTimePeriod" transaction-timeout="1800" transaction="force-new">
        <in-parameters>
            <parameter name="timePeriodId" required="true"/>
            <parameter name="closePrevious" type="Boolean" default="false"/>
            <parameter name="closeChildren" type="Boolean" default="false"/>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="mantle.party.time.TimePeriod" value-field="timePeriod" for-update="true"/>
            <service-call name="mantle.party.TimeServices.get#TimePeriodInfo" in-map="[timePeriod:timePeriod]" out-map="periodInfo"/>
            <set field="fromTimestamp" from="periodInfo.fromTimestamp"/>
            <set field="thruTimestamp" from="periodInfo.thruTimestamp"/>

            <log message="Closing period ${timePeriodId} ${timePeriod.periodName}"/>

            <if condition="timePeriod.isClosed == 'Y'">
                <message error="true">Not closing period ${ec.resource.expand('TimePeriodNameTemplate','',timePeriod)}, already closed.</message></if>
            <if condition="ec.user.nowTimestamp.before(timePeriod.thruDate)">
                <message error="true">Not closing period ${ec.resource.expand('TimePeriodNameTemplate','',timePeriod)}, period has not ended (ends on ${timePeriod.thruDate}).</message></if>

            <!-- don't allow a period to close if the previous period is not closed -->
            <set field="previousTimePeriod" from="timePeriod.previous"/>
            <if condition="previousTimePeriod &amp;&amp; previousTimePeriod.isClosed != 'Y'">
                <if condition="closePrevious"><then>
                    <service-call name="mantle.ledger.LedgerServices.close#FinancialTimePeriod"
                            in-map="[timePeriodId:previousTimePeriod.timePeriodId, closePrevious:closePrevious, closeChildren:closeChildren]"/>
                </then><else>
                    <message error="true">Not closing period ${ec.resource.expand('TimePeriodNameTemplate','',timePeriod)}, previous period ${ec.resource.expand('TimePeriodNameTemplate','',previousTimePeriod)} not closed.</message>
                </else></if>
            </if>

            <!-- if any child periods make sure they are closed -->
            <entity-find entity-name="mantle.party.time.TimePeriod" list="childTimePeriodList">
                <econdition field-name="parentPeriodId" from="timePeriodId"/>
                <order-by field-name="fromDate"/>
            </entity-find>
            <iterate list="childTimePeriodList" entry="childTimePeriod"><if condition="childTimePeriod.isClosed != 'Y'">
                <if condition="closeChildren"><then>
                    <service-call name="mantle.ledger.LedgerServices.close#FinancialTimePeriod"
                            in-map="[timePeriodId:childTimePeriod.timePeriodId, closePrevious:closePrevious, closeChildren:closeChildren]"/>
                </then><else>
                    <message error="true">Not closing period ${ec.resource.expand('TimePeriodNameTemplate','',timePeriod)}, child period ${ec.resource.expand('TimePeriodNameTemplate','',childTimePeriod)} not closed.</message>
                </else></if>
            </if></iterate>

            <!-- make sure there are no unposted transactions within the time period -->
            <entity-find-count entity-name="mantle.ledger.transaction.AcctgTrans" count-field="unpostedTransCount">
                <econdition field-name="isPosted" operator="not-equals" value="Y" or-null="true"/>
                <econdition field-name="transactionDate" operator="greater-equals" from="fromTimestamp"/>
                <econdition field-name="transactionDate" operator="less-equals" from="thruTimestamp"/>
            </entity-find-count>
            <if condition="unpostedTransCount &gt; 0">
                <message error="true">Not closing period ${ec.resource.expand('TimePeriodNameTemplate','',timePeriod)}, found ${unpostedTransCount} unposted transactions in period.</message></if>

            <!-- check errors before continuing -->
            <check-errors/>

            <!-- first close the TimePeriod to avoid further postings -->
            <set field="timePeriod.isClosed" value="Y"/>
            <entity-update value-field="timePeriod"/>

            <!-- recalculate postedDebits, postedCredits, endingBalance, etc on GlAccountOrgTimePeriod records for this time period -->
            <service-call name="mantle.ledger.LedgerServices.recalculate#GlAccountOrgTimePeriodAmounts"
                    in-map="[timePeriodId:timePeriodId]"/>

            <message>Closed period ${timePeriod.periodName} and verified summary totals</message>
        </actions>
    </service>
    <service verb="recalculate" noun="GlAccountOrgTimePeriodAmounts">
        <description>Recalculate postedDebits, postedCredits, endingBalance on GlAccountOrgTimePeriod records for a time period</description>
        <in-parameters><parameter name="timePeriodId" required="true"/></in-parameters>
        <actions>
            <entity-find-one entity-name="mantle.party.time.TimePeriod" value-field="timePeriod" for-update="true"/>
            <service-call name="mantle.party.TimeServices.get#TimePeriodInfo" in-map="[timePeriod:timePeriod]" out-map="periodInfo"/>
            <set field="fromTimestamp" from="periodInfo.fromTimestamp"/>
            <set field="thruTimestamp" from="periodInfo.thruTimestamp"/>

            <!-- get or create the next TimePeriod (gets nextTimePeriodId, nextTimePeriod); always set its begin balance from this period's end balance -->
            <service-call name="mantle.party.TimeServices.getOrCreate#NextTimePeriod" out-map="context" in-map="[timePeriodId:timePeriodId]"/>

            <!-- get any existing subsequent time periods to update those as well (unlike next get only, no create) -->
            <set field="subsequentPeriodIds" from="[nextTimePeriodId]"/>
            <set field="curSubPeriodId" from="nextTimePeriodId"/>
            <script>
            while (curSubPeriodId) {
                Map subNextResult = ec.service.sync().name("mantle.party.TimeServices.get#NextTimePeriod")
                        .parameter("timePeriodId", curSubPeriodId).call()
                curSubPeriodId = subNextResult.nextTimePeriodId
                if (curSubPeriodId) subsequentPeriodIds.add(curSubPeriodId)
            }
            </script>

            <entity-find entity-name="mantle.ledger.transaction.AcctgTransAndEntrySummary" list="allTransSummaryList">
                <econdition field-name="organizationPartyId" from="timePeriod.partyId"/>
                <econdition field-name="transactionDate" operator="greater-equals" from="fromTimestamp"/>
                <econdition field-name="transactionDate" operator="less-equals" from="thruTimestamp"/>
                <econdition field-name="isPosted" value="Y"/>
                <select-field field-name="glAccountId,acctgTransTypeEnumId,debitCreditFlag,amount"/>
                <order-by field-name="glAccountId,acctgTransTypeEnumId,debitCreditFlag"/>
            </entity-find>
            <entity-find entity-name="mantle.ledger.account.GlAccountOrgTimePeriod" list="glAccountOrgTimePeriodList" for-update="true">
                <econdition field-name="organizationPartyId" from="timePeriod.partyId"/>
                <econdition field-name="timePeriodId"/>
            </entity-find>
            <iterate list="glAccountOrgTimePeriodList" entry="glAccountOrgTimePeriod">
                <set field="origGlAccountOrgTimePeriod" from="glAccountOrgTimePeriod.cloneValue()"/>

                <set field="transSummaryList" from="allTransSummaryList.cloneList().filterByAnd([glAccountId:glAccountOrgTimePeriod.glAccountId])"/>
                <!-- should have at most 2 results for each tx type: debitCreditFlag=D, debitCreditFlag=C -->
                <set field="postedDebits" from="0.0"/><set field="postedCredits" from="0.0"/>
                <set field="postedDebitsNoClosing" from="0.0"/><set field="postedCreditsNoClosing" from="0.0"/>
                <iterate list="transSummaryList" entry="transSummary"><if condition="transSummary.debitCreditFlag == 'D'"><then>
                    <set field="postedDebits" from="postedDebits + transSummary.amount"/>
                    <if condition="transSummary.acctgTransTypeEnumId != 'AttNetIncomeClosing'">
                        <set field="postedDebitsNoClosing" from="postedDebitsNoClosing + transSummary.amount"/></if>
                </then><else>
                    <set field="postedCredits" from="postedCredits + transSummary.amount"/>
                    <if condition="transSummary.acctgTransTypeEnumId != 'AttNetIncomeClosing'">
                        <set field="postedCreditsNoClosing" from="postedCreditsNoClosing + transSummary.amount"/></if>
                </else></if></iterate>
                <if condition="postedDebits != glAccountOrgTimePeriod.postedDebits">
                    <set field="glAccountOrgTimePeriod.postedDebits" from="postedDebits"/></if>
                <if condition="postedCredits != glAccountOrgTimePeriod.postedCredits">
                    <set field="glAccountOrgTimePeriod.postedCredits" from="postedCredits"/></if>
                <if condition="postedDebitsNoClosing != glAccountOrgTimePeriod.postedDebitsNoClosing">
                    <set field="glAccountOrgTimePeriod.postedDebitsNoClosing" from="postedDebitsNoClosing"/></if>
                <if condition="postedCreditsNoClosing != glAccountOrgTimePeriod.postedCreditsNoClosing">
                    <set field="glAccountOrgTimePeriod.postedCreditsNoClosing" from="postedCreditsNoClosing"/></if>

                <if condition="glAccountOrgTimePeriod.isModified()">
                    <!-- set the endingBalance based on beginningBalance, postedDebits, postedCredits -->
                    <entity-find-one entity-name="mantle.ledger.account.GlAccount" value-field="glAccount" cache="true">
                        <field-map field-name="glAccountId" from="glAccountOrgTimePeriod.glAccountId"/></entity-find-one>
                    <if condition="glAccount.isDebit.equals('Y')"><then>
                        <set field="glAccountOrgTimePeriod.endingBalance" from="(glAccountOrgTimePeriod.beginningBalance?:0.0) +
                                (glAccountOrgTimePeriod.postedDebits?:0.0) - (glAccountOrgTimePeriod.postedCredits?:0.0)"/>
                    </then><else>
                        <set field="glAccountOrgTimePeriod.endingBalance" from="(glAccountOrgTimePeriod.beginningBalance?:0.0) -
                                (glAccountOrgTimePeriod.postedDebits?:0.0) + (glAccountOrgTimePeriod.postedCredits?:0.0)"/>
                    </else></if>

                    <message>Found GlAccount Org TimePeriod (org ${glAccountOrgTimePeriod.organizationPartyId}, period ${glAccountOrgTimePeriod.timePeriodId}, account ${glAccountOrgTimePeriod.glAccountId}, is debit ${glAccount.isDebit}) with stale posted amounts; beginningBalance=${glAccountOrgTimePeriod.beginningBalance}, postedDebits was ${origGlAccountOrgTimePeriod.postedDebits} is ${glAccountOrgTimePeriod.postedDebits}, postedCredits was ${origGlAccountOrgTimePeriod.postedCredits} is ${glAccountOrgTimePeriod.postedCredits}, endingBalance was ${origGlAccountOrgTimePeriod.endingBalance} is ${glAccountOrgTimePeriod.endingBalance}</message>
                    <log message="In close#FinancialTimePeriod found GlAccountOrgTimePeriod (organizationPartyId=${glAccountOrgTimePeriod.organizationPartyId}, timePeriodId=${glAccountOrgTimePeriod.timePeriodId}, glAccountId=${glAccountOrgTimePeriod.glAccountId}, is debit ${glAccount.isDebit}) with wrong posted amounts; beginningBalance=${glAccountOrgTimePeriod.beginningBalance}, postedDebits was ${origGlAccountOrgTimePeriod.postedDebits} is ${glAccountOrgTimePeriod.postedDebits}, postedCredits was ${origGlAccountOrgTimePeriod.postedCredits} is ${glAccountOrgTimePeriod.postedCredits}, endingBalance was ${origGlAccountOrgTimePeriod.endingBalance} is ${glAccountOrgTimePeriod.endingBalance}"/>
                    <!-- update the record -->
                    <set field="glAccountOrgTimePeriod.balanceLastUpdated" from="ec.user.nowTimestamp"/>
                    <entity-update value-field="glAccountOrgTimePeriod"/>

                    <!-- TODO: also update postedBalance on GlAccountOrganization when we find a difference? -->
                </if>

                <!-- update balances for all existing subsequent periods -->
                <set field="lastGlAccountOrgTimePeriod" from="glAccountOrgTimePeriod"/>
                <iterate list="subsequentPeriodIds" entry="subsequentPeriodId">
                    <!-- for each GlAccountOrgTimePeriod record for current period, set beginning balance for next period
                        (creating new records if they don't exist) -->
                    <entity-find-one entity-name="mantle.ledger.account.GlAccountOrgTimePeriod" value-field="nextGlAccountOrgTimePeriod" for-update="true">
                        <field-map field-name="glAccountId" from="glAccountOrgTimePeriod.glAccountId"/>
                        <field-map field-name="organizationPartyId" from="timePeriod.partyId"/>
                        <field-map field-name="timePeriodId" from="subsequentPeriodId"/>
                    </entity-find-one>
                    <if condition="nextGlAccountOrgTimePeriod == null">
                        <entity-make-value entity-name="mantle.ledger.account.GlAccountOrgTimePeriod" value-field="nextGlAccountOrgTimePeriod"
                            map="[glAccountId:glAccountOrgTimePeriod.glAccountId,  organizationPartyId:timePeriod.partyId,
                                timePeriodId:subsequentPeriodId, beginningBalance:0.0, postedDebits:0.0, postedCredits:0.0,
                                postedDebitsNoClosing:0.0, postedCreditsNoClosing:0.0, endingBalance:0.0]"/>
                    </if>
                    <!-- add endingBalance to both just in case something has already been posted and added to next endingBalance -->
                    <set field="nextGlAccountOrgTimePeriod.endingBalance"
                            from="((nextGlAccountOrgTimePeriod.endingBalance ?: 0.0) - (nextGlAccountOrgTimePeriod.beginningBalance ?: 0.0)) +
                                lastGlAccountOrgTimePeriod.endingBalance"/>
                    <!-- set next beginningBalance from current endingBalance; do after set next endingBalance because it uses next beginningBalance if there is a value -->
                    <set field="nextGlAccountOrgTimePeriod.beginningBalance" from="lastGlAccountOrgTimePeriod.endingBalance"/>

                    <set field="nextGlAccountOrgTimePeriod.balanceLastUpdated" from="ec.user.nowTimestamp"/>
                    <entity-create value-field="nextGlAccountOrgTimePeriod" or-update="true"/>

                    <set field="lastGlAccountOrgTimePeriod" from="nextGlAccountOrgTimePeriod"/>
                </iterate>
            </iterate>
        </actions>
    </service>
    <service verb="reopen" noun="FinancialTimePeriod">
        <description>Service for period re-open (with special permission); don't allow reopening a period if the following period is closed</description>
        <in-parameters><parameter name="timePeriodId" required="true"/></in-parameters>
        <actions>
            <if condition="!ec.user.hasPermission('FISCAL_REOPEN')">
                <return error="true" message="Fiscal Period Reopen permission required"/></if>

            <entity-find-one entity-name="mantle.party.time.TimePeriod" value-field="timePeriod" for-update="true"/>

            <if condition="timePeriod.isClosed != 'Y'">
                <message error="true">Period ${ec.resource.expand('TimePeriodNameTemplate','',timePeriod)} is not closed, not reopening.</message></if>

            <!-- don't allow reopening a period if the following period is closed -->
            <entity-find entity-name="mantle.party.time.TimePeriod" list="nextPeriodList">
                <econdition field-name="previousPeriodId" from="timePeriodId"/></entity-find>
            <iterate list="nextPeriodList" entry="nextPeriod">
                <if condition="nextPeriod.isClosed == 'Y'">
                    <message error="true">Not reopening period ${ec.resource.expand('TimePeriodNameTemplate','',timePeriod)}, next period ${ec.resource.expand('TimePeriodNameTemplate','',nextPeriod)} is closed.</message></if>
            </iterate>

            <!-- check errors before continuing -->
            <check-errors/>

            <!-- reopen the TimePeriod -->
            <set field="timePeriod.isClosed" value="N"/>
            <entity-update value-field="timePeriod"/>
        </actions>
    </service>

    <service verb="create" noun="PeriodCloseAcctgTrans">
        <in-parameters>
            <parameter name="timePeriodId" required="true"/>
            <parameter name="postTransactions" type="Boolean" default="true"/>
            <parameter name="glJournalId"/>
            <parameter name="netIncomeGlAccountId"/>
        </in-parameters>
        <out-parameters><parameter name="acctgTransIdByClassId" type="Map"/></out-parameters>
        <actions>
            <entity-find-one entity-name="mantle.party.time.TimePeriod" value-field="timePeriod" for-update="true"/>
            <set field="organizationPartyId" from="timePeriod.partyId"/>
            <service-call name="mantle.party.TimeServices.get#TimePeriodInfo" in-map="[timePeriod:timePeriod]" out-map="periodInfo"/>
            <set field="transactionDate" from="periodInfo.thruTimestampLate"/>
            <if condition="ec.user.nowTimestamp &lt; periodInfo.thruTimestamp"><message>Fiscal period ${timePeriodId} has not yet ended (ends on ${timePeriod.thruDate})</message></if>
            <if condition="timePeriod.isClosed != 'Y'"><message>Fiscal period ${timePeriodId} is not yet closed, Period Closing transactions may be posted after a period is closed and posting period close transactions before a period is closed may result in non-zero balances, requiring another closing transaction</message></if>

            <if condition="!netIncomeGlAccountId">
                <entity-find entity-name="mantle.ledger.account.GlAccount" list="niGlAccountList">
                    <econdition field-name="glAccountClassEnumId" value="NET_INCOME"/>
                    <order-by field-name="accountCode"/>
                </entity-find>
                <set field="netIncomeGlAccountId" from="niGlAccountList ? niGlAccountList[0].glAccountId : null"/>
            </if>
            <if condition="!netIncomeGlAccountId"><return error="true" message="No Net Income account specified or found by class"/></if>

            <set field="acctgTransIdByClassId" from="[:]"/>
            <set field="tempAccountClasses" from="['REVENUE', 'COST_OF_SALES', 'EXPENSE', 'INCOME', 'NON_OP_EXPENSE']"/>
            <iterate list="tempAccountClasses" entry="tempAccountClass">
                <entity-find-one entity-name="moqui.basic.Enumeration" value-field="classEnum" cache="true">
                    <field-map field-name="enumId" from="tempAccountClass"/></entity-find-one>
                <service-call name="org.moqui.impl.BasicServices.find#EnumerationByParent" out-map="nestedEnumOut"
                        in-map="[parentEnumId:tempAccountClass, includeNested:true]"/>
                <set field="descEnumIdSet" from="nestedEnumOut.enumIdSet"/>
                <service-call name="mantle.ledger.LedgerServices.find#RootGlAccountClassEnum" out-map="rootEnumOut"
                        in-map="[glAccountClassEnumId:tempAccountClass]"/>
                <set field="isDebit" from="'DEBIT'.equals(rootEnumOut.rootGlAccountClassEnumId)"/>
                <if condition="rootEnumOut.isContra == 'Y'"><set field="isDebit" from="!isDebit"/></if>

                <!-- find GAOTP records for balances -->
                <entity-find entity-name="mantle.ledger.report.GlAccountOrgTimePeriodDetail" list="glAccountDetailList">
                    <econdition field-name="timePeriodId"/>
                    <econdition field-name="glAccountClassEnumId" operator="in" from="descEnumIdSet"/>
                    <select-field field-name="glAccountId,isDebit,endingBalance"/>
                </entity-find>

                <!-- see if we have any endingBalance values, if not no TX needed -->
                <set field="hasEndingBalances" from="false"/>
                <iterate list="glAccountDetailList" entry="glAccountDetail">
                    <if condition="glAccountDetail.endingBalance">
                        <set field="hasEndingBalances" from="true"/>
                        <break/>
                    </if>
                </iterate>
                <if condition="!hasEndingBalances">
                    <message>No transaction for ${classEnum.description}, ending balance of all accounts is zero</message>
                    <continue/>
                </if>

                <set field="txDesc" value="${classEnum.description} Closing for Period ${timePeriodId}"/>
                <service-call name="mantle.ledger.LedgerServices.create#AcctgTrans" out-map="createOut"
                        in-map="[acctgTransTypeEnumId:'AttNetIncomeClosing', organizationPartyId:organizationPartyId,
                            transactionDate:transactionDate, description:txDesc, glJournalId:glJournalId]"/>
                <set field="acctgTransId" from="createOut.acctgTransId"/>
                <script>acctgTransIdByClassId.put(tempAccountClass, acctgTransId)</script>

                <!-- entry for each GlAccount with a balance -->
                <set field="balanceTotal" from="0.0"/>
                <iterate list="glAccountDetailList" entry="glAccountDetail">
                    <if condition="!glAccountDetail.endingBalance"><continue/></if>
                    <set field="curEndingBalance" from="glAccountDetail.endingBalance"/>

                    <!-- if current account isDebit indicator opposite of  -->
                    <set field="isCurDebit" from="glAccountDetail.isDebit == 'Y'"/>
                    <set field="isCurContra" from="isDebit != isCurDebit"/>
                    <!-- <log level="warn" message="isDebit ${isDebit} glAccountId ${glAccountDetail.glAccountId} isDebit ${isCurDebit} isCurContra ${isCurContra} endingBalance ${glAccountDetail.endingBalance}"/> -->

                    <!-- create the TX entry, add to balance for balancing entry -->
                    <service-call name="mantle.ledger.LedgerServices.create#AcctgTransEntry"
                            in-map="[acctgTransId:acctgTransId, glAccountId:glAccountDetail.glAccountId,
                                debitCreditFlag:(isCurDebit ? 'C' : 'D'), amount:curEndingBalance]"/>
                    <set field="balanceTotal" from="isCurContra ? balanceTotal - curEndingBalance : balanceTotal + curEndingBalance"/>
                </iterate>

                <!-- balancing entry for the Net Income account -->
                <service-call name="mantle.ledger.LedgerServices.create#AcctgTransEntry"
                        in-map="[acctgTransId:acctgTransId, glAccountId:netIncomeGlAccountId,
                            debitCreditFlag:(isDebit ? 'D' : 'C'), amount:balanceTotal]"/>

                <message>Created transaction ${acctgTransId} ${ec.l10n.format(transactionDate, null)} for ${classEnum.description}, total balance ${ec.l10n.format(balanceTotal, '#,##0.00')}</message>
                <log message="Created transaction ${acctgTransId} ${ec.l10n.format(transactionDate, null)} for ${classEnum.description}, total balance ${ec.l10n.format(balanceTotal, '#,##0.00')}"/>

                <if condition="postTransactions">
                    <service-call name="mantle.ledger.LedgerServices.post#AcctgTrans" in-map="[acctgTransId:acctgTransId]"/></if>
            </iterate>

            <!-- recalc this period -->
            <service-call name="mantle.ledger.LedgerServices.recalculate#GlAccountOrgTimePeriodAmounts"
                    in-map="[timePeriodId:timePeriodId]"/>

            <!-- recalc parent/child periods; this query finds all parents, and using thruDate only last of children -->
            <entity-find entity-name="mantle.party.time.TimePeriodAndType" list="otherTimePeriodList">
                <econdition field-name="timePeriodId" operator="not-equals" from="timePeriodId"/>
                <econdition field-name="fromDate" operator="less-equals" from="timePeriod.thruDate"/>
                <econdition field-name="thruDate" operator="greater-equals" from="timePeriod.thruDate"/>
                <econdition field-name="periodPurposeEnumId" value="Fiscal"/>
                <econdition field-name="partyId" from="organizationPartyId"/>
            </entity-find>
            <iterate list="otherTimePeriodList" entry="otherTimePeriod">
                <service-call name="mantle.ledger.LedgerServices.recalculate#GlAccountOrgTimePeriodAmounts"
                        in-map="[timePeriodId:otherTimePeriod.timePeriodId]"/>
            </iterate>
        </actions>
    </service>

    <service verb="recalculate" noun="GlAccountOrgSummaries" semaphore="wait" semaphore-parameter="organizationPartyId"
             authenticate="anonymous-all" transaction-timeout="1800">
        <!-- NOTE: this service is not protected for authz/authc so that it can run in background; don't expose to unprotected access -->
        <in-parameters>
            <parameter name="organizationPartyId"/>
            <parameter name="lastRunTime" type="Timestamp"/>
            <parameter name="recalculateClosed" type="Boolean" default="false"/>
            <parameter name="deleteExisting" type="Boolean" default="false"/>
        </in-parameters>
        <actions>
            <set field="nowTimestamp" from="ec.user.nowTimestamp"/>
            <set field="nowDate" from="new java.sql.Date(nowTimestamp.time)"/>
            <set field="startTime" from="System.currentTimeMillis()"/>
            <set field="gaoUpdated" from="0"/>
            <set field="gaotpUpdated" from="0"/>

            <!-- find all open fiscal TimePeriods and use for GlAccountOrgTimePeriod records -->
            <entity-find entity-name="mantle.party.time.TimePeriodAndType" list="timePeriodList">
                <econdition field-name="fromDate" operator="less-equals" from="nowDate"/><!-- filter future periods, may remove this if future posting allowed -->
                <econdition field-name="periodPurposeEnumId" value="Fiscal"/>
                <econdition field-name="partyId" from="organizationPartyId" ignore-if-empty="true"/>
                <econdition field-name="isClosed" value="N" or-null="true" ignore="recalculateClosed"/><!-- want all past except closed -->
                <order-by field-name="fromDate"/>
            </entity-find>

            <!-- if no organizationPartyId specified find all orgs from open fiscal TimePeriods list (will only have single if specified) -->
            <set field="organizationPartyIds" from="new HashSet(timePeriodList*.partyId)"/>
            <set field="noTxOrgPartyIds" from="new HashSet()"/>
            <set field="glAccountIsDebitMap" from="[:]"/>

            <if condition="deleteExisting">
                <entity-find-count entity-name="mantle.ledger.account.GlAccountOrgTimePeriod" count-field="glaotpCount">
                    <econdition field-name="organizationPartyId" operator="in" from="organizationPartyIds"/>
                </entity-find-count>
                <log message="Before delete existing found ${glaotpCount} GlAccountOrgTimePeriod records for organizations ${organizationPartyIds}"/>
                <entity-delete-by-condition entity-name="mantle.ledger.account.GlAccountOrgTimePeriod">
                    <econdition field-name="organizationPartyId" operator="in" from="organizationPartyIds"/>
                    <econdition field-name="timePeriodId" operator="in" from="timePeriodList*.timePeriodId" ignore="recalculateClosed"/>
                </entity-delete-by-condition>
                <entity-find-count entity-name="mantle.ledger.account.GlAccountOrgTimePeriod" count-field="glaotpCount">
                    <econdition field-name="organizationPartyId" operator="in" from="organizationPartyIds"/>
                </entity-find-count>
                <log message="After delete existing found ${glaotpCount} GlAccountOrgTimePeriod records for organizations ${organizationPartyIds}"/>
            </if>

            <log message="[Recalculate GlAccountOrgSummaries] lastRunTime ${lastRunTime}, ${timePeriodList.size()} time periods, organizations: ${organizationPartyIds}"/>

            <!-- for specified or all org create/update GlAccountOrganization.postedBalance -->
            <!-- TODO: consider not doing this and find some other approach... goes back to all posted transactions; we have
                balanceLastUpdated but then would have to do query for each existing GlAccountOrganization record, and then an
                exclude by glAccountId query for the rest; may also not work if previous transactions posted in the still open period -->
            <!-- TODO IDEA: find latest closed period, start with its ending balance and query after its thru date -->
            <iterate list="organizationPartyIds" entry="organizationPartyId">
                <!-- see if there are any transactions since the lastRunTime time (if specified) -->
                <if condition="lastRunTime != null">
                    <entity-find entity-name="mantle.ledger.transaction.AcctgTrans" list="latestTransList" limit="1">
                        <econdition field-name="organizationPartyId"/>
                        <econdition field-name="isPosted" value="Y"/>
                        <econdition field-name="postedDate" operator="greater-equals" from="lastRunTime"/>
                    </entity-find>
                    <if condition="!latestTransList">
                        <!-- <log level="warn" message="TOREMOVE No transactions newer than ${lastRunTime} for org ${organizationPartyId}, not recalculating summary balances"/> -->
                        <script>noTxOrgPartyIds.add(organizationPartyId)</script>
                        <continue/>
                    </if>
                    <log message="[Recalculate GlAccountOrgSummaries] org ${organizationPartyId} has tx posted ${latestTransList[0].postedDate} so recalculating summaries"/>
                </if>

                <!-- do the big query to get latest totals -->
                <entity-find entity-name="mantle.ledger.transaction.AcctgTransAndEntrySummary" list="transSummaryList">
                    <econdition field-name="organizationPartyId"/>
                    <econdition field-name="isPosted" value="Y"/>
                    <select-field field-name="glAccountId,debitCreditFlag,amount"/>
                    <order-by field-name="glAccountId,debitCreditFlag"/>
                </entity-find>
                <script><![CDATA[
                    transSummaryListSize = transSummaryList.size()
                    for (int i = 0; i < transSummaryListSize; i++) {
                        Map transSummary = transSummaryList.get(i)
                        String glAccountId = transSummary.glAccountId

                        String isDebit = (String) glAccountIsDebitMap.get(glAccountId)
                        if (!isDebit) {
                            Map glAccount = ec.entity.find("mantle.ledger.account.GlAccount").condition("glAccountId", glAccountId).useCache(true).one()
                            isDebit = glAccount.isDebit
                        }
                        boolean isDebitAccount = isDebit.equals('Y')

                        Map debitTransSummary = null
                        boolean isCredit = transSummary.debitCreditFlag == 'C'
                        if (isCredit && (i + 1) < transSummaryListSize) {
                            debitTransSummary = transSummaryList.get(i + 1)
                            if (debitTransSummary.debitCreditFlag == 'D' && debitTransSummary.glAccountId == glAccountId) {
                                i++
                            } else {
                                debitTransSummary = null
                            }
                        }

                        Map glAccountOrganization = ec.entity.find("mantle.ledger.account.GlAccountOrganization")
                                .condition("glAccountId", glAccountId).condition("organizationPartyId", organizationPartyId)
                                .forUpdate(true).one()
                        if (glAccountOrganization == null) {
                            glAccountOrganization = ec.entity.makeValue("mantle.ledger.account.GlAccountOrganization")
                            glAccountOrganization.put("glAccountId", glAccountId)
                            glAccountOrganization.put("organizationPartyId", organizationPartyId)
                            glAccountOrganization.create()
                        }

                        BigDecimal postedBalance = BigDecimal.ZERO
                        if (isCredit) {
                            // based on account type add/subtract credit
                            if (isDebitAccount) postedBalance -= transSummary.amount
                            else postedBalance += transSummary.amount
                            // if debitTransSummary != null based on account type subtract/add debit
                            if (debitTransSummary != null) {
                                if (isDebitAccount) postedBalance += debitTransSummary.amount
                                else postedBalance -= debitTransSummary.amount
                            }
                        } else {
                            // based on account type subtract/add debit
                            if (isDebitAccount) postedBalance += transSummary.amount
                            else postedBalance -= transSummary.amount
                        }

                        glAccountOrganization.put("postedBalance", postedBalance)
                        glAccountOrganization.put("balanceLastUpdated", nowTimestamp)
                        glAccountOrganization.update()
                        gaoUpdated++
                    }
                ]]></script>
            </iterate>

            <iterate list="timePeriodList" entry="timePeriod">
                <if condition="noTxOrgPartyIds.contains(timePeriod.partyId)"><continue/></if>

                <set field="timePeriodId" from="timePeriod.timePeriodId"/>
                <set field="organizationPartyId" from="timePeriod.partyId"/>

                <service-call name="mantle.party.TimeServices.get#TimePeriodInfo" in-map="[timePeriod:timePeriod]" out-map="periodInfo"/>
                <set field="fromTimestamp" from="periodInfo.fromTimestamp"/>
                <set field="thruTimestamp" from="periodInfo.thruTimestamp"/>

                <!-- get or create the next TimePeriod (gets nextTimePeriodId, nextTimePeriod); always set its begin balance
                    from this period's end balance -->
                <service-call name="mantle.party.TimeServices.getOrCreate#NextTimePeriod" out-map="context"
                              in-map="[timePeriodId:timePeriodId]"/>

                <!-- get any existing subsequent time periods to update those as well (unlike next get only, no create) -->
                <set field="subsequentPeriodIds" from="[nextTimePeriodId]"/>
                <set field="curSubPeriodId" from="nextTimePeriodId"/>
                <script>
                    while (curSubPeriodId) {
                        Map subNextResult = ec.service.sync().name("mantle.party.TimeServices.get#NextTimePeriod")
                                .parameter("timePeriodId", curSubPeriodId).call()
                        curSubPeriodId = subNextResult.nextTimePeriodId
                        if (curSubPeriodId) subsequentPeriodIds.add(curSubPeriodId)
                    }
                </script>

                <set field="glAccountIdsWithTrans" from="new HashSet()"/>

                <!-- calc values for all accounts with entries -->
                <entity-find entity-name="mantle.ledger.transaction.AcctgTransAndEntrySummary" list="transSummaryList">
                    <econdition field-name="organizationPartyId"/>
                    <econdition field-name="transactionDate" operator="greater-equals" from="fromTimestamp"/>
                    <econdition field-name="transactionDate" operator="less-equals" from="thruTimestamp"/>
                    <econdition field-name="isPosted" value="Y"/>
                    <select-field field-name="glAccountId,acctgTransTypeEnumId,debitCreditFlag,amount"/>
                    <order-by field-name="glAccountId,acctgTransTypeEnumId,debitCreditFlag"/>
                </entity-find>
                <script><![CDATA[
                    LinkedHashMap<String, ArrayList<Map>> transSummariesByGlAccountId = new LinkedHashMap<>()
                    transSummaryListSize = transSummaryList.size()
                    for (int i = 0; i < transSummaryListSize; i++) {
                        Map transSummary = (Map) transSummaryList.get(i)
                        org.moqui.util.CollectionUtilities.addToListInMap(transSummary.glAccountId, transSummary, transSummariesByGlAccountId)
                    }

                    for (Map.Entry<String, ArrayList<Map>> byIdEntry in transSummariesByGlAccountId) {
                        ArrayList<Map> transSummaryList = (ArrayList<Map>) byIdEntry.value
                        String glAccountId = (String) byIdEntry.key
                        glAccountIdsWithTrans.add(glAccountId)

                        String isDebit = (String) glAccountIsDebitMap.get(glAccountId)
                        if (!isDebit) {
                            Map glAccount = ec.entity.find("mantle.ledger.account.GlAccount").condition("glAccountId", glAccountId).useCache(true).one()
                            isDebit = glAccount.isDebit
                        }
                        boolean isDebitAccount = isDebit.equals('Y')

                        org.moqui.entity.EntityValue glAccountOrgTimePeriod = ec.entity.find("mantle.ledger.account.GlAccountOrgTimePeriod")
                                .condition("glAccountId", glAccountId).condition("organizationPartyId", organizationPartyId)
                                .condition("timePeriodId", timePeriodId).forUpdate(true).one()
                        boolean foundRecord = true
                        if (glAccountOrgTimePeriod == null) {
                            foundRecord = false
                            glAccountOrgTimePeriod = ec.entity.makeValue("mantle.ledger.account.GlAccountOrgTimePeriod")
                            glAccountOrgTimePeriod.put("glAccountId", glAccountId)
                            glAccountOrgTimePeriod.put("organizationPartyId", organizationPartyId)
                            glAccountOrgTimePeriod.put("timePeriodId", timePeriodId)
                            glAccountOrgTimePeriod.put("beginningBalance", BigDecimal.ZERO)
                            glAccountOrgTimePeriod.create()
                        }

                        BigDecimal postedDebits = BigDecimal.ZERO
                        BigDecimal postedCredits = BigDecimal.ZERO
                        BigDecimal postedDebitsNoClosing = BigDecimal.ZERO
                        BigDecimal postedCreditsNoClosing = BigDecimal.ZERO

                        int transSummaryListSize = transSummaryList.size()
                        for (int i = 0; i < transSummaryListSize; i++) {
                            Map transSummary = (Map) transSummaryList.get(i)
                            if ('C'.equals(transSummary.debitCreditFlag)) {
                                postedCredits += (BigDecimal) transSummary.amount
                                if (!'AttNetIncomeClosing'.equals(transSummary.acctgTransTypeEnumId)) postedCreditsNoClosing += (BigDecimal) transSummary.amount
                            } else {
                                postedDebits += (BigDecimal) transSummary.amount
                                if (!'AttNetIncomeClosing'.equals(transSummary.acctgTransTypeEnumId)) postedDebitsNoClosing += (BigDecimal) transSummary.amount
                            }
                        }

                        // calculate endingBalance from beginningBalance and posted debits/credits
                        BigDecimal beginningBalance = glAccountOrgTimePeriod.beginningBalance ?: BigDecimal.ZERO
                        BigDecimal endingBalance
                        if (isDebitAccount) endingBalance = beginningBalance + postedDebits - postedCredits
                        else endingBalance = beginningBalance - postedDebits + postedCredits

                        Map origGlAccountOrgTimePeriod = glAccountOrgTimePeriod.getMap()
                        glAccountOrgTimePeriod.put("postedDebits", postedDebits)
                        glAccountOrgTimePeriod.put("postedCredits", postedCredits)
                        glAccountOrgTimePeriod.put("postedDebitsNoClosing", postedDebitsNoClosing)
                        glAccountOrgTimePeriod.put("postedCreditsNoClosing", postedCreditsNoClosing)
                        glAccountOrgTimePeriod.put("endingBalance", endingBalance)
                        glAccountOrgTimePeriod.put("balanceLastUpdated", nowTimestamp)
                        glAccountOrgTimePeriod.update()
                        gaotpUpdated++

                        if (foundRecord && (origGlAccountOrgTimePeriod.postedDebits != postedDebits ||
                                origGlAccountOrgTimePeriod.postedCredits != postedCredits ||
                                origGlAccountOrgTimePeriod.postedDebitsNoClosing != postedDebitsNoClosing ||
                                origGlAccountOrgTimePeriod.postedCreditsNoClosing != postedCreditsNoClosing)) {
                            ec.logger.info("In recalculate GLAOS updated account ${glAccountId} period ${timePeriodId} debit? ${isDebit} with wrong posted amounts; beginningBalance=${glAccountOrgTimePeriod.beginningBalance}, postedDebits was ${origGlAccountOrgTimePeriod.postedDebits} is ${glAccountOrgTimePeriod.postedDebits}, postedCredits was ${origGlAccountOrgTimePeriod.postedCredits} is ${glAccountOrgTimePeriod.postedCredits}, postedDebitsNoClosing was ${origGlAccountOrgTimePeriod.postedDebitsNoClosing} is ${glAccountOrgTimePeriod.postedDebitsNoClosing}, postedCreditsNoClosing was ${origGlAccountOrgTimePeriod.postedCreditsNoClosing} is ${glAccountOrgTimePeriod.postedCreditsNoClosing}, endingBalance was ${origGlAccountOrgTimePeriod.endingBalance} is ${glAccountOrgTimePeriod.endingBalance}")
                        }

                        // update balances for all existing subsequent periods
                        Map lastGlAccountOrgTimePeriod = glAccountOrgTimePeriod
                        for (String subsequentPeriodId in subsequentPeriodIds) {
                            Map nextGlAccountOrgTimePeriod = ec.entity.find("mantle.ledger.account.GlAccountOrgTimePeriod")
                                    .condition("glAccountId", glAccountId).condition("organizationPartyId", organizationPartyId)
                                    .condition("timePeriodId", subsequentPeriodId).forUpdate(true).one()
                            if (nextGlAccountOrgTimePeriod == null) {
                                nextGlAccountOrgTimePeriod = ec.entity.makeValue("mantle.ledger.account.GlAccountOrgTimePeriod")
                                nextGlAccountOrgTimePeriod.put("glAccountId", glAccountId)
                                nextGlAccountOrgTimePeriod.put("organizationPartyId", organizationPartyId)
                                nextGlAccountOrgTimePeriod.put("timePeriodId", subsequentPeriodId)
                                nextGlAccountOrgTimePeriod.put("beginningBalance", BigDecimal.ZERO)
                                nextGlAccountOrgTimePeriod.put("postedDebits", BigDecimal.ZERO)
                                nextGlAccountOrgTimePeriod.put("postedCredits", BigDecimal.ZERO)
                                nextGlAccountOrgTimePeriod.put("postedDebitsNoClosing", BigDecimal.ZERO)
                                nextGlAccountOrgTimePeriod.put("postedCreditsNoClosing", BigDecimal.ZERO)
                                nextGlAccountOrgTimePeriod.put("endingBalance", BigDecimal.ZERO)
                                nextGlAccountOrgTimePeriod.create()
                            }

                            nextGlAccountOrgTimePeriod.put("endingBalance", ((nextGlAccountOrgTimePeriod.endingBalance ?: 0.0) -
                                    (nextGlAccountOrgTimePeriod.beginningBalance ?: 0.0)) + lastGlAccountOrgTimePeriod.endingBalance)
                            nextGlAccountOrgTimePeriod.put("beginningBalance", lastGlAccountOrgTimePeriod.endingBalance)
                            nextGlAccountOrgTimePeriod.put("balanceLastUpdated", nowTimestamp)
                            nextGlAccountOrgTimePeriod.update()

                            lastGlAccountOrgTimePeriod = nextGlAccountOrgTimePeriod
                        }
                    }
                ]]></script>

                <!-- propagate end/begin values for accounts with no current entries, make sure in case got missed elsewhere (new period records, etc) -->
                <entity-find entity-name="mantle.ledger.account.GlAccountOrgTimePeriod" list="glAccountOrgTimePeriodList" for-update="true">
                    <econdition field-name="organizationPartyId" from="timePeriod.partyId"/>
                    <econdition field-name="timePeriodId"/>
                </entity-find>
                <iterate list="glAccountOrgTimePeriodList" entry="glAccountOrgTimePeriod">
                    <if condition="glAccountIdsWithTrans.contains(glAccountOrgTimePeriod.glAccountId)"><continue/></if>

                    <set field="lastGlAccountOrgTimePeriod" from="glAccountOrgTimePeriod"/>
                    <iterate list="subsequentPeriodIds" entry="subsequentPeriodId">
                        <!-- for each GlAccountOrgTimePeriod record for current period, set beginning balance for next period
                            (creating new records if they don't exist) -->
                        <entity-find-one entity-name="mantle.ledger.account.GlAccountOrgTimePeriod" value-field="nextGlAccountOrgTimePeriod" for-update="true">
                            <field-map field-name="glAccountId" from="glAccountOrgTimePeriod.glAccountId"/>
                            <field-map field-name="organizationPartyId" from="timePeriod.partyId"/>
                            <field-map field-name="timePeriodId" from="subsequentPeriodId"/>
                        </entity-find-one>
                        <if condition="nextGlAccountOrgTimePeriod == null">
                            <entity-make-value entity-name="mantle.ledger.account.GlAccountOrgTimePeriod" value-field="nextGlAccountOrgTimePeriod"
                                    map="[glAccountId:glAccountOrgTimePeriod.glAccountId, organizationPartyId:timePeriod.partyId,
                                        timePeriodId:subsequentPeriodId, beginningBalance:0.0, postedDebits:0.0, postedCredits:0.0,
                                        postedDebitsNoClosing:0.0, postedCreditsNoClosing:0.0, endingBalance:0.0]"/>
                        </if>
                        <!-- add endingBalance to both just in case something has already been posted and added to next endingBalance -->
                        <set field="nextGlAccountOrgTimePeriod.endingBalance" from="((nextGlAccountOrgTimePeriod.endingBalance ?: 0.0) -
                                (nextGlAccountOrgTimePeriod.beginningBalance ?: 0.0)) + lastGlAccountOrgTimePeriod.endingBalance"/>
                        <!-- set next beginningBalance from current endingBalance; do after set next endingBalance because it uses next beginningBalance if there is a value -->
                        <set field="nextGlAccountOrgTimePeriod.beginningBalance" from="lastGlAccountOrgTimePeriod.endingBalance"/>

                        <set field="nextGlAccountOrgTimePeriod.balanceLastUpdated" from="ec.user.nowTimestamp"/>
                        <entity-create value-field="nextGlAccountOrgTimePeriod" or-update="true"/>

                        <set field="lastGlAccountOrgTimePeriod" from="nextGlAccountOrgTimePeriod"/>
                    </iterate>
                </iterate>
            </iterate>

            <message>Updated GL Account Org Summaries for orgs ${organizationPartyIds} in ${System.currentTimeMillis() - startTime}ms; updated ${gaoUpdated} Organization and ${gaotpUpdated} Period summary records</message>
        </actions>
    </service>

    <!-- ========================================= -->
    <!-- ========== GL Journal Services ========== -->
    <!-- ========================================= -->

    <service verb="create" noun="GlJournal">
        <in-parameters>
            <auto-parameters include="nonpk"><exclude field-name="isPosted"/><exclude field-name="postedDate"/></auto-parameters>
            <parameter name="glJournalName" required="true"/>
        </in-parameters>
        <out-parameters><parameter name="glJournalId"/></out-parameters>
        <actions>
            <set field="isPosted" value="N"/>
            <service-call name="create#mantle.ledger.transaction.GlJournal" in-map="context" out-map="context"/>
        </actions>
    </service>
    <service verb="update" noun="GlJournal">
        <in-parameters>
            <parameter name="glJournalId" required="true"/>
            <auto-parameters include="nonpk"><exclude field-name="isPosted"/><exclude field-name="postedDate"/></auto-parameters>
        </in-parameters>
        <actions>
            <service-call name="update#mantle.ledger.transaction.GlJournal" in-map="context"/>
        </actions>
    </service>

    <!-- is this even needed for anything?
    <service verb="calculate" noun="GlJournalTrialBalance">
        <in-parameters><parameter name="glJournalId" required="true"/></in-parameters>
        <out-parameters>
            <parameter name="debitTotal" type="BigDecimal"/>
            <parameter name="creditTotal" type="BigDecimal"/>
            <parameter name="debitCreditDifference" type="BigDecimal"/>
        </out-parameters>
        <actions>
            <!- - implement this...? - ->
        </actions>
    </service>
    -->
    <service verb="post" noun="GlJournal">
        <description>Posts a GL Journal (GlJournal) by posting each transaction (AcctgTrans) in the journal.</description>
        <in-parameters>
            <parameter name="glJournalId" required="true"/>
            <parameter name="closeJournal" type="Boolean" default="false"/>
        </in-parameters>
        <actions>
            <!-- lock the Journal first -->
            <entity-find-one entity-name="mantle.ledger.transaction.GlJournal" value-field="glJournal" for-update="true"/>

            <entity-find entity-name="mantle.ledger.transaction.AcctgTrans" list="acctgTransList">
                <econdition field-name="glJournalId"/><order-by field-name="acctgTransId"/>
            </entity-find>
            <set field="txPostCount" from="0"/>
            <iterate list="acctgTransList" entry="acctgTrans">
                <service-call name="mantle.ledger.LedgerServices.post#AcctgTrans"
                        in-map="[acctgTransId:acctgTrans.acctgTransId]"/>
                <if condition="ec.message.hasError()"><then><return error="true"/></then>
                    <else><set field="txPostCount" from="txPostCount + 1"/></else></if>
            </iterate>
            <message>Posted ${txPostCount} transactions</message>

            <if condition="closeJournal">
                <set field="glJournal.isPosted" value="Y"/>
                <set field="glJournal.postedDate" from="ec.user.nowTimestamp"/>
                <entity-update value-field="glJournal"/>
            </if>
        </actions>
    </service>
</services>
