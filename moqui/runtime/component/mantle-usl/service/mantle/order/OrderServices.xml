<?xml version="1.0" encoding="UTF-8"?>
<!--
This software is in the public domain under CC0 1.0 Universal plus a 
Grant of Patent License.

To the extent possible under law, the author(s) have dedicated all
copyright and related and neighboring rights to this software to the
public domain worldwide. This software is distributed without any
warranty.

You should have received a copy of the CC0 Public Domain Dedication
along with this software (see the LICENSE.md file). If not, see
<http://creativecommons.org/publicdomain/zero/1.0/>.
-->
<services xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:noNamespaceSchemaLocation="http://moqui.org/xsd/service-definition-3.xsd">

    <!--
General Order Placement and eCommerce Usage

| create customer | PartyServices.create#Account |
| create/update/delete customer address | ContactServices.create#PostalAddress,
    .update#PartyPostalAddress |
| create/update/delete customer phone | ContactServices.create#TelecomNumber,
    .update#PartyTelecomNumber |
| create/update/delete customer credit card | PaymentMethodServices.create#CreditCard,
    .update#CreditCard |

| login: merge with previous open | merge#OrderItems |
| find customer open orders       | find#OpenOrders - TODO |

| init cart (auto on add to cart) | create#Order |
| add to cart                     | add#OrderProductQuantity, create#OrderItem |
| change cart quantity            | update#OrderProductQuantity, update#OrderItem |
| remove from cart                | delete#OrderItem |
| set billing and shipping info   | set#OrderBillingShippingInfo |
| split order                     | create#OrderPart |
| confirm/complete order          | place#Order |

| create order from shopping list (or other existing order) | clone#Order |

-->

    <!-- ========== Order Header and Part Services ========== -->

    <service verb="create" noun="Order">
        <description>
            Create an Order (OrderHeader and one OrderPart).
            All parameters are optional so that this can be called transparently to create a shell/empty order.
        </description>
        <in-parameters>
            <auto-parameters entity-name="mantle.order.OrderHeader" include="nonpk">
                <exclude field-name="remainingSubTotal" />
                <exclude field-name="grandTotal" />
            </auto-parameters>
            <auto-parameters entity-name="mantle.order.OrderPart" include="nonpk" />

            <parameter name="statusId" default-value="OrderOpen">
                <description>The initial statusId for both header and part.</description>
            </parameter>
            <parameter name="entryDate" type="Timestamp" default="ec.user.nowTimestamp" />
            <parameter name="visitId" default="ec.user.visitId" />
            <parameter name="enteredByPartyId" default="ec.user.userAccount?.partyId" />
            <parameter name="currencyUomId">
                <description>Defaults to PartyAcctgPreference.baseCurrencyUomId for whichever
                Party (customer or vendor) is an internal organization with an accounting preference record.</description>
            </parameter>
            <parameter name="orderRevision" type="Integer" default="1" />
        </in-parameters>
        <out-parameters>
            <parameter name="orderId" required="true" />
            <parameter name="orderPartSeqId" required="true" />
        </out-parameters>
        <actions>
            <if condition="productStoreId">
                <!-- Get some unspecified values from the ProductStore -->
                <entity-find-one entity-name="mantle.product.store.ProductStore"
                    value-field="productStore" />
                <set field="vendorPartyId" from="vendorPartyId ?: productStore?.organizationPartyId" />
                <set field="currencyUomId"
                    from="currencyUomId ?: productStore?.defaultCurrencyUomId" />
                <set field="salesChannelEnumId"
                    from="salesChannelEnumId ?: productStore?.defaultSalesChannelEnumId" />
                <set field="facilityId" from="facilityId ?: productStore?.inventoryFacilityId" />
                <set field="reservationAutoEnumId"
                    from="reservationAutoEnumId ?: productStore?.reservationAutoEnumId" />
                <set field="disablePromotions"
                    from="disablePromotions ?: productStore?.defaultDisablePromotions" />
                <set field="disableShippingCalc"
                    from="disableShippingCalc ?: productStore?.defaultDisableShippingCalc" />
                <set field="disableTaxCalc"
                    from="disableTaxCalc ?: productStore?.defaultDisableTaxCalc" />

                <!-- Customer - Bill To: set from store if set there, special case for drop-ship
                channel stores -->
                <entity-find entity-name="mantle.product.store.ProductStoreParty"
                    list="storeBillToList">
                    <date-filter />
                    <econdition field-name="productStoreId" />
                    <econdition field-name="roleTypeId" value="CustomerBillTo" />
                    <order-by field-name="-fromDate" />
                </entity-find>
                <if condition="storeBillToList">
                    <set field="billToPartyId" from="storeBillToList[0].partyId" />
                </if>
            </if>

            <if condition="!currencyUomId">
                <if condition="customerPartyId">
                    <service-call name="mantle.ledger.LedgerServices.find#PartyAcctgPreference"
                        out-map="context"
                        in-map="[organizationPartyId:customerPartyId]" />
                </if>
                <if condition="!partyAcctgPreference &amp;&amp; vendorPartyId">
                    <service-call name="mantle.ledger.LedgerServices.find#PartyAcctgPreference"
                        out-map="context"
                        in-map="[organizationPartyId:vendorPartyId]" />
                </if>
                <set field="currencyUomId" from="partyAcctgPreference?.baseCurrencyUomId" />
            </if>
            <!-- MAYBE: get this from configuration somewhere, needed beyond PartyAcctgPreference? -->
            <if condition="!currencyUomId">
                <set field="currencyUomId" value="USD" />
            </if>

            <service-call name="create#mantle.order.OrderHeader" in-map="context" out-map="context" />

            <if condition="customerPartyId">
                <!-- If customer is internal org and there is a facility get default ship dest
                contact info -->
                <entity-find entity-name="mantle.party.PartyRole" list="custOrgInternalList">
                    <econdition field-name="partyId" from="customerPartyId" />
                    <econdition field-name="roleTypeId" value="OrgInternal" />
                </entity-find>
                <if condition="custOrgInternalList">
                    <service-call name="mantle.facility.ContactServices.get#FacilityDefaultShipDest"
                        in-map="context" out-map="context" />
                </if>

                <!-- if customer Party.shippingInstructions populate if none specified -->
                <if condition="!shippingInstructions">
                    <entity-find-one entity-name="mantle.party.Party" value-field="customerParty">
                        <field-map field-name="partyId" from="customerPartyId" />
                    </entity-find-one>
                    <set field="shippingInstructions" from="customerParty?.shippingInstructions" />
                </if>

                <!-- if customer has a CustomerRequireSign setting use that for
                OrderPart.signatureRequiredEnumId -->
                <if condition="!signatureRequiredEnumId">
                    <set field="signReqSettingValue"
                        from="ec.service.sync().name('mantle.party.PartyServices.get#PartySettingValue')
                        .parameter('partySettingTypeId', 'CustomerRequireSign').parameter('partyId', customerPartyId).call()?.get('settingValue')" />
                    <if condition="signReqSettingValue &amp;&amp; signReqSettingValue != 'PsrNone'">
                        <set field="signatureRequiredEnumId" from="signReqSettingValue" />
                    </if>
                </if>
            </if>

            <service-call name="create#mantle.order.OrderPart" in-map="context" out-map="context" />

            <if condition="billToPartyId">
                <service-call name="create#mantle.order.OrderPartParty"
                    in-map="[orderId:orderId, orderPartSeqId:orderPartSeqId, partyId:billToPartyId, roleTypeId:'CustomerBillTo']" />
            </if>
        </actions>
    </service>
    <service verb="update" noun="OrderHeader">
        <in-parameters>
            <parameter name="orderId" required="true" />
            <auto-parameters entity-name="mantle.order.OrderHeader" include="nonpk">
                <exclude field-name="statusId" />
                <exclude field-name="orderRevision" />
                <exclude field-name="remainingSubTotal" />
                <exclude field-name="grandTotal" />
            </auto-parameters>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="mantle.order.OrderHeader" value-field="orderHeader" />
            <entity-set value-field="orderHeader" include="nonpk" set-if-empty="true" />
            <set field="orderHeader.orderRevision" from="orderHeader.orderRevision + 1" />
            <entity-update value-field="orderHeader" />
            <!-- <service-call name="update#mantle.order.OrderHeader" in-map="context"/> -->
        </actions>
    </service>
    <service verb="create" noun="OrderPart">
        <in-parameters>
            <parameter name="orderId" required="true" />
            <auto-parameters entity-name="mantle.order.OrderPart" include="nonpk" />
            <parameter name="statusId" default-value="OrderOpen" />
        </in-parameters>
        <out-parameters>
            <parameter name="orderPartSeqId" required="true" />
        </out-parameters>
        <actions>
            <!-- If customer is internal org and there is a facility get default ship dest contact
            info -->
            <entity-find-one entity-name="mantle.party.PartyRole" value-field="customerOrgRole">
                <field-map field-name="partyId" from="customerPartyId" />
                <field-map field-name="roleTypeId" value="OrgInternal" />
            </entity-find-one>
            <if condition="customerOrgRole != null">
                <service-call name="mantle.facility.ContactServices.get#FacilityDefaultShipDest"
                    in-map="context" out-map="context" />
            </if>

            <!-- if customer Party.shippingInstructions populate if none specified -->
            <if condition="!shippingInstructions &amp;&amp; customerPartyId">
                <entity-find-one entity-name="mantle.party.Party" value-field="customerParty">
                    <field-map field-name="partyId" from="customerPartyId" />
                </entity-find-one>
                <set field="shippingInstructions" from="customerParty?.shippingInstructions" />
            </if>

            <service-call name="create#mantle.order.OrderPart" in-map="context" out-map="context" />
        </actions>
    </service>
    <service verb="update" noun="OrderPart">
        <in-parameters>
            <parameter name="orderId" required="true" />
            <parameter name="orderPartSeqId" required="true" />
            <auto-parameters entity-name="mantle.order.OrderPart" include="nonpk" />
        </in-parameters>
        <actions>
            <entity-find-one entity-name="mantle.party.PartyRole" value-field="customerOrgRole">
                <field-map field-name="partyId" from="customerPartyId" />
                <field-map field-name="roleTypeId" value="OrgInternal" />
            </entity-find-one>
            <if condition="customerOrgRole != null">
                <service-call name="mantle.facility.ContactServices.get#FacilityDefaultShipDest"
                    in-map="context" out-map="context" />
            </if>
            <service-call name="update#mantle.order.OrderPart" in-map="context" out-map="context" />
        </actions>
    </service>

    <!-- ======================================== -->
    <!-- ========== OrderItem Services ========== -->
    <!-- ======================================== -->

    <service verb="get" noun="OrderItemTotal">
        <in-parameters>
            <parameter name="orderItem" type="EntityValue">
                <description>Can be a view-entity with OrderItem and at least
                the fields orderId, orderItemSeqId, unitAmount, quantity, selectedAmount.</description>
            </parameter>
            <parameter name="getChildrenTotals" type="Boolean" default="false" />
        </in-parameters>
        <out-parameters>
            <parameter name="combinedAmount" type="BigDecimal">
                <description>unitAmount (default 0.0) * selectedAmount (default 1.0)</description>
            </parameter>
            <parameter name="combinedQuantity" type="BigDecimal">
                <description>quantity (1.0 if null) * selectedAmount (default 1.0)</description>
            </parameter>
            <parameter name="itemTotal" type="BigDecimal" />
            <parameter name="childrenTotal" type="BigDecimal" />
            <parameter name="itemPlusChildrenTotal" type="BigDecimal" />
            <parameter name="childItemCount" type="Integer" />
            <parameter name="hasPromo" type="Boolean" />
            <parameter name="promoQuantityUsed" type="BigDecimal" />
            <parameter name="childOrderItemList" type="List">
                <parameter name="childOrderItem" type="Map" />
            </parameter>
        </out-parameters>
        <actions>
            <!-- for return value, unitAmount * selectedAmount -->
            <set field="combinedAmount"
                from="((orderItem.unitAmount ?: 0.0) * (orderItem.selectedAmount ?: 1.0))" />

            <set field="combinedQuantity"
                from="(orderItem.quantity != null ? orderItem.quantity : 1.0) * (orderItem.selectedAmount ?: 1.0)" />
            <!-- NOTE: also a sales/VAT tax calculation concern on item vs invoice level, but using
            2 digits so consistent across order, invoice, GL TX entry
                (tax should generally be calculated to 3 digits on the item level then summed and rounded to 2
            digits to get a tax total) -->
            <!-- NOTE: CurrencyRoundingMarker scale here may vary by currency, make configurable -->
            <set field="itemTotal"
                from="(combinedQuantity * (orderItem.unitAmount as BigDecimal ?: 0.0)).setScale(2, BigDecimal.ROUND_HALF_UP)" />
            <if condition="getChildrenTotals">
                <!-- recursively get total of child OrderItems -->
                <!-- don't use relationship, allow view-entities, etc <entity-find-related
                value-field="orderItem" relationship-name="Child#OrderItem"
                list="childOrderItemList"/> -->
                <entity-find entity-name="mantle.order.OrderItem" list="childOrderItemList">
                    <econdition field-name="orderId" from="orderItem.orderId" />
                    <econdition field-name="parentItemSeqId" from="orderItem.orderItemSeqId" />
                </entity-find>
                <set field="childrenTotal" from="0.0" />
                <set field="hasPromo" from="false" />
                <set field="promoQuantityUsed" from="0.0" />
                <iterate list="childOrderItemList" entry="childOrderItem">
                    <service-call name="mantle.order.OrderServices.get#OrderItemTotal"
                        out-map="getOitResult" out-map-add-to-existing="false"
                        in-map="[orderItem:childOrderItem, getChildrenTotals:true]" />
                    <set field="childrenTotal"
                        from="childrenTotal + getOitResult.itemPlusChildrenTotal" />
                    <if condition="childOrderItem.isPromo == 'Y' || getOitResult.hasPromo">
                        <set field="hasPromo" from="true" />
                    </if>
                    <set field="promoQuantityUsed"
                        from="promoQuantityUsed + (childOrderItem.promoQuantity ?: 0.0) + getOitResult.promoQuantityUsed" />
                </iterate>
                <set field="itemPlusChildrenTotal" from="itemTotal + childrenTotal" />
                <set field="childItemCount" from="childOrderItemList.size()" />
            </if>
        </actions>
    </service>

    <service verb="create" noun="OrderItem">
        <!-- NOTE had transaction="cache" but causing issues with updating single Payment amount and
        sometimes part/header total when there are multiple promotions active (ie New Customer and
        BOGO) -->
        <in-parameters>
            <parameter name="orderId" required="true" />
            <auto-parameters entity-name="mantle.order.OrderItem" include="nonpk" />
            <parameter name="orderPartSeqId" required="true" />
            <parameter name="itemTypeEnumId" default-value="ItemProduct" />
            <parameter name="quantity" type="BigDecimal" default="1" />
            <parameter name="requireInventory" type="Boolean">
                <description>If true make sure inventory is available, if false don't check. If null defer to ProductStore setting.</description>
            </parameter>
        </in-parameters>
        <out-parameters>
            <parameter name="orderItemSeqId" required="true" />
        </out-parameters>
        <actions>
            <set field="isProductItem" from="false" />
            <if condition="productId">
                <entity-find-one entity-name="mantle.product.Product" value-field="product"
                    cache="true" />
                <if condition="product == null">
                    <return error="true" message="Product ${productId} not found" />
                </if>
                <if condition="product.productTypeEnumId == 'PtVirtual'">
                    <return error="true"
                        message="Product ${productId} is a Virtual product and may not be used on an Order" />
                </if>

                <!-- Is this a product item? -->
                <entity-find entity-name="moqui.basic.EnumGroupMember" list="productItemTypeEgms"
                    cache="true">
                    <econdition field-name="enumGroupEnumId" value="EngItemsProduct" />
                </entity-find>
                <set field="productItemTypes" from="productItemTypeEgms*.enumId" />
                <set field="isProductItem" from="itemTypeEnumId in productItemTypes" />
            </if>

            <!-- if requireInventory check available inventory (for store/facility, product) -->
            <if condition="isProductItem &amp;&amp; quantity">
                <service-call name="mantle.order.OrderServices.check#AvailableInventory"
                    in-map="[productId:productId, quantity:quantity, orderId:orderId, orderPartSeqId:orderPartSeqId,
                            requireInventory:requireInventory]" />
            </if>

            <if condition="isProductItem">
                <then>
                    <!-- set some product item defaults -->
                    <if condition="product?.amountRequire == 'Y' &amp;&amp; !selectedAmount">
                        <return error="true"
                            message="Product ${productId} requires a selected amount" />
                    </if>
                    <if condition="!itemDescription">
                        <set field="itemDescription" from="product?.productName" />
                    </if>
                    <if condition="!quantityUomId">
                        <set field="quantityUomId" from="product?.amountUomId" />
                    </if>
                </then>
                <else-if condition="parentItemSeqId">
                    <!-- set productId from parent item -->
                    <if condition="!productId">
                        <entity-find-one entity-name="mantle.order.OrderItem"
                            value-field="parentItem">
                            <field-map field-name="orderId" />
                            <field-map field-name="orderItemSeqId" from="parentItemSeqId" />
                        </entity-find-one>
                        <set field="productId" from="parentItem?.productId" />
                    </if>
                </else-if>
            </if>

            <service-call name="create#mantle.order.OrderItem" in-map="context" out-map="context" />
        </actions>
    </service>
    <service verb="update" noun="OrderItem">
        <!-- NOTE had transaction="cache" but causing issues with updating single Payment amount and
        sometimes part/header total when there are multiple promotions active (ie New Customer and
        BOGO) -->
        <in-parameters>
            <auto-parameters include="pk" required="true" />
            <auto-parameters include="nonpk" />
            <parameter name="unitAmount_changeReason" />
            <parameter name="quantity_changeReason" />
            <parameter name="requireInventory" type="Boolean">
                <description>If true make sure inventory is available, if false don't check. If null defer to ProductStore setting.</description>
            </parameter>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="mantle.order.OrderItem" value-field="orderItem"
                for-update="true" />
            <set field="productId" from="productId ?: orderItem.productId" />
            <set field="quantity" from="quantity != null ? quantity : orderItem.quantity" />
            <set field="orderPartSeqId" from="orderPartSeqId ?: orderItem.orderPartSeqId" />

            <!-- is this a product item? -->
            <set field="isProductItem" from="false" />
            <if condition="productId">
                <if condition="productId != orderItem.productId">
                    <entity-find-one entity-name="mantle.product.Product" value-field="product"
                        cache="true" />
                    <if condition="product == null">
                        <return error="true" message="Product ${productId} not found" />
                    </if>
                    <if condition="product.productTypeEnumId == 'PtVirtual'">
                        <return error="true"
                            message="Product ${productId} is a Virtual product and may not be used on an Order" />
                    </if>
                </if>

                <entity-find entity-name="moqui.basic.EnumGroupMember" list="productItemTypeEgms"
                    cache="true">
                    <econdition field-name="enumGroupEnumId" value="EngItemsProduct" />
                </entity-find>
                <set field="productItemTypes" from="productItemTypeEgms*.enumId" />
                <set field="isProductItem"
                    from="productItemTypes.contains(orderItem.itemTypeEnumId)" />
            </if>

            <if condition="isProductItem">
                <then>
                    <!-- logic for product items -->

                    <!-- if requireInventory check available inventory (for store/facility, product) -->
                    <if condition="quantity">
                        <service-call name="mantle.order.OrderServices.check#AvailableInventory"
                            in-map="[productId:productId, quantity:quantity, orderId:orderId, orderPartSeqId:orderPartSeqId,
                            orderItemSeqId:orderItemSeqId, requireInventory:requireInventory]" />
                        <!-- don't let quantity go below quantity issued -->
                        <entity-find entity-name="mantle.product.issuance.AssetIssuance"
                            list="itemAssetIssuanceList">
                            <econdition field-name="orderId" />
                            <econdition field-name="orderItemSeqId" />
                        </entity-find>
                        <set field="itemQuantityIssued" from="0.0" />
                        <iterate list="itemAssetIssuanceList" entry="itemAssetIssuance">
                            <set field="itemQuantityIssued"
                                from="itemQuantityIssued + itemAssetIssuance.quantity" />
                        </iterate>
                        <if condition="quantity &lt; itemQuantityIssued">
                            <set field="quantity" from="itemQuantityIssued" />
                            <message type="warning" public="true">Quantity requested ${quantity} is less than quantity already shipped ${itemQuantityIssued}, setting to quantity shipped</message>
                        </if>
                    </if>

                    <!-- calculate the price based on quantity, etc, -->
                    <if condition="unitAmount == null &amp;&amp; isProductItem">
                        <then>
                            <entity-find-one entity-name="mantle.order.OrderHeader"
                                value-field="orderHeader" for-update="true" />
                            <set field="orderPart" from="orderItem.part" />

                            <!-- use PriceServices.get#OrderProductPrice instead of calling to get
                            price directly, for pricePurposeEnumId override for recurring orders and
                            other future behavior:
                    <service-call name="mantle.product.PriceServices.get#ProductPrice" out-map="priceMap"
                            in-map="[productId:productId, quantity:quantity, priceUomId:orderHeader.currencyUomId,
                                  productStoreId:orderHeader.productStoreId, customerPartyId:orderPart.customerPartyId,
                                  vendorPartyId:orderPart.vendorPartyId]"/>
                    -->
                            <service-call name="mantle.product.PriceServices.get#OrderProductPrice"
                                out-map="priceMap"
                                in-map="[productId:productId, quantity:quantity, orderId:orderId, orderPartSeqId:orderPartSeqId]" />


                            <set field="unitAmount" from="priceMap.price" />
                            <set field="unitListPrice" from="priceMap.listPrice" />
                            <set field="isModifiedPrice" value="N" />
                        </then>
                        <else>
                            <set field="isModifiedPrice" value="Y" />
                        </else>
                    </if>

                    <!-- on quantity changes adjust ShipmentItem/Source (only if some exist for
                    'open' shipments) -->
                    <if condition="quantity != null &amp;&amp; quantity != orderItem.quantity">
                        <entity-find entity-name="mantle.shipment.ShipmentAndItemSource"
                            list="shipmentItemSourceList">
                            <econdition field-name="orderId" />
                            <econdition field-name="orderItemSeqId" />
                            <econdition field-name="shipmentStatusId" operator="in"
                                value="ShipInput,ShipScheduled" />
                            <order-by field-name="shipmentId" />
                        </entity-find>
                        <if condition="shipmentItemSourceList">
                            <set field="sourceQuantityTotal" from="0" />
                            <iterate list="shipmentItemSourceList" entry="shipmentItemSource">
                                <set field="sourceQuantityTotal"
                                    from="sourceQuantityTotal + shipmentItemSource.quantity" />
                            </iterate>
                            <if condition="quantity &gt; sourceQuantityTotal">
                                <then>
                                    <set field="quantityIncrease"
                                        from="quantity - sourceQuantityTotal" />
                                    <!-- quantity increase, we don't know which shipment it should
                                    go on so just pick the first -->
                                    <set field="shipmentItemSource" from="shipmentItemSourceList[0]" />
                                    <service-call name="update#mantle.shipment.ShipmentItemSource"
                                        in-map="[shipmentItemSourceId:shipmentItemSource.shipmentItemSourceId,
                                          quantity:(shipmentItemSource.quantity + quantityIncrease),
                                          quantityNotHandled:(shipmentItemSource.quantityNotHandled + quantityIncrease)]" />

                                    <!-- also update ShipmentItem.quantity -->
                                    <entity-find-one entity-name="mantle.shipment.ShipmentItem"
                                        value-field="shipmentItem">
                                        <field-map field-name="shipmentId"
                                            from="shipmentItemSource.shipmentId" />
                                        <field-map field-name="productId" from="orderItem.productId" />
                                    </entity-find-one>
                                    <service-call name="update#mantle.shipment.ShipmentItem"
                                        in-map="[shipmentId:shipmentItem.shipmentId, productId:shipmentItem.productId,
                                          quantity:(shipmentItem.quantity + quantityIncrease)]" />
                                </then>
                                <else>
                                    <!-- a little more fun, deduct as available from each item in
                                    the list until all handled -->
                                    <set field="quantityReduceRemaining"
                                        from="sourceQuantityTotal - quantity" />
                                    <iterate list="shipmentItemSourceList"
                                        entry="shipmentItemSource">
                                        <set field="quantityReduce"
                                            from="quantityReduceRemaining &gt; shipmentItemSource.quantityNotHandled ?
                                    shipmentItemSource.quantityNotHandled : quantityReduceRemaining" />
                                        <if condition="quantityReduce == 0">
                                            <break />
                                        </if>
                                        <service-call
                                            name="update#mantle.shipment.ShipmentItemSource"
                                            in-map="[shipmentItemSourceId:shipmentItemSource.shipmentItemSourceId,
                                        quantity:(shipmentItemSource.quantity - quantityReduce),
                                        quantityNotHandled:(shipmentItemSource.quantityNotHandled - quantityReduce)]" />
                                        <set field="quantityReduceRemaining"
                                            from="quantityReduceRemaining - quantityReduce" />

                                        <!-- also update ShipmentItem.quantity -->
                                        <entity-find-one entity-name="mantle.shipment.ShipmentItem"
                                            value-field="shipmentItem">
                                            <field-map field-name="shipmentId"
                                                from="shipmentItemSource.shipmentId" />
                                            <field-map field-name="productId"
                                                from="orderItem.productId" />
                                        </entity-find-one>
                                        <set field="newItemQuantity"
                                            from="shipmentItem.quantity &gt; quantityReduce ?
                                    shipmentItem.quantity - quantityReduce : 0.0" />
                                        <service-call name="update#mantle.shipment.ShipmentItem"
                                            in-map="[shipmentId:shipmentItem.shipmentId, productId:shipmentItem.productId,
                                        quantity:newItemQuantity]" />
                                    </iterate>
                                </else>
                            </if>
                        </if>
                    </if>
                </then>
                <else>
                    <!-- logic for non-product items -->

                    <!-- defaults from parent item -->
                    <if condition="parentItemSeqId">
                        <!-- set productId from parent item -->
                        <if condition="!productId">
                            <entity-find-one entity-name="mantle.order.OrderItem"
                                value-field="parentItem">
                                <field-map field-name="orderId" />
                                <field-map field-name="orderItemSeqId" from="parentItemSeqId" />
                            </entity-find-one>
                            <set field="productId" from="parentItem?.productId" />
                        </if>
                    </if>
                </else>
            </if>

            <service-call name="update#mantle.order.OrderItem" in-map="context" />
            <!-- leave this out, may be nice to have a way to easily ignore messages from a specific
            service call: <message>Order item ${orderItemSeqId} updated</message> -->
        </actions>
    </service>
    <service verb="delete" noun="OrderItem">
        <in-parameters>
            <auto-parameters include="pk" required="true" />
        </in-parameters>
        <actions>
            <entity-find-one entity-name="mantle.order.OrderItem" value-field="orderItem" />
            <if condition="orderItem == null">
                <return message="Order ${orderId} item ${orderItemSeqId} not found" />
            </if>

            <!-- remove reservations -->
            <service-call name="mantle.product.AssetServices.remove#OrderItemReservations"
                in-map="context" />
            <!-- delete children -->
            <entity-find entity-name="mantle.order.OrderItem" list="childItemList">
                <econdition field-name="orderId" />
                <econdition field-name="parentItemSeqId" from="orderItemSeqId" />
            </entity-find>
            <iterate list="childItemList" entry="childItem">
                <service-call name="mantle.order.OrderServices.delete#OrderItem"
                    in-map="[orderId:orderId, orderItemSeqId:childItem.orderItemSeqId]" />
            </iterate>
            <!-- delete item -->
            <service-call name="delete#mantle.order.OrderItem" in-map="context" />

            <!-- explicitly call handle#OrderMajorChange to trigger promo, shipping, tax calc -->
            <service-call name="mantle.order.OrderServices.handle#OrderMajorChange"
                in-map="[orderId:orderItem.orderId, orderPartSeqId:orderItem.orderPartSeqId]" />
        </actions>
    </service>

    <service verb="recalc" noun="OrderItemAmount">
        <in-parameters>
            <parameter name="orderId" required="true" />
            <parameter name="orderItemSeqId" required="true" />
        </in-parameters>
        <actions>
            <entity-find-one entity-name="mantle.order.OrderItem" value-field="orderItem"
                for-update="true" />
            <if condition="orderItem.productId == null">
                <return />
            </if>

            <!-- Is this a product item? -->
            <entity-find entity-name="moqui.basic.EnumGroupMember" list="productItemTypeEgms"
                cache="true">
                <econdition field-name="enumGroupEnumId" value="EngItemsProduct" />
            </entity-find>
            <set field="productItemTypes" from="productItemTypeEgms*.enumId" />
            <if condition="!(orderItem.itemTypeEnumId in productItemTypes)">
                <return />
            </if>

            <service-call name="mantle.product.PriceServices.get#OrderProductPrice"
                out-map="priceOut"
                in-map="[productId:orderItem.productId, quantity:orderItem.quantity, orderId:orderId,
                        orderPartSeqId:orderItem.orderPartSeqId]" />

            <if condition="priceOut.price">
                <then>
                    <if condition="priceOut.price != orderItem.unitAmount">
                        <service-call name="update#mantle.order.OrderItem"
                            in-map="[orderId:orderId, orderItemSeqId:orderItem.orderItemSeqId,
                        unitAmount:priceOut.price, unitListPrice:priceOut.listPrice, isModifiedPrice:'N']" />
                    </if>
                </then>
                <else>
                    <message type="warning">No price found for Product ${orderItem.productId} on Order Item ${orderId}:${orderItemSeqId}, not resetting</message>
                </else>
            </if>
        </actions>
    </service>
    <service verb="recalc" noun="OrderPartItemAmounts">
        <in-parameters>
            <parameter name="orderId" required="true" />
            <parameter name="orderPartSeqId" required="true" />
        </in-parameters>
        <actions>
            <entity-find-one entity-name="mantle.order.OrderPart" value-field="orderPart"
                for-update="true" />

            <entity-find entity-name="moqui.basic.EnumGroupMember" list="productItemTypeEgms"
                cache="true">
                <econdition field-name="enumGroupEnumId" value="EngItemsProduct" />
            </entity-find>
            <set field="productItemTypes" from="productItemTypeEgms*.enumId" />

            <entity-find entity-name="mantle.order.OrderItem" list="orderItemList">
                <econdition field-name="orderId" />
                <econdition field-name="orderPartSeqId" />
                <econdition field-name="itemTypeEnumId" operator="in" from="productItemTypes" />
                <econdition field-name="productId" operator="is-not-null" />
                <order-by field-name="orderItemSeqId" />
            </entity-find>
            <iterate list="orderItemList" entry="orderItem">
                <service-call name="mantle.order.OrderServices.recalc#OrderItemAmount"
                    in-map="[orderId:orderItem.orderId, orderItemSeqId:orderItem.orderItemSeqId]" />
            </iterate>
        </actions>
    </service>

    <service verb="check" noun="AvailableInventory">
        <in-parameters>
            <parameter name="productId" required="true" />
            <parameter name="quantity" type="BigDecimal" required="true" />
            <parameter name="orderId" required="true" />
            <parameter name="orderPartSeqId" required="true" />
            <parameter name="orderItemSeqId" />
            <parameter name="requireInventory" type="Boolean">
                <description>If true make sure inventory is available, if false don't check. If null defer to ProductStore.requireInventory setting.</description>
            </parameter>

            <parameter name="orderHeader" type="EntityValue" />
            <parameter name="orderPart" type="EntityValue" />
            <parameter name="productStore" type="EntityValue" />
        </in-parameters>
        <actions>
            <if condition="requireInventory == null">
                <if condition="productStore == null">
                    <if condition="orderHeader == null">
                        <entity-find-one entity-name="mantle.order.OrderHeader"
                            value-field="orderHeader" />
                    </if>
                    <entity-find-one entity-name="mantle.product.store.ProductStore"
                        value-field="productStore" cache="true">
                        <field-map field-name="productStoreId" from="orderHeader.productStoreId" />
                    </entity-find-one>
                </if>
                <set field="requireInventory" from="productStore?.requireInventory == 'Y'" />
            </if>
            <!-- if available inventory not required return now -->
            <if condition="!requireInventory">
                <return />
            </if>
            <!-- get current available inventory -->
            <service-call name="mantle.product.AssetServices.get#AvailableForOrder"
                out-map="availOut"
                in-map="[productId:productId, orderId:orderId, orderPartSeqId:orderPartSeqId, orderItemSeqId:orderItemSeqId,
                        orderHeader:orderHeader, orderPart:orderPart]" />
            <set field="availableToPromiseTotal" from="availOut.availableToPromiseTotal" />
            <!-- if out of stock show one message, if insufficient available show another -->
            <if condition="availableToPromiseTotal &lt; quantity">
                <entity-find-one entity-name="mantle.product.Product" value-field="product"
                    cache="true" />
                <if condition="availableToPromiseTotal &lt;= 0.0">
                    <then>
                        <message public="true" type="warning">OrderInventoryNotAvailable</message>
                        <return error="true"
                            message="Inventory not available, not updating order ${orderId}:${orderPartSeqId} product ${productId} for quantity ${quantity}" />
                    </then>
                    <else>
                        <message public="true" type="warning">OrderInventoryInsufficient</message>
                        <return error="true"
                            message="Inventory insufficient, not updating order ${orderId}:${orderPartSeqId} product ${productId} for quantity ${quantity}" />
                    </else>
                </if>
            </if>
        </actions>
    </service>

    <!-- OrderProductQuantity aka "Cart" Services -->
    <service verb="add" noun="OrderProductQuantity" authenticate="anonymous-all">
        <!-- TODO had transaction="cache" but causing issues with updating single Payment amount and
        sometimes part/header total when there are multiple promotions active (ie New Customer and
        BOGO) -->
        <description>A service for an add-to-cart sort of operation, including:
            1. create an Order if no orderId is passed in
            2. determine the price to charge for the Product (and update based on quantity as needed)
            3. find a OrderItem matching the productId, and if found update quantity
            4. if no existing OrderItem is found create a new OrderItem
        </description>
        <in-parameters>
            <parameter name="orderId" />
            <parameter name="orderPartSeqId" />
            <!-- OrderHeader settings -->
            <parameter name="productStoreId" />
            <parameter name="currencyUomId" />
            <parameter name="salesChannelEnumId" />
            <!-- OrderPart settings -->
            <parameter name="customerPartyId" />
            <parameter name="carrierPartyId" />
            <parameter name="shipmentMethodEnumId" />

            <parameter name="productId" required="true" />
            <parameter name="description" />
            <parameter name="quantity" type="BigDecimal">
                <description>Defaults to 1 if addToQuantity=true (default)</description>
            </parameter>
            <parameter name="addToQuantity" type="Boolean" default="true">
                <description>If true add to existing quantity, if false set quantity on current item</description>
            </parameter>
            <parameter name="updateExisting" type="Boolean" default="true">
                <description>If true update existing item by productId, if false always create a new item</description>
            </parameter>
            <parameter name="requireInventory" type="Boolean">
                <description>If true make sure inventory is available, if false don't check. If null defer to ProductStore.requireInventory setting.</description>
            </parameter>
            <parameter name="itemTypeEnumId" default-value="ItemProduct" />
            <parameter name="unitAmount" type="BigDecimal" />
            <parameter name="standardCost" type="BigDecimal" />
            <parameter name="requiredByDate" type="Timestamp" />
            <parameter name="otherPartyProductId" />
        </in-parameters>
        <out-parameters>
            <parameter name="orderId" required="true" />
            <parameter name="orderPartSeqId" required="true" />
            <parameter name="orderItemSeqId" required="true" />
        </out-parameters>
        <actions>
            <if condition="quantity == null &amp;&amp; (addToQuantity || !updateExisting)">
                <set field="quantity" from="1.0" />
            </if>
            <!-- handle explicit zero quantity -->
            <if condition="(quantity == null || quantity &lt;= 0) &amp;&amp; updateExisting">
                <!-- do nothing if add -->
                <if condition="addToQuantity || !orderId">
                    <return />
                </if>
                <!-- in set mode remove the item -->
                <entity-find entity-name="mantle.order.OrderItem" list="orderItemList">
                    <econdition-object
                        field="[orderId:orderId, orderPartSeqId:orderPartSeqId, productId:productId,
                        productConfigSavedId:null, forAssetId:null, selectedAmount:null]" />
                </entity-find>
                <if condition="orderItemList">
                    <service-call name="mantle.order.OrderServices.delete#OrderItem"
                        in-map="[orderId:orderId, orderItemSeqId:orderItemList[0].orderItemSeqId]" />
                </if>
                <return />
            </if>

            <!-- lookup orderPartSeqId if not passed in -->
            <if condition="!orderPartSeqId &amp;&amp; orderId">
                <entity-find entity-name="mantle.order.OrderPart" list="orderPartList">
                    <econdition field-name="orderId" />
                    <select-field field-name="orderPartSeqId" />
                    <order-by field-name="orderPartSeqId" />
                </entity-find>
                <set field="orderPartSeqId" from="orderPartList?.first?.orderPartSeqId" />
            </if>

            <entity-find-one entity-name="mantle.order.OrderHeader" value-field="orderHeader"
                for-update="true" />
            <entity-find-one entity-name="mantle.order.OrderPart" value-field="orderPart"
                for-update="true" />

            <set field="productStoreId" from="productStoreId ?: orderHeader?.productStoreId" />
            <entity-find-one entity-name="mantle.product.store.ProductStore"
                value-field="productStore" />
            <set field="vendorPartyId"
                from="orderPart?.vendorPartyId ?: productStore?.organizationPartyId" />
            <set field="currencyUomId" from="currencyUomId ?: productStore?.defaultCurrencyUomId" />
            <set field="salesChannelEnumId"
                from="salesChannelEnumId ?: productStore?.defaultSalesChannelEnumId" />

            <!-- if orderPart.customerPartyId always use it, otherwise default to customerPartyId
            parameter or current user's partyId -->
            <set field="customerPartyId"
                from="(orderPart?.customerPartyId ?: customerPartyId) ?: ec.user.userAccount?.partyId" />

            <if condition="!orderId">
                <if condition="customerPartyId">
                    <entity-find entity-name="mantle.order.OrderHeaderAndPart"
                        list="existingOrderList">
                        <econdition field-name="statusId" value="OrderOpen" />
                        <econdition field-name="customerPartyId" />
                        <econdition field-name="vendorPartyId" ignore-if-empty="true" />
                        <econdition field-name="productStoreId" ignore-if-empty="true" />
                        <select-field field-name="orderId" />
                        <select-field field-name="orderPartSeqId" />
                        <order-by field-name="-entryDate" /><!-- get most recent open order -->
                    </entity-find>
                    <if condition="existingOrderList">
                        <set field="orderId" from="existingOrderList[0].orderId" />
                        <set field="orderPartSeqId" from="existingOrderList[0].orderPartSeqId" />

                        <entity-find-one entity-name="mantle.order.OrderHeader"
                            value-field="orderHeader" />
                        <entity-find-one entity-name="mantle.order.OrderPart"
                            value-field="orderPart" />
                    </if>
                </if>
                <!-- no existing open (cart) order found? create one -->
                <if condition="!orderId">
                    <service-call name="mantle.order.OrderServices.create#Order"
                        out-map="createOrderOut"
                        in-map="[currencyUomId:currencyUomId, productStoreId:productStoreId, salesChannelEnumId:salesChannelEnumId,
                                vendorPartyId:vendorPartyId, customerPartyId:customerPartyId, carrierPartyId:carrierPartyId,
                                shipmentMethodEnumId:shipmentMethodEnumId]" />
                    <set field="orderId" from="createOrderOut.orderId" />
                    <set field="orderPartSeqId" from="createOrderOut.orderPartSeqId" />

                    <entity-find-one entity-name="mantle.order.OrderHeader"
                        value-field="orderHeader" />
                    <entity-find-one entity-name="mantle.order.OrderPart" value-field="orderPart" />
                </if>
            </if>

            <!-- calculate the price based on quantity, etc, -->
            <if condition="unitAmount == null">
                <then>
                    <!-- use PriceServices.get#OrderProductPrice instead of calling to get price
                    directly, for pricePurposeEnumId override for recurring orders and other future
                    behavior:
                <service-call name="mantle.product.PriceServices.get#ProductPrice" out-map="priceMap"
                              in-map="[productId:productId, quantity:quantity, priceUomId:currencyUomId,
                         productStoreId:productStoreId, customerPartyId:customerPartyId, vendorPartyId:vendorPartyId]"/>
                -->
                    <service-call name="mantle.product.PriceServices.get#OrderProductPrice"
                        out-map="priceMap"
                        in-map="[productId:productId, quantity:quantity, orderId:orderId, orderPartSeqId:orderPartSeqId]" />

                    <set field="unitAmount" from="priceMap.price" />
                    <set field="unitListPrice" from="priceMap.listPrice" />
                    <set field="isModifiedPrice" value="N" />
                    <!--log
                    message="OrderProductQuantity Calculated Order ${orderId}:${orderPartSeqId}
                    Product ${productId} calculated unitAmount ${unitAmount} unitListPrice
                    ${unitListPrice} productStoreId ${productStoreId} customerPartyId
                    ${customerPartyId} vendorPartyId ${vendorPartyId}"/-->
                </then>
                <else>
                    <!--log
                    message="OrderProductQuantity Modified Order ${orderId}:${orderPartSeqId}
                    Product ${productId} manual unitAmount ${unitAmount}"/-->
                    <set field="isModifiedPrice" value="Y" />
                </else>
            </if>

            <!-- look up otherPartyProductId if not specified - first from ProductParty then
            ProductPrice -->
            <if condition="!otherPartyProductId &amp;&amp; productId">
                <entity-find-one entity-name="mantle.party.PartyRole" value-field="vendorOrgRole">
                    <field-map field-name="partyId" from="orderPart.vendorPartyId" />
                    <field-map field-name="roleTypeId" value="OrgInternal" />
                </entity-find-one>
                <if condition="vendorOrgRole != null &amp;&amp; orderPart.customerPartyId">
                    <then>
                        <entity-find entity-name="mantle.product.ProductParty"
                            list="otherPartyItemIdList" cache="false">
                            <date-filter />
                            <econdition field-name="productId" />
                            <econdition field-name="partyId" from="orderPart.customerPartyId" />
                            <econdition field-name="roleTypeId" value="Customer" />
                            <econdition field-name="otherPartyItemId" operator="is-not-null" />
                        </entity-find>
                        <if condition="otherPartyItemIdList">
                            <then>
                                <set field="otherPartyProductId"
                                    from="otherPartyItemIdList[0].otherPartyItemId" />
                            </then>
                            <else>
                                <!-- NOTE: consider removing this, ProductParty a better place, but
                                would not be backward compatible -->
                                <entity-find entity-name="mantle.product.ProductPrice"
                                    list="otherPartyItemIdList" cache="false">
                                    <date-filter />
                                    <econdition field-name="productId" />
                                    <econdition field-name="customerPartyId"
                                        from="orderPart.customerPartyId" />
                                    <econdition field-name="otherPartyItemId" operator="is-not-null" />
                                </entity-find>
                                <if condition="otherPartyItemIdList">
                                    <set field="otherPartyProductId"
                                        from="otherPartyItemIdList[0].otherPartyItemId" />
                                </if>
                            </else>
                        </if>
                    </then>
                    <else-if condition="vendorOrgRole == null &amp;&amp; orderPart.vendorPartyId">
                        <entity-find entity-name="mantle.product.ProductParty"
                            list="otherPartyItemIdList" cache="false">
                            <date-filter />
                            <econdition field-name="productId" />
                            <econdition field-name="partyId" from="orderPart.vendorPartyId" />
                            <econdition field-name="roleTypeId" value="Supplier" />
                            <econdition field-name="otherPartyItemId" operator="is-not-null" />
                        </entity-find>
                        <if condition="otherPartyItemIdList">
                            <then>
                                <set field="otherPartyProductId"
                                    from="otherPartyItemIdList[0].otherPartyItemId" />
                            </then>
                            <else>
                                <!-- NOTE: consider removing this, ProductParty a better place, but
                                would not be backward compatible -->
                                <entity-find entity-name="mantle.product.ProductPrice"
                                    list="otherPartyItemIdList" cache="false">
                                    <date-filter />
                                    <econdition field-name="productId" />
                                    <econdition field-name="vendorPartyId"
                                        from="orderPart.vendorPartyId" />
                                    <econdition field-name="otherPartyItemId" operator="is-not-null" />
                                </entity-find>
                                <if condition="otherPartyItemIdList">
                                    <set field="otherPartyProductId"
                                        from="otherPartyItemIdList[0].otherPartyItemId" />
                                </if>
                            </else>
                        </if>
                    </else-if>
                </if>
            </if>

            <!-- find an OrderItem for the productId and increment quantity if found, otherwise
            create OrderItem with quantity -->
            <entity-find entity-name="mantle.order.OrderItem" list="orderItemList">
                <econdition field-name="orderId" />
                <econdition field-name="orderPartSeqId" />
                <econdition field-name="productId" />
                <econdition field-name="itemTypeEnumId" value="ItemProduct" />
                <econdition field-name="fromAssetId" operator="is-null" />
                <econdition field-name="selectedAmount" operator="is-null" />
                <!-- for future reference: <econdition field-name="productConfigSavedId"
                operator="is-null"/> -->
                <order-by field-name="orderItemSeqId" />
            </entity-find>

            <if condition="orderItemList &amp;&amp; updateExisting">
                <then>
                    <set field="orderItem" from="orderItemList.first" />
                    <set field="orderItemSeqId" from="orderItem.orderItemSeqId" />
                    <set field="orderPartSeqId" from="orderItem.orderPartSeqId" set-if-empty="false" />
                    <set field="unitAmount"
                        from="unitAmount != null ? unitAmount : orderItem.unitAmount" />
                    <set field="standardCost"
                        from="standardCost != null ? standardCost : orderItem.standardCost" />
                    <set field="quantity"
                        from="addToQuantity ? quantity + orderItem.quantity : quantity" />
                    <!-- if requiredByDate on orderItem is less than that passed in, make sure to
                    use it instead of the new later one -->
                    <if
                        condition="orderItem.requiredByDate &amp;&amp; requiredByDate &amp;&amp; orderItem.requiredByDate &lt; requiredByDate">
                        <set field="requiredByDate" from="orderItem.requiredByDate" />
                    </if>
                    <service-call name="mantle.order.OrderServices.update#OrderItem"
                        in-map="context" />
                </then>
                <else>
                    <service-call name="mantle.order.OrderServices.create#OrderItem"
                        in-map="context" out-map="createOrderItemOut" />
                    <set field="orderItemSeqId" from="createOrderItemOut.orderItemSeqId" />
                </else>
            </if>
        </actions>
    </service>
    <service verb="update" noun="OrderProductQuantity" authenticate="anonymous-all">
        <!-- TODO had transaction="cache" but causing issues with updating single Payment amount and
        sometimes part/header total when there are multiple promotions active (ie New Customer and
        BOGO) -->
        <in-parameters>
            <parameter name="orderId" required="true" />
            <parameter name="orderItemSeqId" required="true" />
            <parameter name="quantity" type="BigDecimal" required="true" />
        </in-parameters>
        <actions>
            <entity-find-one entity-name="mantle.order.OrderHeader" value-field="orderHeader"
                for-update="true" />
            <if condition="quantity &lt;= 0">
                <service-call name="mantle.order.OrderServices.delete#OrderItem"
                    in-map="[orderId:orderId, orderItemSeqId:orderItemSeqId]" />
                <return />
            </if>

            <service-call name="mantle.order.OrderServices.update#OrderItem"
                in-map="[orderId:orderId, orderItemSeqId:orderItemSeqId, quantity:quantity]" />
        </actions>
    </service>
    <service verb="merge" noun="OrderItems">
        <in-parameters>
            <parameter name="orderId" required="true" />
            <parameter name="fromOrderId" required="true" />
        </in-parameters>
        <actions>
            <entity-find entity-name="mantle.order.OrderItem" list="orderItemList">
                <econdition field-name="orderId" from="fromOrderId" />
            </entity-find>
            <entity-find entity-name="moqui.basic.EnumGroupMember" list="productItemTypeEgms"
                cache="true">
                <econdition field-name="enumGroupEnumId" value="EngItemsProduct" />
            </entity-find>
            <set field="productItemTypes" from="productItemTypeEgms*.enumId" />
            <iterate list="orderItemList" entry="orderItem">
                <if
                    condition="!orderItem.productId || !productItemTypes.contains(orderItem.itemTypeEnumId)">
                    <continue />
                </if>
                <service-call name="mantle.order.OrderServices.add#OrderProductQuantity"
                    in-map="[orderId:orderId, productId:orderItem.productId, quantity:orderItem.quantity]" />
            </iterate>
        </actions>
    </service>

    <!-- ===================================================== -->
    <!-- ========== Order Billing/Shipping Services ========== -->
    <!-- ===================================================== -->

    <service verb="set" noun="OrderBillingShippingInfo">
        <in-parameters>
            <parameter name="orderId" required="true" />
            <parameter name="orderPartSeqId" />
            <parameter name="paymentId" />

            <parameter name="paymentInstrumentEnumId" />
            <parameter name="paymentMethodId" />
            <parameter name="toPaymentMethodId" />
            <parameter name="finAccountId" />
            <parameter name="shippingFacilityId" />
            <parameter name="shippingPostalContactMechId" />
            <parameter name="shippingTelecomContactMechId" />

            <parameter name="carrierAndShipmentMethod" />
            <parameter name="carrierPartyId" />
            <parameter name="shipmentMethodEnumId" />
        </in-parameters>
        <out-parameters>
            <parameter name="paymentId" />
        </out-parameters>
        <actions>
            <entity-find-one entity-name="mantle.order.OrderHeader" value-field="orderHeader"
                for-update="true" />
            <if condition="orderPartSeqId">
                <then>
                    <entity-find-one entity-name="mantle.order.OrderPart" value-field="orderPart"
                        for-update="true" />
                </then>
                <else>
                    <!-- just get the first part -->
                    <entity-find entity-name="mantle.order.OrderPart" list="orderPartList">
                        <econdition field-name="orderId" />
                        <order-by field-name="orderPartSeqId" />
                    </entity-find>
                    <set field="orderPart" from="orderPartList.first" />
                    <set field="orderPartSeqId" from="orderPart.orderPartSeqId" />
                </else>
            </if>

            <if condition="shippingPostalContactMechId &amp;&amp; !shippingTelecomContactMechId">
                <entity-find-one entity-name="mantle.party.contact.PostalAddress"
                    value-field="shippingPostalAddress">
                    <field-map field-name="contactMechId" from="shippingPostalContactMechId" />
                </entity-find-one>
                <set field="shippingTelecomContactMechId"
                    from="shippingPostalAddress.telecomContactMechId" />
            </if>

            <set field="canUpdateShippingInfo" from="true" />
            <!-- Find the shipment IDs for this order part -->
            <entity-find entity-name="mantle.shipment.ShipmentItemSource"
                list="shipmentItemSourceList">
                <econdition field-name="orderId" />
            </entity-find>
            <if condition="shipmentItemSourceList">
                <entity-find entity-name="mantle.order.OrderItem" list="partOrderItemList">
                    <econdition field-name="orderId" />
                    <econdition field-name="orderPartSeqId" />
                </entity-find>
                <script>
                    List orderItemSeqIdList = partOrderItemList.orderItemSeqId
                    partShipmentIdSet = new TreeSet()
                    for (Map sis in shipmentItemSourceList) if (sis.orderItemSeqId in orderItemSeqIdList) {
                        partShipmentIdSet.add(sis.shipmentId)
                    }
                </script>

                <!-- Update shipment method and shipping address on the last route segment(s) of
                this order part -->
                <iterate list="partShipmentIdSet" entry="shipmentId">
                    <entity-find-one entity-name="mantle.shipment.Shipment" value-field="shipment" />
                    <if condition="shipment.statusId in ['ShipRejected', 'ShipCancelled']">
                        <continue />
                    </if>
                    <if
                        condition="shipment.statusId in ['ShipPacked', 'ShipShipped', 'ShipDelivered']">
                        <message type="danger" public="true">Not updating shipping info, Shipment ${shipmentId} is ${shipment.status?.description}</message>
                        <set field="canUpdateShippingInfo" from="false" />
                    </if>
                </iterate>
            </if>

            <if condition="canUpdateShippingInfo">
                <if condition="partShipmentIdSet">
                    <iterate list="partShipmentIdSet" entry="shipmentId">
                        <entity-find entity-name="mantle.shipment.ShipmentRouteSegment"
                            list="shipmentRouteSegments">
                            <econdition field-name="shipmentId" />
                            <order-by field-name="-shipmentRouteSegmentSeqId" />
                        </entity-find>
                        <if condition="shipmentRouteSegments">
                            <set field="shipmentRouteSegment" from="shipmentRouteSegments[0]" />
                            <set field="shipmentRouteSegment.shipmentMethodEnumId"
                                from="shipmentMethodEnumId" set-if-empty="false" />
                            <set field="shipmentRouteSegment.destPostalContactMechId"
                                from="shippingPostalContactMechId" set-if-empty="false" />
                            <set field="shipmentRouteSegment.destTelecomContactMechId"
                                from="shippingTelecomContactMechId" set-if-empty="false" />
                            <entity-update value-field="shipmentRouteSegment" />
                        </if>
                    </iterate>
                </if>

                <if condition="shippingFacilityId">
                    <set field="orderPart.facilityId" from="shippingFacilityId" />
                </if>
                <if condition="shippingPostalContactMechId">
                    <set field="orderPart.postalContactMechId" from="shippingPostalContactMechId" />
                </if>
                <if condition="shippingTelecomContactMechId">
                    <set field="orderPart.telecomContactMechId" from="shippingTelecomContactMechId" />
                </if>
                <if condition="carrierAndShipmentMethod">
                    <set field="carrierPartyId" from="carrierAndShipmentMethod.split(':')[0]" />
                    <set field="shipmentMethodEnumId" from="carrierAndShipmentMethod.split(':')[1]" />
                </if>
                <if condition="carrierPartyId">
                    <set field="orderPart.carrierPartyId" from="carrierPartyId" />
                </if>
                <if condition="shipmentMethodEnumId">
                    <set field="orderPart.shipmentMethodEnumId" from="shipmentMethodEnumId" />
                </if>
                <entity-update value-field="orderPart" />
            </if>

            <if condition="paymentId">
                <entity-find-one entity-name="mantle.account.payment.Payment" value-field="payment" />
                <if
                    condition="payment != null &amp;&amp; (payment.orderId != orderId || payment.orderPartSeqId != orderPartSeqId)">
                    <!-- don't allow updating/hijacking this payment, whatever it was for -->
                    <set field="payment" from="null" />
                    <set field="paymentId" from="null" />
                </if>
            </if>

            <if condition="payment == null">
                <!-- try the first payment for the part -->
                <entity-find entity-name="mantle.account.payment.Payment" list="paymentList">
                    <econdition field-name="orderId" />
                    <econdition field-name="orderPartSeqId" />
                    <order-by field-name="paymentId" />
                </entity-find>
                <set field="payment" from="paymentList.first" />
            </if>

            <if condition="payment != null">
                <then>
                    <!-- update existing payment -->
                    <if condition="paymentMethodId">
                        <set field="payment.paymentMethodId" from="paymentMethodId" />
                    </if>
                    <if condition="toPaymentMethodId">
                        <set field="payment.toPaymentMethodId" from="toPaymentMethodId" />
                    </if>
                    <if condition="finAccountId">
                        <set field="payment.finAccountId" from="finAccountId" />
                    </if>
                    <entity-update value-field="payment" />
                    <set field="paymentId" from="payment.paymentId" />
                </then>
                <else-if condition="paymentMethodId || paymentInstrumentEnumId || finAccountId">
                    <!-- create a new Payment for the Order -->
                    <service-call name="mantle.order.OrderServices.add#OrderPartPayment"
                        out-map="context"
                        in-map="[orderId:orderId, orderPartSeqId:orderPartSeqId, paymentInstrumentEnumId:paymentInstrumentEnumId,
                            paymentMethodId:paymentMethodId, toPaymentMethodId:toPaymentMethodId, finAccountId:finAccountId]" />
                </else-if>
            </if>
        </actions>
    </service>
    <service verb="add" noun="OrderPartPayment">
        <in-parameters>
            <auto-parameters entity-name="mantle.account.payment.Payment" include="nonpk">
                <exclude field-name="amountUomId" />
                <exclude field-name="fromPartyId" />
                <exclude field-name="toPartyId" />
                <exclude field-name="acctgTransResultEnumId" />
                <exclude field-name="reconcileStatusId" />
                <exclude field-name="paymentMethodFileId" />
            </auto-parameters>
            <parameter name="orderId" required="true" />
            <parameter name="orderPartSeqId" required="true" />
            <parameter name="paymentTypeEnumId" default-value="PtInvoicePayment" />
            <parameter name="statusId" default-value="PmntPromised" />
            <parameter name="amount" type="BigDecimal">
                <description>Defaults to OrderPart.partTotal</description>
            </parameter>
            <parameter name="visitId" default="ec.user.visitId" />
            <parameter name="settlementTermId" />
        </in-parameters>
        <out-parameters>
            <parameter name="paymentId" />
        </out-parameters>
        <actions>
            <entity-find-one entity-name="mantle.order.OrderHeader" value-field="orderHeader" />
            <entity-find-one entity-name="mantle.order.OrderPart" value-field="orderPart" />

            <set field="fromPartyId" from="orderPart.customerPartyId" />
            <entity-find entity-name="mantle.order.OrderPartParty" list="billToList">
                <econdition field-name="orderId" />
                <econdition field-name="orderPartSeqId" />
                <econdition field-name="roleTypeId" value="CustomerBillTo" />
            </entity-find>
            <if condition="billToList">
                <set field="fromPartyId" from="billToList[0].partyId" />
            </if>

            <set field="amountUomId" from="orderHeader.currencyUomId" />
            <set field="toPartyId" from="orderPart.vendorPartyId" />

            <if condition="settlementTermId">
                <entity-find-one entity-name="mantle.account.invoice.SettlementTerm"
                    value-field="settlementTerm" cache="true" />
                <if condition="!settlementTerm?.orderPmtServiceRegisterId">
                    <message type="warning">Selected Term has no Auto Payments Service, creating a single Payment</message>
                </if>
            </if>

            <if condition="settlementTerm?.orderPmtServiceRegisterId">
                <then>
                    <service-call name="update#mantle.order.OrderPart"
                        in-map="[orderId:orderId, orderPartSeqId:orderPartSeqId, settlementTermId:settlementTermId]" />

                    <entity-find-one entity-name="moqui.service.ServiceRegister"
                        value-field="serviceRegister">
                        <field-map field-name="serviceRegisterId"
                            from="settlementTerm.orderPmtServiceRegisterId" />
                    </entity-find-one>
                    <script><![CDATA[
                    try {
                        ec.service.sync().name(serviceRegister.serviceName).parameters(context).softValidate(true).disableAuthz().call()
                        if (ec.message.hasError()) return
                    } catch (Throwable t) {
                        ec.logger.log(300, "Error calling auto order payments service for SettlementTerm ${settlementTermId}", t)
                    }
                ]]></script>
                </then>
                <else>
                    <service-call name="mantle.account.PaymentServices.create#Payment"
                        out-map="context"
                        in-map="context + [amount:amount, amountUomId:amountUomId, fromPartyId:fromPartyId, toPartyId:toPartyId]" />
                </else>
            </if>
        </actions>
    </service>

    <service verb="create" noun="OrderPayments50Split">
        <in-parameters>
            <auto-parameters entity-name="mantle.account.payment.Payment" include="nonpk">
                <exclude field-name="amountUomId" />
                <exclude field-name="acctgTransResultEnumId" />
                <exclude field-name="reconcileStatusId" />
                <exclude field-name="paymentMethodFileId" />
            </auto-parameters>
            <parameter name="orderId" required="true" />
            <parameter name="orderPartSeqId" />
            <parameter name="dueDate" type="Timestamp" />
            <parameter name="paymentTypeEnumId" default-value="PtInvoicePayment" />
            <parameter name="statusId" default-value="PmntPromised" />
            <parameter name="amount" type="BigDecimal">
                <description>Defaults to OrderPart.partTotal</description>
            </parameter>
            <parameter name="visitId" default="ec.user.visitId" />
            <parameter name="settlementTermId" />
        </in-parameters>
        <actions>
            <set field="amount" from="amount ?: orderPart.partTotal" />
            <if condition="amount == 0.0">
                <return message="Amount is 0.00, not creating Payments" />
            </if>

            <set field="advanceAmount" from="amount.divide(2.0, BigDecimal.ROUND_HALF_UP)" />
            <set field="remainingAmount" from="amount - advanceAmount" />

            <service-call name="mantle.account.PaymentServices.create#Payment" out-map="advanceOut"
                in-map="context + [amount:advanceAmount]" />
            <service-call name="mantle.account.PaymentServices.create#Payment"
                out-map="remainingOut"
                in-map="context + [amount:remainingAmount, dueDate:null]" />
        </actions>
    </service>

    <!-- ================================================== -->
    <!-- ========== Order Status Change Services ========== -->
    <!-- ================================================== -->

    <service verb="change" noun="OrderStatusInterface" type="interface">
        <in-parameters>
            <parameter name="orderId" required="true" />
            <parameter name="orderPartSeqId" />
        </in-parameters>
        <out-parameters>
            <parameter name="oldStatusId" />
            <parameter name="statusChanged" type="Boolean" />
        </out-parameters>
    </service>
    <service verb="update" noun="OrderStatus">
        <in-parameters>
            <parameter name="orderId" required="true" />
            <parameter name="orderPartSeqId" />
            <parameter name="statusId" required="true" />
            <parameter name="placedDate" type="Timestamp" />
            <parameter name="approvedDate" type="Timestamp" />
            <parameter name="completedDate" type="Timestamp" />
        </in-parameters>
        <out-parameters>
            <parameter name="oldStatusId" />
            <parameter name="statusChanged" type="Boolean" />
        </out-parameters>
        <actions>
            <entity-find-one entity-name="mantle.order.OrderHeader" value-field="orderHeader"
                for-update="true" />
            <entity-find entity-name="mantle.order.OrderPart" list="orderPartList" for-update="true">
                <econdition field-name="orderId" />
                <econdition field-name="orderPartSeqId" ignore-if-empty="true" />
            </entity-find>
            <iterate list="orderPartList" entry="orderPart">
                <service-call name="update#mantle.order.OrderPart" out-map="context"
                    in-map="[orderId:orderId, orderPartSeqId:orderPart.orderPartSeqId, statusId:statusId]" />
            </iterate>

            <!-- only update header status if no order part specified, or set status if all parts
            now same, etc like complete#OrderPart does -->
            <set field="updateMap" from="[orderId:orderId, statusId:statusId]" />
            <if condition="placedDate != null &amp;&amp; orderHeader.placedDate == null">
                <script>updateMap.put('placedDate', placedDate)</script>
            </if>
            <if condition="approvedDate != null &amp;&amp; orderHeader.approvedDate == null">
                <script>updateMap.put('approvedDate', approvedDate)</script>
            </if>
            <if condition="completedDate != null &amp;&amp; orderHeader.completedDate == null">
                <script>updateMap.put('completedDate', completedDate)</script>
            </if>
            <if condition="orderPartSeqId">
                <then>
                    <set field="allPartsSame" from="true" />
                    <entity-find entity-name="mantle.order.OrderPart" list="allPartList">
                        <econdition field-name="orderId" />
                    </entity-find>
                    <iterate list="allPartList" entry="orderPart">
                        <if condition="orderPart.statusId != statusId">
                            <set field="allPartsSame" from="false" />
                        </if>
                    </iterate>
                    <if condition="allPartsSame">
                        <service-call name="update#mantle.order.OrderHeader" out-map="context"
                            in-map="updateMap" />
                    </if>
                </then>
                <else>
                    <service-call name="update#mantle.order.OrderHeader" out-map="context"
                        in-map="updateMap" />
                </else>
            </if>
        </actions>
    </service>
    <service verb="propose" noun="Order">
        <implements service="mantle.order.OrderServices.change#OrderStatusInterface" />
        <actions>
            <service-call name="mantle.order.OrderServices.update#OrderStatus" out-map="context"
                in-map="context + [statusId:'OrderProposed']" />
        </actions>
    </service>
    <service verb="place" noun="Order">
        <!-- this used to use transaction="cache" but with record locks (for asset reservation) it
        is unreliable, gets old data from the TX cache -->
        <implements service="mantle.order.OrderServices.change#OrderStatusInterface" />
        <in-parameters>
            <parameter name="placedDate" type="Timestamp" default="ec.user.nowTimestamp" />
            <parameter name="requireInventory" type="Boolean">
                <description>If true make sure inventory is available, if false don't check. If null defer to ProductStore.requireInventory setting.</description>
            </parameter>
        </in-parameters>
        <actions>
            <service-call name="mantle.order.OrderServices.update#OrderStatus" out-map="context"
                in-map="context + [statusId:'OrderPlaced', placedDate:placedDate]" />

            <!-- if requireInventory make sure all is available (or was reserved) -->
            <!-- NOTE: do this AFTER the update#OrderStatus call so that transactional reservation
            is already done and we know if we were able to reserve all (or if reservation not done
            that all is available) -->
            <if condition="requireInventory == null">
                <if condition="orderHeader == null">
                    <entity-find-one entity-name="mantle.order.OrderHeader"
                        value-field="orderHeader" />
                </if>
                <entity-find-one entity-name="mantle.product.store.ProductStore"
                    value-field="productStore" cache="true">
                    <field-map field-name="productStoreId" from="orderHeader.productStoreId" />
                </entity-find-one>
                <set field="requireInventory" from="productStore?.requireInventory == 'Y'" />
            </if>
            <if condition="requireInventory">
                <entity-find entity-name="moqui.basic.EnumGroupMember" list="productItemTypeEgms"
                    cache="true">
                    <econdition field-name="enumGroupEnumId" value="EngItemsProduct" />
                </entity-find>
                <set field="productItemTypes" from="productItemTypeEgms*.enumId" />

                <if condition="orderHeader == null">
                    <entity-find-one entity-name="mantle.order.OrderHeader"
                        value-field="orderHeader" />
                </if>
                <entity-find entity-name="mantle.order.OrderItem" list="orderItemList">
                    <econdition field-name="orderId" />
                    <econdition field-name="orderPartSeqId" ignore-if-empty="true" />
                    <econdition field-name="productId" operator="is-not-null" />
                    <!-- order by productId to avoid deadlocks -->
                    <order-by field-name="productId" />
                </entity-find>

                <set field="allInventoryAvailable" from="true" />
                <iterate list="orderItemList" entry="orderItem">
                    <set field="isProductItem"
                        from="productItemTypes.contains(orderItem.itemTypeEnumId) &amp;&amp; orderItem.productId" />
                    <if condition="!isProductItem">
                        <continue />
                    </if>

                    <entity-find-one entity-name="mantle.product.Product" value-field="product"
                        cache="true">
                        <field-map field-name="productId" from="orderItem.productId" />
                    </entity-find-one>
                    <if
                        condition="!(product?.productTypeEnumId in ['PtAsset', 'PtDigitalAsset', 'PtAssetUse', 'PtPickAssembly'])">
                        <continue />
                    </if>

                    <!-- get current available inventory -->
                    <service-call name="mantle.product.AssetServices.get#AvailableForOrder"
                        out-map="availOut" out-map-add-to-existing="false"
                        in-map="[productId:orderItem.productId, orderId:orderId, orderPartSeqId:orderItem.orderPartSeqId,
                                orderItemSeqId:orderItem.orderItemSeqId, orderHeader:orderHeader]" />
                    <set field="availableToPromiseTotal" from="availOut.availableToPromiseTotal" />
                    <!-- if out of stock show one message, if insufficient available show another -->
                    <if condition="availableToPromiseTotal &lt; orderItem.quantity">
                        <set field="allInventoryAvailable" from="false" />
                        <if condition="availableToPromiseTotal &lt;= 0.0">
                            <then>
                                <message public="true" type="warning">OrderInventoryNotAvailable</message>
                            </then>
                            <else>
                                <message public="true" type="warning">OrderInventoryInsufficient</message>
                            </else>
                        </if>
                    </if>
                </iterate>

                <if condition="!allInventoryAvailable">
                    <!-- NOTE: return with error=true will cause TX rollback, including reservations -->
                    <return error="true"
                        message="Inventory required but not all available, not placing order ${orderId}" />
                </if>
            </if>

            <!-- New Customer: see if this is the first order for a customer -->
            <entity-find entity-name="mantle.order.OrderPart" list="orderPartList" for-update="true">
                <econdition field-name="orderId" />
                <econdition field-name="orderPartSeqId" ignore-if-empty="true" />
            </entity-find>
            <set field="customerPartyId"
                from="orderPartList ? orderPartList[0].customerPartyId : null" />
            <if condition="!customerPartyId">
                <return />
            </if><!-- if no customer we don't know if they are new -->
            <set field="includeStatuses"
                from="['OrderPlaced', 'OrderProcessing', 'OrderApproved', 'OrderSent', 'OrderCompleted', 'OrderHold']" />
            <entity-find-count entity-name="mantle.order.OrderHeaderAndPart"
                count-field="ordersCount">
                <econdition field-name="customerPartyId" />
                <econdition field-name="orderId" operator="not-equals" />
                <econdition field-name="statusId" operator="in" from="includeStatuses" />
                <!-- <econdition field-name="partStatusId" operator="in" from="includeStatuses"
                or-null="true"/> -->
            </entity-find-count>
            <if condition="ordersCount == 0">
                <iterate list="orderPartList" entry="orderPart">
                    <set field="orderPart.isNewCustomer" value="Y" />
                    <entity-update value-field="orderPart" />
                </iterate>
            </if>
        </actions>
    </service>
    <service verb="approve" noun="Order">
        <description>For manual order approval, requires ORDER_APPROVE permission.</description>
        <implements service="mantle.order.OrderServices.change#OrderStatusInterface" />
        <in-parameters>
            <parameter name="approvedDate" type="Timestamp" default="ec.user.nowTimestamp" />
        </in-parameters>
        <actions>
            <if condition="!ec.user.hasPermission('ORDER_APPROVE')">
                <return error="true" message="Order Approve permission required" />
            </if>
            <service-call name="mantle.order.OrderServices.update#OrderStatus" out-map="context"
                in-map="context + [statusId:'OrderApproved']" />
        </actions>
    </service>

    <service verb="autoApprove" noun="OrdersDelayed" authenticate="anonymous-all">
        <description>ServiceJob service (see default jobName 'autoApprove_OrdersDelayed') to try auto-approval for Placed orders in ProductStore with
            autoApproveDelay; can setup for specific store or all stores</description>
        <in-parameters>
            <parameter name="productStoreId">
                <description>If specified only run for this store, otherwise run for all stores</description>
            </parameter>
        </in-parameters>
        <actions>
            <entity-find entity-name="mantle.product.store.ProductStore" list="productStoreList">
                <econdition field-name="productStoreId" ignore-if-empty="true" />
                <econdition field-name="autoApproveDelay" operator="not-equals" from="0" />
            </entity-find>
            <iterate list="productStoreList" entry="productStore">
                <set field="delayMinutes" from="productStore.autoApproveDelay" />
                <script>
                    Calendar delayCal = ec.user.getCalendarSafe()
                    delayCal.add(Calendar.MINUTE, (int) -delayMinutes)
                    delayTimestamp = new Timestamp(delayCal.getTimeInMillis())
                </script>

                <entity-find entity-name="mantle.order.OrderHeader" list="orderList">
                    <econdition field-name="productStoreId" from="productStore.productStoreId" />
                    <econdition field-name="statusId" value="OrderPlaced" />
                    <econdition field-name="placedDate" operator="less-equals" from="delayTimestamp" />
                    <select-field field-name="orderId" />
                </entity-find>
                <if condition="orderList">
                    <log
                        message="Trying delayed auto-approve for store ${productStore.productStoreId} with ${delayMinutes}m delay (before ${delayTimestamp}) for ${orderList.size()} orders" />

                    <iterate list="orderList" entry="order">
                        <service-call name="mantle.order.OrderServices.autoApprove#Order"
                            in-map="[orderId:order.orderId]" />
                    </iterate>
                </if>
            </iterate>
        </actions>
    </service>
    <service verb="autoApprove" noun="Order">
        <description>
            If order is in Placed status and has sufficient Authorized, Delivered, or Confirmed payments for the grandTotal
            and hasn't been in Approved status before, and there are no pre-approve warnings from OrderInfoServices.check#OrderPreApprove
            then change the order status to Approved.

            This is called by SECA rule on OrderHeader change to OrderPlaced status, and directly in PaymentServices.authorize#OrderPayments.
        </description>
        <in-parameters>
            <parameter name="orderId" required="true" />
        </in-parameters>
        <actions>
            <entity-find-one entity-name="mantle.order.OrderHeader" value-field="orderHeader" />
            <if condition="orderHeader == null">
                <return error="true" message="Order ${orderId} not found" />
            </if>
            <if condition="orderHeader.statusId != 'OrderPlaced'">
                <return />
            </if>

            <entity-find entity-name="mantle.account.payment.Payment" list="paymentList">
                <econdition field-name="orderId" />
                <econdition field-name="statusId" operator="in"
                    from="['PmntAuthorized', 'PmntDelivered', 'PmntConfirmed']" />
            </entity-find>
            <set field="totalAuthorized" from="0.0" />
            <iterate list="paymentList" entry="payment">
                <set field="totalAuthorized" from="totalAuthorized + (payment.amount ?: 0.0)" />
            </iterate>

            <!-- if we authorized all set order to approved; don't use
            mantle.order.OrderServices.approve#Order service,
                meant for manual approval and requires permission -->
            <if condition="totalAuthorized &gt;= orderHeader.grandTotal">
                <!-- run approval checks, don't approve if any warnings or if order has been
                previously approved -->
                <service-call name="mantle.order.OrderInfoServices.check#OrderPreApprove"
                    in-map="[orderId:orderId]" out-map="checkOut" />
                <!-- if has been Approved before don't auto-approve -->
                <entity-find entity-name="moqui.entity.EntityAuditLog" list="statusHistoryList">
                    <econdition field-name="changedEntityName" value="mantle.order.OrderHeader" />
                    <econdition field-name="changedFieldName" value="statusId" />
                    <econdition field-name="pkPrimaryValue" from="orderId" />
                    <econdition field-name="newValueText" value="OrderApproved" />
                    <select-field field-name="auditHistorySeqId" />
                </entity-find>

                <if condition="!checkOut.approveWarnings &amp;&amp; !statusHistoryList">
                    <then>
                        <service-call name="mantle.order.OrderServices.update#OrderStatus"
                            in-map="[orderId:orderId, statusId:'OrderApproved', approvedDate:ec.user.nowTimestamp]" />
                    </then>
                    <else>
                        <log
                            message="Not auto-approving Order ${orderId} status history: ${statusHistoryList*.auditHistorySeqId}, warnings: ${checkOut.approveWarnings}" />
                    </else>
                </if>
            </if>
        </actions>
    </service>

    <service verb="isFulfilled" noun="OrderPart">
        <in-parameters>
            <parameter name="orderId" required="true" />
            <parameter name="orderPartSeqId" required="true" />
        </in-parameters>
        <out-parameters>
            <parameter name="isFulfilled" type="Boolean" />
        </out-parameters>
        <actions>
            <entity-find entity-name="mantle.product.subscription.Subscription"
                list="orderSubscriptionList">
                <econdition field-name="orderId" />
            </entity-find>
            <entity-find entity-name="mantle.order.OrderItemWorkEffort" list="orderWorkEffortList">
                <econdition field-name="orderId" />
                <econdition field-name="requiredWork" value="Y" />
            </entity-find>
            <entity-find entity-name="mantle.product.issuance.AssetIssuance"
                list="orderAssetIssuanceList">
                <econdition field-name="orderId" />
            </entity-find>
            <entity-find entity-name="mantle.product.receipt.AssetReceipt"
                list="orderAssetReceiptList">
                <econdition field-name="orderId" />
            </entity-find>

            <entity-find entity-name="mantle.order.OrderItem" list="orderItemList">
                <econdition field-name="orderId" />
                <econdition field-name="orderPartSeqId" />
                <order-by field-name="orderItemSeqId" />
            </entity-find>

            <entity-find entity-name="moqui.basic.EnumGroupMember" list="productItemTypeEgms"
                cache="true">
                <econdition field-name="enumGroupEnumId" value="EngItemsProduct" />
            </entity-find>
            <set field="productItemTypes" from="productItemTypeEgms*.enumId" />

            <!-- set to true, if any found not fulfilled will set to false -->
            <set field="isFulfilled" from="true" />
            <iterate list="orderItemList" entry="orderItem">
                <if
                    condition="orderItem.productId &amp;&amp; productItemTypes.contains(orderItem.itemTypeEnumId)">
                    <service-call name="mantle.order.OrderServices.isFulfilled#OrderItem"
                        out-map="itemOut" out-map-add-to-existing="false"
                        in-map="[orderId:orderId, orderItemSeqId:orderItem.orderItemSeqId, orderItem:orderItem,
                                orderSubscriptionList:orderSubscriptionList, orderWorkEffortList:orderWorkEffortList,
                                orderAssetIssuanceList:orderAssetIssuanceList, orderAssetReceiptList:orderAssetReceiptList]" />
                    <if condition="!itemOut.isFulfilled">
                        <set field="isFulfilled" from="false" />
                        <break />
                    </if>
                </if>
            </iterate>
        </actions>
    </service>
    <service verb="isFulfilled" noun="OrderItem">
        <in-parameters>
            <parameter name="orderId" required="true" />
            <parameter name="orderItemSeqId" required="true" />
            <!-- optional fields for efficiency, each if null will be queried -->
            <parameter name="orderItem" type="EntityValue" />
            <parameter name="orderSubscriptionList" type="List" />
            <parameter name="orderWorkEffortList" type="List" />
            <parameter name="orderAssetIssuanceList" type="List" />
            <parameter name="orderAssetReceiptList" type="List" />
        </in-parameters>
        <out-parameters>
            <parameter name="isFulfilled" type="Boolean" />
        </out-parameters>
        <actions>
            <if condition="orderItem == null">
                <entity-find-one entity-name="mantle.order.OrderItem" value-field="orderItem" />
            </if>

            <entity-find entity-name="moqui.basic.EnumGroupMember" list="productItemTypeEgms"
                cache="true">
                <econdition field-name="enumGroupEnumId" value="EngItemsProduct" />
            </entity-find>
            <set field="productItemTypes" from="productItemTypeEgms*.enumId" />

            <!-- set to true, if any evidence found that it is not fulfilled will set to false -->
            <set field="isFulfilled" from="true" />
            <if
                condition="orderItem.productId &amp;&amp; productItemTypes.contains(orderItem.itemTypeEnumId)">
                <then>
                    <entity-find-one entity-name="mantle.product.Product" value-field="product"
                        cache="true">
                        <field-map field-name="productId" from="orderItem.productId" />
                    </entity-find-one>

                    <if condition="product.productTypeEnumId in ['PtDigital', 'PtDigitalAsset']">
                        <if condition="orderSubscriptionList == null">
                            <entity-find entity-name="mantle.product.subscription.Subscription"
                                list="orderSubscriptionList">
                                <econdition field-name="orderId" />
                                <econdition field-name="orderItemSeqId" />
                            </entity-find>
                        </if>
                        <entity-find
                            entity-name="mantle.product.subscription.ProductSubscriptionResource"
                            list="productSubscriptionResourceList" cache="true">
                            <econdition field-name="productId" from="product.productId" />
                        </entity-find>
                        <iterate list="productSubscriptionResourceList"
                            entry="productSubscriptionResource">
                            <filter-map-list list="orderSubscriptionList"
                                to-list="currentSubscriptionList">
                                <field-map field-name="orderItemSeqId"
                                    from="orderItem.orderItemSeqId" />
                                <field-map field-name="subscriptionResourceId"
                                    from="productSubscriptionResource.subscriptionResourceId" />
                            </filter-map-list>
                            <if condition="!currentSubscriptionList">
                                <set field="isFulfilled" from="false" />
                            </if>
                        </iterate>
                    </if>
                    <if
                        condition="isFulfilled &amp;&amp; product.productTypeEnumId in ['PtAsset', 'PtDigitalAsset', 'PtAssetUse', 'PtPickAssembly']">
                        <if condition="orderAssetIssuanceList == null">
                            <then>
                                <entity-find entity-name="mantle.product.issuance.AssetIssuance"
                                    list="currentAssetIssuanceList">
                                    <econdition field-name="orderId" />
                                    <econdition field-name="orderItemSeqId" />
                                </entity-find>
                            </then>
                            <else>
                                <filter-map-list list="orderAssetIssuanceList"
                                    to-list="currentAssetIssuanceList">
                                    <field-map field-name="orderItemSeqId" />
                                </filter-map-list>
                            </else>
                        </if>
                        <if condition="orderAssetReceiptList == null">
                            <then>
                                <entity-find entity-name="mantle.product.issuance.AssetIssuance"
                                    list="currentAssetIssuanceList">
                                    <econdition field-name="orderId" />
                                    <econdition field-name="orderItemSeqId" />
                                </entity-find>
                            </then>
                            <else>
                                <filter-map-list list="orderAssetReceiptList"
                                    to-list="currentAssetReceiptList">
                                    <field-map field-name="orderItemSeqId" />
                                </filter-map-list>
                            </else>
                        </if>

                        <!-- add up quantity in currentAssetIssuanceList, compare to
                        orderItem.quantity -->
                        <set field="currentQuantityTotal" from="0" type="BigDecimal" />
                        <iterate list="currentAssetIssuanceList" entry="currentAssetIssuance">
                            <set field="currentQuantityTotal"
                                from="currentQuantityTotal + currentAssetIssuance.quantity" />
                        </iterate>
                        <iterate list="currentAssetReceiptList" entry="currentAssetReceipt">
                            <set field="currentQuantityTotal"
                                from="currentQuantityTotal + currentAssetReceipt.quantityAccepted" />
                        </iterate>
                        <if condition="currentQuantityTotal &lt; orderItem.quantity">
                            <set field="isFulfilled" from="false" />
                        </if>
                    </if>

                    <!-- check WorkEfforts (OrderItemWorkEffort with requiredWork == 'Y') for all
                    Product types,
                    if any work efforts not cancelled or completed consider item not fulfilled -->
                    <if condition="isFulfilled">
                        <!-- NOTE: this could be constrained only to WorkEfforts associated with the
                        OrderItem's Product, but don't to support arbitrary tasks required for
                        OrderItems -->
                        <if condition="orderWorkEffortList == null">
                            <then>
                                <entity-find entity-name="mantle.order.OrderItemWorkEffort"
                                    list="itemWorkEffortList">
                                    <econdition field-name="orderId" />
                                    <econdition field-name="orderItemSeqId" />
                                    <econdition field-name="requiredWork" value="Y" />
                                </entity-find>
                            </then>
                            <else>
                                <filter-map-list list="orderWorkEffortList"
                                    to-list="itemWorkEffortList">
                                    <field-map field-name="orderItemSeqId" />
                                </filter-map-list>
                            </else>
                        </if>

                        <if condition="itemWorkEffortList">
                            <set field="workEffortIdList" from="itemWorkEffortList*.workEffortId" />
                            <entity-find entity-name="mantle.work.effort.WorkEffort"
                                list="workEffortList">
                                <econdition field-name="workEffortId" operator="in"
                                    from="workEffortIdList" />
                                <select-field field-name="workEffortId,statusId" />
                            </entity-find>
                            <iterate list="workEffortList" entry="workEffort">
                                <if
                                    condition="!(workEffort.statusId in ['WeComplete', 'WeClosed', 'WeCancelled'])">
                                    <set field="isFulfilled" from="false" />
                                    <break />
                                </if>
                            </iterate>
                        </if>
                    </if>
                </then>
                <else>
                    <!-- TODO: for non-product items look for parent that is fulfilled? -->
                    <!-- NOTE 2021-02-12 this service is only used to check isFulfilled#OrderPart so
                    far, so this alternate definition of fulfilled isn't needed -->
                </else>
            </if>
        </actions>
    </service>
    <service verb="checkComplete" noun="OrderPart">
        <description>Checks to see if all items in the order part have been shipped and/or digitally (including
            subscription) fulfilled, and if so complete the order part. Also checks for receipt of purchase order items.</description>
        <in-parameters>
            <parameter name="orderId" required="true" />
            <parameter name="orderPartSeqId" required="true" />
        </in-parameters>
        <out-parameters>
            <parameter name="oldStatusId" />
            <parameter name="statusChanged" type="Boolean" />
        </out-parameters>
        <actions>
            <entity-find-one entity-name="mantle.order.OrderPart" value-field="orderPart" />
            <if condition="orderPart == null">
                <return error="true" message="Order Part ${orderId}:${orderPartSeqId} not found" />
            </if>
            <if condition="!(orderPart?.statusId in ['OrderApproved', 'OrderSent'])">
                <return />
            </if>

            <service-call name="mantle.order.OrderServices.isFulfilled#OrderPart"
                out-map="isFulfilledOut"
                in-map="[orderId:orderId, orderPartSeqId:orderPartSeqId]" />

            <if condition="isFulfilledOut.isFulfilled">
                <service-call name="mantle.order.OrderServices.complete#OrderPart" out-map="context"
                    in-map="context" />
            </if>
        </actions>
    </service>
    <service verb="checkStillComplete" noun="Order">
        <in-parameters>
            <parameter name="orderId" />
        </in-parameters>
        <out-parameters>
            <parameter name="oldStatusId" />
            <parameter name="statusChanged" type="Boolean" />
        </out-parameters>
        <actions>
            <entity-find-one entity-name="mantle.order.OrderHeader" value-field="orderHeader" />
            <if condition="orderHeader == null">
                <return error="true" message="Order ${orderId} not found" />
            </if>
            <if condition="orderHeader.statusId != 'OrderCompleted'">
                <return />
            </if>

            <set field="statusChanged" from="false" />
            <set field="allPartsComplete" from="true" />
            <entity-find entity-name="mantle.order.OrderPart" list="orderPartList">
                <econdition field-name="orderId" />
            </entity-find>
            <iterate list="orderPartList" entry="orderPart">
                <!-- part already not completed? -->
                <if condition="orderPart.statusId != 'OrderCompleted'">
                    <set field="allPartsComplete" from="false" />
                    <continue />
                </if>
                <!-- part marked as Completed, see if really is still -->
                <service-call name="mantle.order.OrderServices.isFulfilled#OrderPart"
                    out-map="isFulfilledOut"
                    in-map="[orderId:orderId, orderPartSeqId:orderPart.orderPartSeqId]" />
                <if condition="!isFulfilledOut.isFulfilled">
                    <service-call name="update#mantle.order.OrderPart"
                        in-map="[orderId:orderId, orderPartSeqId:orderPart.orderPartSeqId, statusId:'OrderApproved']" />
                    <set field="allPartsComplete" from="false" />
                </if>
            </iterate>
            <if condition="!allPartsComplete">
                <service-call name="update#mantle.order.OrderHeader" out-map="context"
                    in-map="[orderId:orderId, statusId:'OrderApproved']" />
            </if>
        </actions>
    </service>
    <service verb="checkCancelComplete" noun="Order">
        <in-parameters>
            <parameter name="orderId" />
        </in-parameters>
        <out-parameters>
            <parameter name="oldStatusId" />
            <parameter name="statusChanged" type="Boolean" />
        </out-parameters>
        <actions>
            <!-- if all parts Cancelled set header Cancelled, if any Completed and all others
            Completed or Cancelled set header Completed -->
            <set field="statusChanged" from="false" />
            <entity-find entity-name="mantle.order.OrderPart" list="orderPartList">
                <econdition field-name="orderId" />
            </entity-find>
            <set field="allCancelled" from="true" />
            <set field="anyCompleted" from="false" />
            <set field="allCancelledOrCompleted" from="true" />
            <iterate list="orderPartList" entry="curOrderPart">
                <if condition="curOrderPart.statusId in ['OrderRejected', 'OrderCancelled']">
                    <continue />
                </if>
                <if condition="curOrderPart.statusId == 'OrderCompleted'">
                    <set field="allCancelled" from="false" />
                    <set field="anyCompleted" from="true" />
                    <continue />
                </if>
                <set field="allCancelled" from="false" />
                <set field="allCancelledOrCompleted" from="false" />
            </iterate>
            <if condition="allCancelled">
                <then>
                    <service-call name="update#mantle.order.OrderHeader" out-map="context"
                        in-map="[orderId:orderId, statusId:'OrderCancelled']" />
                </then>
                <else-if condition="anyCompleted &amp;&amp; allCancelledOrCompleted">
                    <service-call name="update#mantle.order.OrderHeader" out-map="context"
                        in-map="[orderId:orderId, statusId:'OrderCompleted']" />
                </else-if>
            </if>
        </actions>
    </service>

    <service verb="complete" noun="OrderPart">
        <in-parameters>
            <parameter name="orderId" required="true" />
            <parameter name="orderPartSeqId" required="true" />
            <parameter name="completedDate" type="Timestamp" default="ec.user.nowTimestamp" />
        </in-parameters>
        <out-parameters>
            <parameter name="oldStatusId" />
            <parameter name="statusChanged" type="Boolean" />
        </out-parameters>
        <actions>
            <service-call name="update#mantle.order.OrderPart" out-map="context"
                in-map="[orderId:orderId, orderPartSeqId:orderPartSeqId, statusId:'OrderCompleted']" />
            <set field="allComplete" from="true" />
            <entity-find entity-name="mantle.order.OrderPart" list="orderPartList">
                <econdition field-name="orderId" />
            </entity-find>
            <iterate list="orderPartList" entry="orderPart">
                <if condition="orderPart.statusId != 'OrderCompleted'">
                    <set field="allComplete" from="false" />
                </if>
            </iterate>
            <if condition="allComplete">
                <service-call name="update#mantle.order.OrderHeader" out-map="context"
                    in-map="[orderId:orderId, statusId:'OrderCompleted', completedDate:completedDate]" />
            </if>
        </actions>
    </service>
    <service verb="complete" noun="Order">
        <implements service="mantle.order.OrderServices.change#OrderStatusInterface" />
        <in-parameters>
            <parameter name="completedDate" type="Timestamp" default="ec.user.nowTimestamp" />
        </in-parameters>
        <actions>
            <service-call name="mantle.order.OrderServices.update#OrderStatus" out-map="context"
                in-map="context + [statusId:'OrderCompleted']" />
        </actions>
    </service>

    <service verb="cancel" noun="Order">
        <description>Call when customer cancels the order. If no items shipped the order will be Cancelled.
            If partially shipped all items will be reduced to shipped quantity and the order will be Completed.</description>
        <implements service="mantle.order.OrderServices.change#OrderStatusInterface" />
        <!-- TODO add reject parameter to use OrderRejected status instead of OrderCancelled -->
        <actions>
            <!-- does partial cancel if already partially shipped, and then set what is left as
            completed; otherwise does a full cancel -->
            <entity-find-one entity-name="mantle.order.OrderHeader" value-field="orderHeader"
                for-update="true" />
            <if condition="orderHeader == null">
                <return error="true" message="Order ${orderId} not found" />
            </if>
            <if condition="orderHeader.statusId == 'OrderCompleted'">
                <return error="true" message="Cannot cancel order ${orderId}, already Completed" />
            </if>
            <if condition="orderHeader.statusId in ['OrderRejected', 'OrderCancelled']">
                <return message="Order ${orderId} already Cancelled" />
            </if>

            <!-- cancel item quantities not issued, update or remove ShipmentItemSource records,
            remove asset reservations if any -->
            <entity-find entity-name="mantle.product.issuance.AssetIssuance"
                list="fullAssetIssuanceList">
                <econdition field-name="orderId" />
            </entity-find>
            <entity-find entity-name="mantle.shipment.ShipmentItemSource"
                list="fullShipmentItemSourceList">
                <econdition field-name="orderId" />
            </entity-find>

            <set field="quantityIssued" from="0.0" />
            <iterate list="fullAssetIssuanceList" entry="assetIssuance">
                <set field="quantityIssued" from="quantityIssued + assetIssuance.quantity" />
            </iterate>
            <set field="hasIssuedQuantity" from="quantityIssued &gt; 0.0" />

            <entity-find entity-name="mantle.order.OrderItem" list="orderItemList">
                <econdition field-name="orderId" />
            </entity-find>
            <iterate list="orderItemList" entry="orderItem">
                <service-call name="mantle.order.OrderServices.cancel#OrderItem" out-map="itemOut"
                    out-map-add-to-existing="false"
                    in-map="[orderId:orderId, orderItemSeqId:orderItem.orderItemSeqId, orderItem:orderItem, checkCancelPart:false,
                            fullAssetIssuanceList:fullAssetIssuanceList, fullShipmentItemSourceList:fullShipmentItemSourceList]" />
            </iterate>

            <!-- cancel or complete order parts -->
            <set field="targetStatusId"
                from="hasIssuedQuantity ? 'OrderCompleted' : 'OrderCancelled'" />
            <entity-find entity-name="mantle.order.OrderPart" list="orderPartList">
                <econdition field-name="orderId" />
            </entity-find>
            <iterate list="orderPartList" entry="orderPart">
                <service-call name="update#mantle.order.OrderPart" out-map="context"
                    in-map="[orderId:orderId, orderPartSeqId:orderPart.orderPartSeqId, statusId:targetStatusId]" />
            </iterate>

            <!-- cancel or complete order header -->
            <service-call name="update#mantle.order.OrderHeader" out-map="context"
                in-map="[orderId:orderId, statusId:targetStatusId]" />
        </actions>
    </service>
    <service verb="cancel" noun="OrderPart">
        <in-parameters>
            <parameter name="orderId" required="true" />
            <parameter name="orderPartSeqId" required="true" />
        </in-parameters>
        <actions>
            <entity-find-one entity-name="mantle.order.OrderPart" value-field="orderPart"
                for-update="true" />
            <if condition="orderPart == null">
                <return error="true" message="Order Part ${orderId}:${orderPartSeqId} not found" />
            </if>
            <if condition="orderPart.statusId == 'OrderCompleted'">
                <return error="true"
                    message="Cannot cancel Order Part ${orderId}:${orderPartSeqId}, already Completed" />
            </if>
            <if condition="orderPart.statusId in ['OrderRejected', 'OrderCancelled']">
                <return message="Order Part ${orderId}:${orderPartSeqId} already Cancelled" />
            </if>

            <set field="hasIssuedQuantity" from="false" />
            <entity-find entity-name="mantle.order.OrderItem" list="orderItemList">
                <econdition field-name="orderId" />
                <econdition field-name="orderPartSeqId" />
            </entity-find>
            <iterate list="orderItemList" entry="orderItem">
                <service-call name="mantle.order.OrderServices.cancel#OrderItem" out-map="itemOut"
                    out-map-add-to-existing="false"
                    in-map="[orderId:orderId, orderItemSeqId:orderItem.orderItemSeqId, orderItem:orderItem, checkCancelPart:false]" />
                <if condition="itemOut.hasIssuedQuantity">
                    <set field="hasIssuedQuantity" from="true" />
                </if>
            </iterate>

            <!-- cancel or complete order part -->
            <set field="targetStatusId"
                from="hasIssuedQuantity ? 'OrderCompleted' : 'OrderCancelled'" />
            <service-call name="update#mantle.order.OrderPart" out-map="context"
                in-map="[orderId:orderId, orderPartSeqId:orderPartSeqId, statusId:targetStatusId]" />

            <!-- if all parts Cancelled set header Cancelled, if any Completed and all others
            Completed or Cancelled set header Completed -->
            <service-call name="mantle.order.OrderServices.checkCancelComplete#Order"
                in-map="[orderId:orderId]" />
        </actions>
    </service>
    <service verb="cancel" noun="OrderItem" no-tx-cache="true">
        <in-parameters>
            <parameter name="orderId" required="true" />
            <parameter name="orderItemSeqId" required="true" />
            <parameter name="cancelQuantity" type="BigDecimal">
                <description>Defaults to quantity not yet issued, if greater than quantity not issued will be reduced to quantity not issued</description>
            </parameter>
            <parameter name="orderItem" type="EntityValue" />
            <parameter name="fullAssetIssuanceList" type="List">
                <parameter name="assetIssuance" type="EntityValue" />
            </parameter>
            <parameter name="fullShipmentItemSourceList" type="List">
                <parameter name="shipmentItemSource" type="EntityValue" />
            </parameter>
            <parameter name="checkCancelPart" type="Boolean" default="true" />
        </in-parameters>
        <out-parameters>
            <parameter name="hasIssuedQuantity" type="Boolean" />
            <parameter name="quantityCancelled" type="BigDecimal" />
        </out-parameters>
        <actions>
            <if condition="orderItem == null">
                <entity-find-one entity-name="mantle.order.OrderItem" value-field="orderItem" />
            </if>
            <if condition="orderItem == null">
                <return error="true" message="Order Item ${orderId}:${orderItemSeqId} not found" />
            </if>

            <!-- only do this for product items -->
            <if condition="!orderItem.productId">
                <return />
            </if>
            <entity-find entity-name="moqui.basic.EnumGroupMember" list="productItemTypeEgms"
                cache="true">
                <econdition field-name="enumGroupEnumId" value="EngItemsProduct" />
            </entity-find>
            <set field="productItemTypes" from="productItemTypeEgms*.enumId" />
            <if condition="!productItemTypes.contains(orderItem.itemTypeEnumId)">
                <return type="warning"
                    message="Item ${orderItemSeqId} is not a product type item, not closing" />
            </if>

            <!-- check quantity issued -->
            <if condition="fullAssetIssuanceList">
                <then>
                    <filter-map-list list="fullAssetIssuanceList" to-list="itemAssetIssuanceList">
                        <field-map field-name="orderItemSeqId" />
                        <field-map field-name="productId" from="orderItem.productId" />
                    </filter-map-list>
                </then>
                <else>
                    <entity-find entity-name="mantle.product.issuance.AssetIssuance"
                        list="itemAssetIssuanceList">
                        <econdition field-name="orderId" />
                        <econdition field-name="orderItemSeqId" />
                        <econdition field-name="productId" from="orderItem.productId" />
                    </entity-find>
                </else>
            </if>

            <set field="itemQuantityIssued" from="0.0" />
            <iterate list="itemAssetIssuanceList" entry="itemAssetIssuance">
                <set field="itemQuantityIssued"
                    from="itemQuantityIssued + itemAssetIssuance.quantity" />
            </iterate>
            <set field="hasIssuedQuantity" from="itemQuantityIssued &gt; 0.0" />

            <!-- determine quantity to cancel -->
            <set field="itemQuantity" from="orderItem.quantity != null ? orderItem.quantity : 1.0" />
            <set field="notIssuedQuantity" from="itemQuantity - itemQuantityIssued" />
            <if condition="notIssuedQuantity &lt; 0.0">
                <log level="warn"
                    message="In cancel#OrderItem itemQuantityIssued ${itemQuantityIssued} is greater than itemQuantity ${itemQuantity}, using 0.0 for notIssuedQuantity instead of ${notIssuedQuantity}" />
                <set field="notIssuedQuantity" from="0.0" />
            </if>
            <if condition="cancelQuantity">
                <then>
                    <if condition="cancelQuantity &gt; notIssuedQuantity">
                        <then>
                            <set field="quantityCancelled" from="notIssuedQuantity" />
                            <message type="warning">Cannot cancel quantity ${cancelQuantity}, only ${notIssuedQuantity} not yet shipped for Order Item ${orderId}:${orderItemSeqId}</message>
                        </then>
                        <else>
                            <set field="quantityCancelled" from="cancelQuantity" />
                        </else>
                    </if>
                </then>
                <else>
                    <set field="quantityCancelled" from="notIssuedQuantity" />
                </else>
            </if>

            <if condition="!quantityCancelled">
                <return />
            </if>

            <!-- update the OrderItem -->
            <service-call name="update#mantle.order.OrderItem"
                in-map="[orderId:orderId,
                        orderItemSeqId:orderItem.orderItemSeqId,
                        quantityCancelled:(quantityCancelled + (orderItem.quantityCancelled ?: 0)),
                        quantity:(itemQuantity - quantityCancelled)]" />

            <!-- adjust child items (usually discount and tax) for new quantity -->
            <!-- NOTE this is simpler than other prorating because it is only done once, then the
            item is either completed if partially filled or cancelled otherwise -->
            <!-- NOTE skip discounts if isPromo=Y? those will be handled by order update triggers,
            if enabled; maybe best to calc here and disable promo calc (are disabled by default for
            orders Approved, etc) -->
            <if condition="itemQuantity == quantityCancelled">
                <then>
                    <set field="childCancelRatio" from="1.0" />
                </then>
                <else>
                    <set field="childCancelRatio"
                        from="(quantityCancelled as BigDecimal).divide(itemQuantity as BigDecimal, 6, BigDecimal.ROUND_HALF_EVEN)" />
                </else>
            </if>
            <set field="childOrderItemList" from="orderItem.'Child#mantle.order.OrderItem'" />
            <order-map-list list="childOrderItemList">
                <order-by field-name="orderItemSeqId" />
            </order-map-list>
            <iterate list="childOrderItemList" entry="childOrderItem">
                <if condition="childOrderItem.quantity == 0.0 || childOrderItem.unitAmount == 0.0">
                    <continue />
                </if>
                <if condition="childOrderItem.quantity == itemQuantity">
                    <then>
                        <!-- if child qty == parent qty no need to prorate, just adjust quantities
                        to match -->
                        <service-call name="update#mantle.order.OrderItem"
                            in-map="[orderId:orderId,
                        orderItemSeqId:childOrderItem.orderItemSeqId,
                        quantityCancelled:(quantityCancelled + (childOrderItem.quantityCancelled ?: 0)),
                        quantity:(itemQuantity - quantityCancelled)]" />
                    </then>
                    <else>
                        <!-- quantity doesn't match, leave quantity alone and prorate unitAmount -->
                        <set field="newUnitAmount"
                            from="childOrderItem.unitAmount - ((childCancelRatio as BigDecimal) * (childOrderItem.unitAmount as BigDecimal)).setScale(2, BigDecimal.ROUND_HALF_UP)" />
                        <service-call name="update#mantle.order.OrderItem"
                            in-map="[orderId:orderId,
                        orderItemSeqId:childOrderItem.orderItemSeqId, unitAmount:newUnitAmount]" />
                    </else>
                </if>
            </iterate>

            <!-- update or remove ShipmentItemSource records -->
            <if condition="fullShipmentItemSourceList">
                <then>
                    <filter-map-list list="fullShipmentItemSourceList"
                        to-list="itemShipmentItemSourceList">
                        <field-map field-name="orderItemSeqId" />
                    </filter-map-list>
                </then>
                <else>
                    <entity-find entity-name="mantle.shipment.ShipmentItemSource"
                        list="itemShipmentItemSourceList">
                        <econdition field-name="orderId" />
                        <econdition field-name="orderItemSeqId" />
                    </entity-find>
                </else>
            </if>

            <set field="shipmentItemQuantityReducedMap" from="[:]" />
            <set field="shipQuantityRemaining" from="quantityCancelled" />
            <iterate list="itemShipmentItemSourceList" entry="itemShipmentItemSource">
                <set field="shipQuantityToReduce"
                    from="shipQuantityRemaining &gt; itemShipmentItemSource.quantityNotHandled ?
                        itemShipmentItemSource.quantityNotHandled : shipQuantityRemaining" />
                <if condition="!shipQuantityToReduce">
                    <continue />
                </if>
                <script>addToBigDecimalInMap(itemShipmentItemSource.shipmentId, shipQuantityToReduce, shipmentItemQuantityReducedMap)</script>
                <!-- reduce quantity by quantityNotHandled -->
                <service-call name="update#mantle.shipment.ShipmentItemSource"
                    in-map="[shipmentItemSourceId:itemShipmentItemSource.shipmentItemSourceId, quantityNotHandled:0,
                                quantity:(itemShipmentItemSource.quantity - shipQuantityToReduce)]" />

                <set field="shipQuantityRemaining"
                    from="shipQuantityRemaining - shipQuantityToReduce" />
            </iterate>

            <iterate list="shipmentItemQuantityReducedMap" entry="shipmentItemQuantityReduced"
                key="shipmentId">
                <entity-find-one entity-name="mantle.shipment.ShipmentItem"
                    value-field="shipmentItem">
                    <field-map field-name="shipmentId" />
                    <field-map field-name="productId" from="orderItem.productId" />
                </entity-find-one>
                <if condition="shipmentItem != null">
                    <set field="newSiQuantity"
                        from="shipmentItem.quantity &gt; shipmentItemQuantityReduced ?
                                shipmentItem.quantity - shipmentItemQuantityReduced : 0.0" />
                    <service-call name="update#mantle.shipment.ShipmentItem"
                        in-map="[shipmentId:shipmentId, productId:orderItem.productId, quantity:newSiQuantity]" />

                    <if condition="newSiQuantity == 0.0">
                        <!-- if no ShipmentItems have quantity greater than 0.0 cancel Shipment -->
                        <entity-find-count entity-name="mantle.shipment.ShipmentItem"
                            count-field="nonZeroShipItemCount">
                            <econdition field-name="shipmentId" />
                            <econdition field-name="quantity" operator="greater" from="0.0" />
                        </entity-find-count>
                        <if condition="nonZeroShipItemCount == 0">
                            <!-- cancel#Shipment won't do what it normally does reducing quantities,
                            but just in case other cleanups needed -->
                            <service-call name="mantle.shipment.ShipmentServices.cancel#Shipment"
                                in-map="[shipmentId:shipmentId]" />
                        </if>
                    </if>
                </if>
            </iterate>

            <if condition="quantityCancelled == notIssuedQuantity">
                <then>
                    <!-- if quantityCancelled == notIssuedQuantity remove all OrderItem Reservations -->
                    <service-call name="mantle.product.AssetServices.remove#OrderItemReservations"
                        in-map="[orderId:orderId, orderItemSeqId:orderItem.orderItemSeqId]" />

                    <if
                        condition="checkCancelPart &amp;&amp; quantityCancelled == notIssuedQuantity">
                        <!-- first see if all OrderItem in part have quantity 0, if so cancel order -->
                        <entity-find-count entity-name="mantle.order.OrderItem"
                            count-field="partItemQtyOverZeroCount">
                            <econdition field-name="orderId" />
                            <econdition field-name="orderPartSeqId" from="orderItem.orderPartSeqId" />
                            <econdition field-name="itemTypeEnumId" operator="in"
                                from="productItemTypes" />
                            <econdition field-name="quantity" operator="greater" from="0.0" />
                        </entity-find-count>
                        <if condition="partItemQtyOverZeroCount == 0">
                            <then>
                                <service-call name="update#mantle.order.OrderPart" out-map="context"
                                    in-map="[orderId:orderId, orderPartSeqId:orderItem.orderPartSeqId, statusId:'OrderCancelled']" />
                                <!-- if all parts Cancelled set header Cancelled, if any Completed
                                and all others Completed or Cancelled set header Completed -->
                                <service-call
                                    name="mantle.order.OrderServices.checkCancelComplete#Order"
                                    in-map="[orderId:orderId]" />
                            </then>
                            <else>
                                <!-- otherwise call checkComplete#OrderPart -->
                                <service-call
                                    name="mantle.order.OrderServices.checkComplete#OrderPart"
                                    out-map="checkPartOut"
                                    in-map="[orderId:orderId, orderPartSeqId:orderItem.orderPartSeqId]" />
                                <if condition="checkPartOut.statusChanged">
                                    <!-- if all parts Cancelled set header Cancelled, if any
                                    Completed and all others Completed or Cancelled set header
                                    Completed -->
                                    <service-call
                                        name="mantle.order.OrderServices.checkCancelComplete#Order"
                                        in-map="[orderId:orderId]" />
                                </if>
                            </else>
                        </if>
                    </if>
                </then>
                <else>
                    <!-- reduce OrderItem Reservations by quantityCancelled? no need to,
                    AssetReservation ECA rule will pick it up -->
                </else>
            </if>
        </actions>
    </service>

    <!-- ============================================================== -->
    <!-- ========== Clone Order and Recurring Order Services ========== -->
    <!-- ============================================================== -->

    <service verb="clone" noun="Order">
        <description>Clone an order. Always copies the OrderHeader, OrderPart, and OrderItem records.</description>
        <in-parameters>
            <parameter name="baseOrderId" required="true" default="orderId" />
            <parameter name="orderId" />
            <auto-parameters entity-name="mantle.order.OrderHeader" include="nonpk">
                <exclude field-name="parentOrderId" />
                <exclude field-name="lastOrderedDate" />
            </auto-parameters>
            <auto-parameters entity-name="mantle.order.OrderPart" include="nonpk" />
            <parameter name="requiredByDate" type="Timestamp" />
            <parameter name="statusId" default-value="OrderOpen" />
            <parameter name="entryDate" type="Timestamp" default="ec.user.nowTimestamp" />
            <parameter name="visitId" default="ec.user.visitId" />
            <parameter name="orderRevision" type="Integer" default="1" />

            <parameter name="clearDates" type="Boolean" default="true" />
            <parameter name="productItemsOnly" type="Boolean" default="true" />
            <parameter name="copyContactMech" type="Boolean" default="true" />
            <parameter name="copyContent" type="Boolean" default="true" />
            <parameter name="copyNote" type="Boolean" default="true" />
            <parameter name="copyPartParty" type="Boolean" default="true" />
            <parameter name="copyTerm" type="Boolean" default="true" />
            <parameter name="copyItemWorkEffort" type="Boolean" default="true" />
            <parameter name="copyPayment" type="Boolean" default="true" />
            <parameter name="paymentStatusId" default-value="PmntPromised" />
        </in-parameters>
        <out-parameters>
            <parameter name="orderId" />
        </out-parameters>
        <actions>
            <entity-find-one entity-name="mantle.order.OrderHeader" value-field="orderHeader">
                <field-map field-name="orderId" from="baseOrderId" />
            </entity-find-one>

            <!-- clear and sequence new orderId -->
            <set field="orderHeader.orderId" from="null" />
            <entity-sequenced-id-primary value-field="orderHeader" />

            <!-- set nonpk fields from context, if passed -->
            <entity-set value-field="orderHeader" include="nonpk" />

            <!-- set or clear fields related to order cloning and recurrence -->
            <set field="orderHeader.parentOrderId" from="baseOrderId" />
            <set field="orderHeader.recurCronExpression" from="null" />
            <set field="orderHeader.lastOrderedDate" from="null" />
            <set field="orderHeader.recurAutoInvoice" from="null" />

            <if condition="clearDates">
                <!-- set the fields even if null, don't do this for other fields -->
                <set field="orderHeader.entryDate" from="entryDate" />
                <set field="orderHeader.placedDate" from="placedDate" />
                <set field="orderHeader.approvedDate" from="approvedDate" />
                <set field="orderHeader.completedDate" from="completedDate" />
                <!-- don't set this on clones, used for recurring orders to track last date/time of
                clone/recurrence: <set field="orderHeader.lastOrderedDate" from="lastOrderedDate"/> -->
            </if>

            <!-- create new OrderHeader -->
            <entity-create value-field="orderHeader" />
            <set field="orderId" from="orderHeader.orderId" />

            <entity-find entity-name="mantle.order.OrderPart" list="valueList">
                <econdition field-name="orderId" from="baseOrderId" />
            </entity-find>
            <iterate list="valueList" entry="value">
                <set field="value.orderId" from="orderId" />
                <entity-set value-field="value" include="nonpk" />
                <if condition="clearDates">
                    <!-- set the fields even if null, don't do this for other fields -->
                    <set field="value.shipAfterDate" from="shipAfterDate" />
                    <set field="value.shipBeforeDate" from="shipBeforeDate" />
                    <set field="value.estimatedShipDate" from="estimatedShipDate" />
                    <set field="value.estimatedDeliveryDate" from="estimatedDeliveryDate" />
                    <set field="value.validFromDate" from="validFromDate" />
                    <set field="value.validThruDate" from="validThruDate" />
                    <set field="value.autoCancelDate" from="autoCancelDate" />
                    <set field="value.dontCancelSetDate" from="dontCancelSetDate" />
                </if>
                <entity-create value-field="value" />
            </iterate>

            <entity-find entity-name="moqui.basic.EnumGroupMember" list="productItemTypeEgms"
                cache="true">
                <econdition field-name="enumGroupEnumId" value="EngItemsProduct" />
            </entity-find>
            <set field="productItemTypes" from="productItemTypeEgms*.enumId" />

            <entity-find entity-name="mantle.order.OrderItem" list="valueList">
                <econdition field-name="orderId" from="baseOrderId" />
                <order-by field-name="orderItemSeqId" />
            </entity-find>
            <iterate list="valueList" entry="value">
                <if
                    condition="productItemsOnly &amp;&amp; (!value.productId || !productItemTypes.contains(value.itemTypeEnumId))">
                    <continue />
                </if>
                <set field="value.orderId" from="orderId" />
                <set field="value.orderItemSeqId" from="null" />
                <entity-sequenced-id-secondary value-field="value" />
                <if condition="clearDates">
                    <set field="value.requiredByDate" from="requiredByDate" />
                </if>
                <entity-create value-field="value" />
            </iterate>

            <if condition="copyContactMech">
                <entity-find entity-name="mantle.order.OrderPartContactMech" list="valueList">
                    <econdition field-name="orderId" from="baseOrderId" />
                </entity-find>
                <iterate list="valueList" entry="value">
                    <set field="value.orderId" from="orderId" />
                    <entity-create value-field="value" />
                </iterate>
            </if>
            <if condition="copyContent">
                <entity-find entity-name="mantle.order.OrderContent" list="valueList">
                    <econdition field-name="orderId" from="baseOrderId" />
                </entity-find>
                <iterate list="valueList" entry="value">
                    <set field="value.orderId" from="orderId" />
                    <set field="value.orderContentId" from="null" />
                    <entity-sequenced-id-primary value-field="value" />
                    <entity-create value-field="value" />
                </iterate>
            </if>
            <if condition="copyNote">
                <entity-find entity-name="mantle.order.OrderNote" list="valueList">
                    <econdition field-name="orderId" from="baseOrderId" />
                </entity-find>
                <iterate list="valueList" entry="value">
                    <set field="value.orderId" from="orderId" />
                    <entity-create value-field="value" />
                </iterate>
            </if>
            <if condition="copyPartParty">
                <entity-find entity-name="mantle.order.OrderPartParty" list="valueList">
                    <econdition field-name="orderId" from="baseOrderId" />
                </entity-find>
                <iterate list="valueList" entry="value">
                    <set field="value.orderId" from="orderId" />
                    <entity-create value-field="value" />
                </iterate>
            </if>
            <if condition="copyTerm">
                <entity-find entity-name="mantle.order.OrderPartTerm" list="valueList">
                    <econdition field-name="orderId" from="baseOrderId" />
                </entity-find>
                <iterate list="valueList" entry="value">
                    <set field="value.orderId" from="orderId" />
                    <entity-create value-field="value" />
                </iterate>
            </if>
            <if condition="copyItemWorkEffort">
                <entity-find entity-name="mantle.order.OrderItemWorkEffort" list="valueList">
                    <econdition field-name="orderId" from="baseOrderId" />
                </entity-find>
                <iterate list="valueList" entry="value">
                    <set field="value.orderId" from="orderId" />
                    <entity-create value-field="value" />
                </iterate>
            </if>

            <if condition="copyPayment">
                <entity-find entity-name="mantle.account.payment.Payment" list="valueList">
                    <econdition field-name="orderId" from="baseOrderId" />
                </entity-find>
                <iterate list="valueList" entry="value">
                    <set field="value.orderId" from="orderId" />
                    <set field="value.statusId" from="paymentStatusId" />
                    <set field="value.paymentAuthCode" from="null" />
                    <set field="value.paymentRefNum" from="null" />
                    <set field="value.presentFlag" from="null" />
                    <set field="value.swipedFlag" from="null" />
                    <set field="value.processAttempt" from="null" />
                    <set field="value.needsNsfRetry" from="null" />
                    <set field="value.visitId" from="visitId" />
                    <if condition="clearDates">
                        <set field="value.effectiveDate" from="null" />
                    </if>
                    <set field="value.paymentId" from="null" />
                    <entity-sequenced-id-primary value-field="value" />
                    <entity-create value-field="value" />
                </iterate>
            </if>

            <message type="success">Created Order ${orderId} as a clone of Order ${baseOrderId}</message>
        </actions>
    </service>

    <service verb="update" noun="OrderRecur">
        <in-parameters>
            <parameter name="orderId" required="true" />
            <parameter name="recurCronExpression" required="true" />
            <parameter name="recurAutoInvoice" default-value="N" />
            <parameter name="lastOrderedDate" type="Timestamp" />
        </in-parameters>
        <actions>
            <!-- make sure order has no associated shipments or invoices -->
            <entity-find-count entity-name="mantle.order.OrderItemBilling"
                count-field="itemBillingCount">
                <econdition field-name="orderId" />
            </entity-find-count>
            <if condition="itemBillingCount">
                <return error="true"
                    message="Order ${orderId} has been invoiced (billed), cannot make recurring" />
            </if>

            <entity-find-count entity-name="mantle.shipment.ShipmentItemSource"
                count-field="shipmentSourceCount">
                <econdition field-name="orderId" />
            </entity-find-count>
            <if condition="shipmentSourceCount">
                <return error="true"
                    message="Order ${orderId} has been shipped, cannot make recurring" />
            </if>

            <!-- make sure cron expr is valid -->
            <script>
                try { org.moqui.impl.service.ScheduledJobRunner.getExecutionTime((String) recurCronExpression) } catch (Exception e) {
                    ec.message.addError("Invalid Cron expression '${recurCronExpression}': ${e.message}")
                    return
                }
            </script>

            <!-- update OrderHeader -->
            <service-call name="update#mantle.order.OrderHeader" in-map="context" />

            <!-- cancel reservations if there are any -->
            <service-call name="mantle.product.AssetServices.remove#OrderReservations"
                in-map="[orderId:orderId]" />

            <!-- TODO: don't allow AssetReservation, ShipmentItemSource, or OrderItemBilling for
            OrderHeader with recurCronExpression -->
        </actions>
    </service>

    <service verb="create" noun="RecurringOrders" authenticate="anonymous-all">
        <description>Called by scheduled ServiceJob to clone recurring orders, place, and try auto-approve</description>
        <actions>
            <entity-find entity-name="mantle.order.OrderHeader" list="orderHeaderList" cache="false">
                <econdition field-name="statusId" value="OrderApproved" />
                <econdition field-name="recurCronExpression" operator="is-not-null" />
                <select-field field-name="orderId,recurCronExpression,lastOrderedDate" />
                <order-by field-name="orderId" />
            </entity-find>
            <iterate list="orderHeaderList" entry="orderHeader">
                <!-- check recurCronExpression vs lastOrderedDate to see if we need to run -->
                <set field="shouldRun"
                    from="org.moqui.impl.service.ScheduledJobRunner.isLastRunBeforeLastSchedule(
                        orderHeader.recurCronExpression, orderHeader.lastOrderedDate, 'Order ' + orderHeader.orderId, null)" />

                <if condition="shouldRun">
                    <service-call name="mantle.order.OrderServices.create#RecurringOrder"
                        in-map="[baseOrderId:orderHeader.orderId]" async="distribute" />
                </if>
            </iterate>
        </actions>
    </service>
    <service verb="create" noun="RecurringOrder" authenticate="anonymous-all">
        <in-parameters>
            <parameter name="baseOrderId" required="true" />
        </in-parameters>
        <out-parameters>
            <parameter name="orderId" />
        </out-parameters>
        <actions>
            <!-- lock the order  -->
            <entity-find-one entity-name="mantle.order.OrderHeader" value-field="baseOrderHeader"
                for-update="true">
                <field-map field-name="orderId" from="baseOrderId" />
            </entity-find-one>

            <if condition="!baseOrderHeader?.recurCronExpression">
                <return type="danger"
                    message="Order ${baseOrderId} is not a recurring order (has no recur cron expression)" />
            </if>
            <if condition="baseOrderHeader?.statusId != 'OrderApproved'">
                <return type="danger" message="Order ${baseOrderId} is not in the Approved status" />
            </if>

            <!-- check again to make sure hasn't run since last execution time -->
            <set field="shouldRun"
                from="org.moqui.impl.service.ScheduledJobRunner.isLastRunBeforeLastSchedule(
                    baseOrderHeader.recurCronExpression, baseOrderHeader.lastOrderedDate, 'Order ' + baseOrderHeader.orderId, null)" />
            <if condition="!shouldRun">
                <return type="warning"
                    message="Order ${baseOrderHeader.orderId} is not yet scheduled to reorder since last order time ${baseOrderHeader.lastOrderedDate}" />
            </if>

            <!-- clone the order -->
            <service-call name="mantle.order.OrderServices.clone#Order" out-map="cloneOut"
                in-map="[baseOrderId:baseOrderId]" />
            <set field="orderId" from="cloneOut.orderId" />

            <!-- Place the Order -->
            <service-call name="mantle.order.OrderServices.place#Order"
                in-map="[orderId:orderId, requireInventory:false]" />

            <!-- if recurAutoInvoice == 'Y' AND Order was auto-approved then create Invoice -->
            <if condition="baseOrderHeader.recurAutoInvoice == 'Y'">
                <entity-find entity-name="mantle.order.OrderPart" list="orderPartList">
                    <econdition field-name="orderId" />
                    <order-by field-name="orderPartSeqId" />
                </entity-find>
                <iterate list="orderPartList" entry="orderPart">
                    <if condition="orderPart?.statusId == 'OrderApproved'">
                        <service-call
                            name="mantle.account.InvoiceServices.create#EntireOrderPartInvoice"
                            in-map="[orderId:orderId, orderPartSeqId:orderPart.orderPartSeqId]" />
                    </if>
                </iterate>
            </if>

            <!-- set lastOrderedDate on recurring order -->
            <set field="baseOrderHeader.lastOrderedDate" from="ec.user.nowTimestamp" />
            <entity-update value-field="baseOrderHeader" />
        </actions>
    </service>

    <!-- ==================================================== -->
    <!-- ========== Order Change Response Services ========== -->
    <!-- ==================================================== -->

    <service verb="handle" noun="OrderItemChange">
        <description>Called by EECA rule on OrderItem create/update/delete</description>
        <in-parameters>
            <parameter name="orderId" required="true" />
            <parameter name="orderItemSeqId" />
            <parameter name="orderPartSeqId" />
            <parameter name="itemTypeEnumId" />
            <parameter name="quantity" type="BigDecimal" />
            <parameter name="unitAmount" type="BigDecimal" />
            <parameter name="selectedAmount" type="BigDecimal" />
            <parameter name="isPromo" />
            <parameter name="originalValue" type="Map" />
            <parameter name="eecaOperation" />
        </in-parameters>
        <actions>
            <if condition="eecaOperation == 'delete'">
                <service-call name="mantle.order.OrderServices.update#OrderPartTotal"
                    in-map="context" />
                <!-- NOTE: OrderServices.handle#OrderMajorChange is called by delete#OrderItem -->
                <return />
            </if>

            <if
                condition="!originalValue || quantity != originalValue.quantity || unitAmount != originalValue.unitAmount ||
                    selectedAmount != originalValue.selectedAmount || orderPartSeqId != originalValue.orderPartSeqId">
                <then>
                    <entity-find-one entity-name="mantle.order.OrderHeader"
                        value-field="orderHeader" for-update="true" />
                    <service-call name="mantle.order.OrderServices.update#OrderPartTotal"
                        in-map="context" />
                    <if
                        condition="originalValue &amp;&amp; orderPartSeqId != originalValue.orderPartSeqId">
                        <service-call name="mantle.order.OrderServices.update#OrderPartTotal"
                            in-map="[orderId:orderId, orderPartSeqId:originalValue.orderPartSeqId]" />
                    </if>

                    <if
                        condition="orderHeader.productStoreId &amp;&amp; isPromo != 'Y' &amp;&amp; !(itemTypeEnumId in ['ItemShipping', 'ItemSalesTax', 'ItemVatTax'])">
                        <service-call name="mantle.order.OrderServices.handle#OrderMajorChange"
                            in-map="[orderId:orderId, orderPartSeqId:orderPartSeqId]" />
                        <if
                            condition="originalValue &amp;&amp; orderPartSeqId != originalValue.orderPartSeqId">
                            <service-call name="mantle.order.OrderServices.handle#OrderMajorChange"
                                in-map="[orderId:orderId, orderPartSeqId:originalValue.orderPartSeqId]" />
                        </if>
                    </if>
                    <!-- NOTE: no need to increment#OrderRevision, will be done when part updated -->
                </then>
                <else>
                    <!-- increment order revision if anything else changes on an item -->
                    <service-call name="mantle.order.OrderServices.increment#OrderRevision"
                        in-map="context" />
                </else>
            </if>
        </actions>
    </service>
    <service verb="handle" noun="OrderPartChange">
        <description>Called by EECA rule on OrderPart update</description>
        <in-parameters>
            <parameter name="orderId" required="true" />
            <parameter name="orderPartSeqId" required="true" />
            <parameter name="carrierPartyId" />
            <parameter name="shipmentMethodEnumId" />
            <parameter name="postalContactMechId" />
            <parameter name="customerPartyId" />
            <parameter name="disablePromotions" />
            <parameter name="disableShippingCalc" />
            <parameter name="disableTaxCalc" />
            <parameter name="partTotal" type="BigDecimal" />
            <parameter name="originalValue" type="Map" />
        </in-parameters>
        <actions>
            <!-- generally if partTotal changes only that has changed, so don't consider it any sort
            of significant change -->
            <if condition="originalValue &amp;&amp; partTotal != originalValue.partTotal">
                <return />
            </if>

            <entity-find-one entity-name="mantle.order.OrderHeader" value-field="orderHeader"
                for-update="true" />
            <if
                condition="orderHeader.productStoreId &amp;&amp; (!originalValue || postalContactMechId != originalValue.postalContactMechId ||
                    carrierPartyId != originalValue.carrierPartyId || shipmentMethodEnumId != originalValue.shipmentMethodEnumId ||
                    customerPartyId != originalValue.customerPartyId || disablePromotions != originalValue.disablePromotions ||
                    disableShippingCalc != originalValue.disableShippingCalc || disableTaxCalc != originalValue.disableTaxCalc)">
                <then>
                    <service-call name="mantle.order.OrderServices.handle#OrderMajorChange"
                        in-map="[orderId:orderId, orderPartSeqId:orderPartSeqId]" />
                </then>
                <else>
                    <service-call name="mantle.order.OrderServices.increment#OrderRevision"
                        in-map="context" />
                </else>
            </if>
        </actions>
    </service>
    <service verb="handle" noun="OrderMajorChange">
        <in-parameters>
            <parameter name="orderId" required="true" />
            <parameter name="orderPartSeqId" required="true" />
            <parameter name="orderHeader" type="EntityValue" />
        </in-parameters>
        <actions>
            <!-- use ec.context.sharedMap for a reentrant semaphore (sort of, not thread safe but
            all needed to prevent incorrect/infinite recursion) -->
            <set field="sharedFlagKey" from="'OrderMajorChange' + orderId + orderPartSeqId" />
            <if condition="ec.context.getSharedMap().get(sharedFlagKey)">
                <return />
            </if>

            <if condition="orderHeader == null">
                <entity-find-one entity-name="mantle.order.OrderHeader" value-field="orderHeader"
                    for-update="true" />
            </if>
            <if condition="orderHeader.productStoreId">
                <entity-find-one entity-name="mantle.order.OrderPart" value-field="orderPart"
                    for-update="true" />
                <set field="noRecalcStatuses"
                    from="['OrderApproved', 'OrderSent', 'OrderCompleted', 'OrderRejected', 'OrderCancelled']" />
                <if condition="orderHeader.statusId in noRecalcStatuses">
                    <return type="warning"
                        message="Not updating promotions, shipping, or tax for order ${orderId} in status ${orderHeader.status?.description}" />
                </if>
                <if condition="orderPart.statusId in noRecalcStatuses">
                    <return type="warning"
                        message="Not updating promotions, shipping, or tax for order part ${orderId}:${orderPartSeqId} in status ${orderPart.status?.description}" />
                </if>

                <!-- make sure no billing done, don't auto update if so -->
                <entity-find-count entity-name="mantle.order.OrderItemBillingDetail"
                    count-field="partBillingCount">
                    <econdition field-name="orderId" />
                    <econdition field-name="orderPartSeqId" />
                </entity-find-count>
                <if condition="partBillingCount">
                    <return type="warning"
                        message="Not updating promotions, shipping, or tax for order part ${orderId}:${orderPartSeqId} with ${partBillingCount} OrderItemBilling records" />
                </if>

                <!-- set flag in context root to avoid recursive triggers -->
                <script>ec.context.getSharedMap().put(sharedFlagKey, true)</script>

                <!-- Apply Promotions -->
                <if condition="!'Y'.equals(orderPart.disablePromotions)">
                    <entity-find entity-name="mantle.order.OrderItem" list="promoItemList">
                        <econdition field-name="orderId" />
                        <econdition field-name="orderPartSeqId" />
                        <econdition field-name="isPromo" value="Y" />
                    </entity-find>
                    <iterate list="promoItemList" entry="promoItem">
                        <service-call name="mantle.order.OrderServices.delete#OrderItem"
                            in-map="[orderId:promoItem.orderId, orderItemSeqId:promoItem.orderItemSeqId]" />
                    </iterate>
                    <service-call name="mantle.product.PromotionServices.apply#OrderPromotions"
                        in-map="[orderId:orderId, orderPartSeqId:orderPartSeqId, orderHeader:orderHeader]" />
                </if>

                <!-- Check for promotions with free ground shipping (if shipmentMethodEnumId ==
                ShMthGround) -->
                <set field="doShipCalc" from="true" />
                <if condition="'ShMthGround'.equals(orderPart.shipmentMethodEnumId)">
                    <!-- get promotions applied -->
                    <entity-find entity-name="mantle.order.OrderItem" list="shipPromoItemList"
                        distinct="true">
                        <econdition field-name="orderId" />
                        <econdition field-name="orderPartSeqId" />
                        <econdition field-name="isPromo" value="Y" />
                        <econdition field-name="storePromotionId" operator="is-not-null" />
                        <select-field field-name="storePromotionId" />
                    </entity-find>
                    <!-- this may look inefficient, but the best way to get arbitrary set of cached
                    ProductStorePromotion values -->
                    <iterate list="shipPromoItemList" entry="shipPromoItem">
                        <entity-find-one entity-name="mantle.product.store.ProductStorePromotion"
                            value-field="storePromotion" cache="true">
                            <field-map field-name="storePromotionId"
                                from="shipPromoItem.storePromotionId" />
                        </entity-find-one>
                        <if condition="'Y'.equals(storePromotion?.freeGroundShipping)">
                            <set field="doShipCalc" from="false" />
                            <break />
                        </if>
                    </iterate>
                </if>

                <!-- Calculate Shipping, after promotions so that order total/etc is adjusted for
                them -->
                <if condition="!'Y'.equals(orderPart.disableShippingCalc)">
                    <entity-find entity-name="mantle.order.OrderItem" list="shippingItemList">
                        <econdition field-name="orderId" />
                        <econdition field-name="orderPartSeqId" />
                        <econdition field-name="itemTypeEnumId" value="ItemShipping" />
                    </entity-find>
                    <iterate list="shippingItemList" entry="shippingItem">
                        <service-call name="mantle.order.OrderServices.delete#OrderItem"
                            in-map="[orderId:shippingItem.orderId, orderItemSeqId:shippingItem.orderItemSeqId]" />
                    </iterate>
                    <if condition="doShipCalc">
                        <service-call
                            name="mantle.shipment.CarrierServices.calculate#OrderPartShipping"
                            in-map="[orderId:orderId, orderPartSeqId:orderPartSeqId, createOrderItem:true]" />
                    </if>
                </if>

                <!-- Calculate Tax, after Shipping as it might be taxed -->
                <if condition="!'Y'.equals(orderPart.disableTaxCalc)">
                    <entity-find entity-name="mantle.order.OrderItem" list="taxItemList">
                        <econdition field-name="orderId" />
                        <econdition field-name="orderPartSeqId" />
                        <econdition field-name="itemTypeEnumId" operator="in"
                            value="ItemSalesTax,ItemVatTax" />
                    </entity-find>
                    <iterate list="taxItemList" entry="taxItem">
                        <service-call name="mantle.order.OrderServices.delete#OrderItem"
                            in-map="[orderId:taxItem.orderId, orderItemSeqId:taxItem.orderItemSeqId]" />
                    </iterate>
                    <service-call name="mantle.other.TaxServices.calculate#OrderSalesTax"
                        in-map="[orderId:orderId, orderPartSeqId:orderPartSeqId]" />
                </if>

                <script>ec.context.getSharedMap().remove(sharedFlagKey)</script>

                <service-call name="mantle.order.OrderServices.increment#OrderRevision"
                    in-map="context" />
            </if>
        </actions>
    </service>

    <service verb="update" noun="OrderHeaderTotal">
        <description>Update OrderHeader.grandTotal based on OrderPart.partTotal values, called by update#OrderPartTotal
            which is called by EECA on OrderItem</description>
        <in-parameters>
            <parameter name="orderId" />
        </in-parameters>
        <actions>
            <entity-find-one entity-name="mantle.order.OrderHeader" value-field="orderHeader"
                for-update="true" />
            <set field="totalSum" from="0.0" type="BigDecimal" />
            <entity-find entity-name="mantle.order.OrderPart" list="orderPartList">
                <econdition field-name="orderId" />
            </entity-find>
            <iterate list="orderPartList" entry="orderPart">
                <set field="totalSum" from="totalSum + (orderPart.partTotal ?: 0)" />
            </iterate>
            <set field="orderHeader.grandTotal" from="totalSum" />
            <entity-update value-field="orderHeader" />
        </actions>
    </service>
    <service verb="update" noun="OrderPartTotal">
        <in-parameters>
            <parameter name="orderId" required="true" />
            <parameter name="orderPartSeqId" required="true" />
            <parameter name="originalValue" type="Map" />
        </in-parameters>
        <actions>
            <set field="totalSum" from="0.0" type="BigDecimal" />
            <entity-find entity-name="mantle.order.OrderItem" list="orderItemList">
                <econdition field-name="orderId" />
                <econdition field-name="orderPartSeqId" />
            </entity-find>
            <iterate list="orderItemList" entry="orderItem">
                <service-call name="mantle.order.OrderServices.get#OrderItemTotal"
                    out-map="itemTotalOut" in-map="[orderItem:orderItem]" />
                <set field="totalSum" from="totalSum + itemTotalOut.itemTotal" />
            </iterate>

            <!-- NOTE: CurrencyRoundingMarker scale here may vary by currency, make configurable -->
            <set field="totalSum"
                from="(totalSum as BigDecimal).setScale(2, BigDecimal.ROUND_HALF_UP)" />

            <entity-find-one entity-name="mantle.order.OrderPart" value-field="orderPart"
                for-update="true" />
            <set field="orderPart.partTotal" from="totalSum" />
            <entity-update value-field="orderPart" />

            <!-- if there is one Payment associated with the OrderPart with statusId in
            PmntProposed,PmntPromised update it -->
            <entity-find entity-name="mantle.account.payment.Payment" list="paymentList">
                <econdition field-name="orderId" />
                <econdition field-name="orderPartSeqId" />
                <econdition field-name="statusId" operator="in" value="PmntProposed,PmntPromised" />
                <select-field field-name="paymentId" />
            </entity-find>
            <if condition="paymentList.size() == 1">
                <service-call name="update#mantle.account.payment.Payment"
                    in-map="[paymentId:paymentList.get(0).paymentId, amount:totalSum]" />
                <!-- <log level="warn" message="Set order part ${orderId}:${orderPartSeqId} total to
                ${orderPart.partTotal} and payment ${paymentList.get(0).paymentId} amount to
                ${totalSum}"/> -->
            </if>
            <if condition="paymentList.size() == 0">
                <!-- NOTE: also update Payment records in Declined status since Payment services
                allow retry of auth from Declined -->
                <entity-find entity-name="mantle.account.payment.Payment" list="declinedPaymentList">
                    <econdition field-name="orderId" />
                    <econdition field-name="orderPartSeqId" />
                    <econdition field-name="statusId" operator="in" value="PmntDeclined" />
                    <select-field field-name="paymentId" />
                </entity-find>
                <if condition="declinedPaymentList.size() == 1">
                    <service-call name="update#mantle.account.payment.Payment"
                        in-map="[paymentId:declinedPaymentList.get(0).paymentId, amount:totalSum]" />
                </if>
            </if>

            <!-- now update the OrderHeader.grandTotal -->
            <service-call name="mantle.order.OrderServices.update#OrderHeaderTotal"
                in-map="[orderId:orderId]" />
        </actions>
    </service>
    <service verb="increment" noun="OrderRevision">
        <in-parameters>
            <parameter name="orderId" />
        </in-parameters>
        <actions>
            <if condition="!orderId">
                <return />
            </if>
            <entity-find-one entity-name="mantle.order.OrderHeader" value-field="orderHeader"
                for-update="true">
                <field-map field-name="orderId" />
            </entity-find-one>
            <!-- TODO: not using <select-field field-name="orderId,orderRevision"/> because of issue
            in EntityValue where a bunch of stuff gets set to null -->
            <if condition="orderHeader != null">
                <set field="orderHeader.orderRevision" from="(orderHeader.orderRevision ?: 1) + 1" />
                <entity-update value-field="orderHeader" />
            </if>
        </actions>
    </service>

    <!-- ========== OrderContent Services ========== -->

    <service verb="create" noun="OrderContent">
        <in-parameters>
            <auto-parameters entity-name="mantle.order.OrderContent" include="nonpk">
                <exclude field-name="contentLocation" />
            </auto-parameters>
            <parameter name="orderId" required="true" />
            <parameter name="contentFile" type="org.apache.commons.fileupload.FileItem" />
        </in-parameters>
        <out-parameters>
            <parameter name="orderContentId" />
        </out-parameters>
        <actions>
            <service-call name="create#mantle.order.OrderContent" in-map="context" out-map="context" />
            <if condition="contentFile != null &amp;&amp; contentFile.size &gt; 0">
                <service-call name="mantle.order.OrderServices.save#OrderContentFile"
                    in-map="context" />
            </if>
        </actions>
    </service>
    <service verb="update" noun="OrderContent">
        <in-parameters>
            <parameter name="orderContentId" required="true" />
            <auto-parameters entity-name="mantle.order.OrderContent" include="nonpk">
                <exclude field-name="contentLocation" />
            </auto-parameters>
            <parameter name="contentFile" type="org.apache.commons.fileupload.FileItem" />
        </in-parameters>
        <actions>
            <if condition="contentFile != null &amp;&amp; contentFile.size &gt; 0">
                <entity-find-one entity-name="mantle.order.OrderContent" value-field="orderContent" />
                <service-call name="mantle.order.OrderServices.save#OrderContentFile"
                    out-map="context"
                    in-map="context + [orderId:orderContent.orderId, saveContentLocation:false]" />
            </if>
            <service-call name="update#mantle.order.OrderContent" in-map="context" />
        </actions>
    </service>
    <service verb="save" noun="OrderContentFile">
        <in-parameters>
            <parameter name="orderContentId" required="true" />
            <parameter name="orderId" required="true" />
            <parameter name="contentFile" type="org.apache.commons.fileupload.FileItem"
                required="true" />
            <parameter name="saveContentLocation" type="Boolean" default="true" />
        </in-parameters>
        <out-parameters>
            <parameter name="contentLocation" />
        </out-parameters>
        <actions>
            <set field="filename" from="contentFile.getName()" />
            <if condition="org.moqui.resource.ResourceReference.isTextFilename(filename)">
                <then>
                    <set field="contentRoot"
                        from="ec.user.getPreference('mantle.content.root') ?: 'dbresource://mantle/content'" />
                </then>
                <else>
                    <set field="contentRoot"
                        from="ec.user.getPreference('mantle.content.large.root') ?: 'dbresource://mantle/content'" />
                </else>
            </if>
            <set field="contentLocation"
                value="${contentRoot}/order/${orderId}/content_${orderContentId}/${filename}" />

            <set field="docRr" from="ec.resource.getLocationReference(contentLocation)" />
            <script>
                fileStream = contentFile.getInputStream()
                try { docRr.putStream(fileStream) } finally { fileStream.close() }
            </script>

            <if condition="saveContentLocation">
                <service-call name="update#mantle.order.OrderContent"
                    in-map="[orderContentId:orderContentId, contentLocation:contentLocation]" />
            </if>
        </actions>
    </service>

    <!-- ========== Order-Request Services ========== -->

    <service verb="create" noun="PurchaseRequestOrder">
        <in-parameters>
            <parameter name="requestId" required="true" />
            <parameter name="customerPartyId" required="true">
                <description>The customer for the PO. Should be an Internal Org.</description>
            </parameter>
            <parameter name="paymentInstrumentEnumId" default-value="PiCompanyCheck" />
            <parameter name="paymentMethodId" />
            <parameter name="shipmentMethodEnumId" default-value="ShMthPickUp" />
            <parameter name="placeAndApproveOrders" type="Boolean" default="false" />
        </in-parameters>
        <out-parameters>
            <parameter name="orderId" required="true" />
            <parameter name="orderPartSeqId" required="true" />
        </out-parameters>
        <actions>
            <entity-find-one entity-name="mantle.request.Request" value-field="request" />
            <if condition="!request.facilityId">
                <return error="true" message="Request ${requestId} has no Facility set." />
            </if>

            <entity-find entity-name="mantle.facility.FacilityContactMech" list="postalList"
                cache="true">
                <date-filter />
                <econdition field-name="facilityId" from="request.facilityId" />
                <econdition field-name="contactMechPurposeId" operator="in"
                    value="PostalShippingDest,PostalGeneral" />
                <order-by field-name="-contactMechPurposeId,-fromDate" /><!-- prefer
                PostalShippingDest over PostalGeneral, get most recent -->
            </entity-find>
            <set field="shippingPostalContactMechId" from="postalList?.first?.contactMechId" />

            <entity-find entity-name="mantle.facility.FacilityContactMech" list="phoneList"
                cache="true">
                <date-filter />
                <econdition field-name="facilityId" from="request.facilityId" />
                <econdition field-name="contactMechPurposeId" operator="in"
                    value="PhoneShippingDest,PhonePrimary" />
                <order-by field-name="-contactMechPurposeId,-fromDate" /><!-- prefer
                PhoneShippingDest over PhonePrimary, get most recent -->
            </entity-find>
            <set field="shippingTelecomContactMechId" from="phoneList?.first?.contactMechId" />

            <entity-find entity-name="mantle.request.RequestItem" list="allRequestItemList">
                <econdition field-name="requestId" />
            </entity-find>

            <!-- split request by supplierPartyId, create one PO for each -->
            <set field="requestItemListBySupplier" from="[:]" />
            <iterate list="allRequestItemList" entry="requestItem">
                <if condition="!requestItem.supplierPartyId">
                    <return error="true"
                        message="No Supplier set on item ${requestItem.requestItemSeqId} for Request ${requestId}" />
                </if>
                <script>addToListInMap(requestItem.supplierPartyId, requestItem, requestItemListBySupplier)</script>
            </iterate>

            <iterate list="requestItemListBySupplier" entry="requestItemList" key="supplierPartyId">
                <service-call name="mantle.order.OrderServices.create#Order" out-map="orderOut"
                    in-map="[vendorPartyId:supplierPartyId, customerPartyId:customerPartyId,
                            currencyUomId:(request.currencyUomId ?: 'USD'), facilityId:request.facilityId]" />
                <set field="earliestRequiredByDate" from="null" />
                <iterate list="requestItemList" entry="requestItem">
                    <service-call name="mantle.order.OrderServices.add#OrderProductQuantity"
                        in-map="[orderId:orderOut.orderId, orderPartSeqId:orderOut.orderPartSeqId,
                                productId:requestItem.productId, quantity:requestItem.quantity,
                                itemTypeEnumId:'ItemProduct', requiredByDate:requestItem.requiredByDate]"
                        out-map="addOut" />
                    <service-call name="create#mantle.request.RequestItemOrder"
                        in-map="[requestId:requestItem.requestId, requestItemSeqId:requestItem.requestItemSeqId,
                                orderId:orderOut.orderId, orderItemSeqId:addOut.orderItemSeqId, quantity:requestItem.quantity]" />
                    <if
                        condition="!earliestRequiredByDate || (requestItem.requiredByDate &amp;&amp; requestItem.requiredByDate &lt; earliestRequiredByDate)">
                        <set field="earliestRequiredByDate" from="requestItem.requiredByDate" />
                    </if>
                </iterate>
                <if condition="earliestRequiredByDate">
                    <service-call name="update#mantle.order.OrderPart"
                        in-map="[orderId:orderOut.orderId,
                            orderPartSeqId:orderOut.orderPartSeqId, shipBeforeDate:earliestRequiredByDate]" />
                </if>
                <service-call name="mantle.order.OrderServices.set#OrderBillingShippingInfo"
                    in-map="[orderId:orderOut.orderId, orderPartSeqId:orderOut.orderPartSeqId,
                            paymentInstrumentEnumId:paymentInstrumentEnumId, paymentMethodId:paymentMethodId,
                            shippingPostalContactMechId:shippingPostalContactMechId,
                            shippingTelecomContactMechId:shippingTelecomContactMechId,
                            shipmentMethodEnumId:shipmentMethodEnumId]" />
                <if condition="placeAndApproveOrders">
                    <service-call name="mantle.order.OrderServices.place#Order"
                        in-map="[orderId:orderOut.orderId, orderPartSeqId:orderOut.orderPartSeqId]" />
                    <service-call name="mantle.order.OrderServices.approve#Order"
                        in-map="[orderId:orderOut.orderId, orderPartSeqId:orderOut.orderPartSeqId]" />
                </if>
            </iterate>

            <!-- Order created for Purchase Request, set Request status to In Progress -->
            <service-call name="update#mantle.request.Request"
                in-map="[requestId:requestId, statusId:'ReqInProgress']" />
        </actions>
    </service>
</services>