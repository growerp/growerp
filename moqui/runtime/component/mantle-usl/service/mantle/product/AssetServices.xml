<?xml version="1.0" encoding="UTF-8"?>
<!--
This software is in the public domain under CC0 1.0 Universal plus a 
Grant of Patent License.

To the extent possible under law, the author(s) have dedicated all
copyright and related and neighboring rights to this software to the
public domain worldwide. This software is distributed without any
warranty.

You should have received a copy of the CC0 Public Domain Dedication
along with this software (see the LICENSE.md file). If not, see
<http://creativecommons.org/publicdomain/zero/1.0/>.
-->
<services xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://moqui.org/xsd/service-definition-3.xsd">

    <!-- ========== Get and Info Services ========== -->

    <service verb="get" noun="AssetDisplayInfo">
        <in-parameters><parameter name="assetId"/></in-parameters>
        <out-parameters>
            <parameter name="asset" type="EntityValue"/>
            <parameter name="isFixedAsset" type="Boolean"/>
            <parameter name="statusItem" type="EntityValue"/>
            <parameter name="statusId"/>
            <parameter name="statusHistoryList" type="EntityList"><parameter name="auditLog" type="EntityValue"/></parameter>
            <parameter name="product" type="EntityValue"/>
            <parameter name="facility" type="EntityValue"/>
            <parameter name="facilityLocation" type="EntityValue"/>
            <parameter name="originFacility" type="EntityValue"/>
            <parameter name="assetDetailList" type="EntityList"><parameter name="assetDetail" type="EntityValue"/></parameter>
            <parameter name="assetReservationList" type="EntityList"><parameter name="assetReservation" type="EntityValue"/></parameter>
        </out-parameters>
        <actions>
            <entity-find-one entity-name="mantle.product.asset.Asset" value-field="asset"/>
            <if condition="asset == null"><return error="true" message="Asset not found with ID ${assetId}"/></if>

            <set field="isFixedAsset" from="!(asset.assetTypeEnumId in ['AstTpInventory', 'AstTpSupplies'])"/>

            <set field="statusItem" from="asset.'Asset#moqui.basic.StatusItem'"/>
            <entity-find entity-name="moqui.entity.EntityAuditLog" list="statusHistoryList">
                <econdition field-name="changedEntityName" value="mantle.product.asset.Asset"/>
                <econdition field-name="changedFieldName" value="statusId"/>
                <econdition field-name="pkPrimaryValue" from="assetId"/>
                <order-by field-name="changedDate"/>
            </entity-find>
            <set field="statusId" from="asset.statusId"/>

            <set field="facility" from="asset.'mantle.facility.Facility'"/>
            <set field="facilityLocation" from="asset.'mantle.facility.FacilityLocation'"/>
            <set field="product" from="asset.'mantle.product.Product'"/>
            <set field="originFacility" from="asset.'Origin#mantle.facility.Facility'"/>

            <entity-find entity-name="mantle.product.asset.AssetDetail" list="assetDetailList" limit="20">
                <econdition field-name="assetId"/><order-by field-name="-effectiveDate"/></entity-find>
            <entity-find entity-name="mantle.product.issuance.AssetReservation" list="assetReservationList">
                <econdition field-name="assetId"/><order-by field-name="reservedDate"/></entity-find>
        </actions>
    </service>

    <service verb="get" noun="AvailableInventory">
        <in-parameters>
            <parameter name="productId" required="true"/>
            <parameter name="facilityId"/>
            <parameter name="productStoreId"><description>If specified get facilities and vendor from store, must specify products or categories separately</description></parameter>
            <parameter name="vendorPartyId"><description>Defaults to ProductStore.organizationPartyId; used for ownerPartyId filter and AssetPool lookup by Vendor</description></parameter>
            <parameter name="customerPartyId"><description>Used for AssetPool lookup by Customer</description></parameter>
        </in-parameters>
        <out-parameters><parameter name="availableToPromiseTotal" type="BigDecimal"/></out-parameters>
        <actions>
            <entity-find-one entity-name="mantle.product.Product" value-field="product" cache="true"/>
            <if condition="!(product?.productTypeEnumId in ['PtAsset', 'PtDigitalAsset', 'PtAssetUse', 'PtPickAssembly'])">
                <log level="warn" message="AssetServices.get#AvailableInventory called for Product ${productId} with type ${product?.productTypeEnumId}, only applicable for PtAsset, PtDigitalAsset, PtAssetUse, PtPickAssembly"/></if>

            <set field="facilityIdSet" from="new HashSet()"/>
            <if condition="facilityId"><script>facilityIdSet.add(facilityId)</script></if>

            <!-- ProductStore based values -->
            <if condition="productStoreId">
                <entity-find-one entity-name="mantle.product.store.ProductStore" value-field="productStore"/>
                <if condition="!vendorPartyId"><set field="vendorPartyId" from="productStore?.organizationPartyId"/></if>
                <if condition="facilityIdSet.size() == 0">
                    <!-- get facilities from store -->
                    <if condition="productStore.inventoryFacilityId">
                        <script>facilityIdSet.add(productStore.inventoryFacilityId)</script></if>
                    <entity-find entity-name="mantle.product.store.ProductStoreFacility" list="productStoreFacilityList">
                        <date-filter/><econdition field-name="productStoreId"/></entity-find>
                    <if condition="productStoreFacilityList">
                        <script>facilityIdSet.addAll(productStoreFacilityList*.facilityId)</script></if>
                </if>
            </if>

            <!-- compile set of ownerPartyId values -->
            <set field="ownerPartyIdSet" from="new HashSet()"/>
            <if condition="vendorPartyId">
                <script>ownerPartyIdSet.add(vendorPartyId)</script>
                <!-- look for parent org(s) if any, include assets from parent org too -->
                <entity-find entity-name="mantle.party.PartyRelationship" list="parentRelList" cache="true">
                    <date-filter/>
                    <econdition field-name="relationshipTypeEnumId" value="PrtOrgRollup"/>
                    <econdition field-name="fromPartyId" from="vendorPartyId"/>
                    <econdition field-name="toPartyId" operator="is-not-null"/>
                </entity-find>
                <script>if (parentRelList) ownerPartyIdSet.addAll(parentRelList*.toPartyId)</script>
            </if>

            <!-- compile set of assetPoolId values -->
            <service-call name="mantle.product.AssetServices.get#AssetPools" out-map="poolsOut"
                    in-map="[productStoreId:productStoreId, vendorPartyId:vendorPartyId, customerPartyId:customerPartyId]"/>
            <set field="assetPoolIdSet" from="poolsOut.assetPoolIdSet"/>

            <set field="availableToPromiseTotal" from="0.0"/>
            <!-- to support assetAllowOtherOwner may need to do query per Facility... -->
            <iterate list="facilityIdSet" entry="facilityId">
                <entity-find-one entity-name="mantle.facility.Facility" value-field="facility" cache="true"/>

                <entity-find entity-name="mantle.product.asset.AssetQuantitySummary" list="quantSumList">
                    <econdition field-name="productId"/>
                    <econdition field-name="facilityId"/>
                    <econdition field-name="ownerPartyId" operator="in" from="ownerPartyIdSet"
                            ignore="facility?.assetAllowOtherOwner == 'Y' || !ownerPartyIdSet"/>
                    <econdition field-name="assetPoolId" operator="in" from="assetPoolIdSet" ignore="!assetPoolIdSet" or-null="true"/>
                    <econdition field-name="assetPoolId" operator="is-null" ignore="assetPoolIdSet"/>
                    <econdition field-name="statusId" value="AstAvailable"/>
                    <select-field field-name="availableToPromiseTotal"/>
                </entity-find>
                <if condition="quantSumList.size() &gt; 0 &amp;&amp; quantSumList[0].availableToPromiseTotal">
                    <set field="availableToPromiseTotal" from="availableToPromiseTotal + quantSumList[0].availableToPromiseTotal"/></if>

                <!-- if Product is a Pick Assembly (productTypeEnumId=PtPickAssembly) add available inventory from BOM components -->
                <if condition="product.productTypeEnumId == 'PtPickAssembly'">
                    <entity-find entity-name="mantle.product.ProductAssoc" list="assocList">
                        <date-filter/>
                        <econdition field-name="productId" from="product.productId"/>
                        <econdition field-name="productAssocTypeEnumId" value="PatMfgBom"/>
                    </entity-find>
                    <set field="availableFromComponents" from="0.0"/>
                    <iterate list="assocList" entry="assoc">
                        <service-call name="mantle.product.AssetServices.get#AvailableInventory" out-map="compAvailOut" out-map-add-to-existing="false"
                                in-map="[productId:assoc.toProductId, facilityId:facilityId, productStoreId:productStoreId,
                                    vendorPartyId:vendorPartyId, customerPartyId:customerPartyId]"/>
                        <!-- NOTE: digits to round? asset qty can be non-integer, but most products are and we want that -->
                        <set field="compScale" from="assoc.quantity != null ? assoc.quantity.scale() : 0"/>
                        <set field="componentAvailable" from="(compAvailOut.availableToPromiseTotal ?: 0.0).divide((assoc.quantity ?: 1.0), compScale, BigDecimal.ROUND_FLOOR)"/>
                        <!-- <log level="warn" message="comp prod ${assoc.toProductId} ATP ${compAvailOut.availableToPromiseTotal} comp qty ${assoc.quantity} (scale ${compScale}) calc avail ${componentAvailable}"/> -->
                        <if condition="availableFromComponents == 0.0 || availableFromComponents &gt; componentAvailable">
                            <set field="availableFromComponents" from="componentAvailable"/></if>
                    </iterate>
                    <!-- <log level="warn" message="available pre add availableToPromiseTotal ${availableToPromiseTotal} availableFromComponents ${availableFromComponents}"/> -->
                    <set field="availableToPromiseTotal" from="availableToPromiseTotal + availableFromComponents"/>
                </if>
            </iterate>
        </actions>
    </service>
    <!-- NOTE: get#AvailableByStore removed as is no longer used and get#AvailableInventory may be used instead -->
    <service verb="get" noun="AvailableForOrder">
        <in-parameters>
            <parameter name="productId" required="true"/>
            <parameter name="orderId" required="true"/>
            <parameter name="orderPartSeqId" required="true"/>
            <parameter name="orderItemSeqId"><description>Should be specified for updates to add in existing reservations (also available to the OrderItem)</description></parameter>
            <parameter name="orderHeader" type="EntityValue"/>
            <parameter name="orderPart" type="EntityValue"/>
        </in-parameters>
        <out-parameters><parameter name="availableToPromiseTotal" type="BigDecimal"/></out-parameters>
        <actions>
            <if condition="orderHeader == null"><entity-find-one entity-name="mantle.order.OrderHeader" value-field="orderHeader"/></if>
            <if condition="orderPart == null"><entity-find-one entity-name="mantle.order.OrderPart" value-field="orderPart"/></if>

            <if condition="!orderPart.facilityId &amp;&amp; !orderHeader.productStoreId">
                <return type="warning" message="Cannot get available inventory for order ${orderId} part ${orderPartSeqId}, no facility on order part and no store on header"/></if>

            <service-call name="mantle.product.AssetServices.get#AvailableInventory" out-map="context"
                    in-map="[productId:productId, facilityId:orderPart.facilityId, productStoreId:orderHeader.productStoreId,
                        vendorPartyId:orderPart.vendorPartyId, customerPartyId:orderPart.customerPartyId]"/>

            <!-- get current quantity reserved (for updates) -->
            <if condition="orderItemSeqId">
                <entity-find entity-name="mantle.product.issuance.AssetReservationSummary" list="resSumList">
                    <econdition field-name="orderId"/>
                    <econdition field-name="orderItemSeqId"/>
                    <econdition field-name="productId"/>
                    <select-field field-name="quantity,quantityNotAvailable"/>
                </entity-find>
                <if condition="resSumList.size() &gt; 0">
                    <set field="resQuantity" from="resSumList[0].quantity"/>
                    <set field="resQuantityNotAvailable" from="resSumList[0].quantityNotAvailable"/>
                    <set field="availableToPromiseTotal" from="(availableToPromiseTotal ?: 0.0) + (resQuantity ?: 0.0) - (resQuantityNotAvailable ?: 0.0)"/>
                </if>

                <!-- if Product is a Pick Assembly (productTypeEnumId=PtPickAssembly) adjust by reserve qty and qty not available from BOM components -->
                <entity-find-one entity-name="mantle.product.Product" value-field="product" cache="true"/>
                <if condition="product.productTypeEnumId == 'PtPickAssembly'">
                    <entity-find entity-name="mantle.product.issuance.AssetReservationSummary" list="allResSumList">
                        <econdition field-name="orderId"/>
                        <econdition field-name="orderItemSeqId"/>
                        <select-field field-name="productId,quantity,quantityNotAvailable"/>
                    </entity-find>

                    <entity-find entity-name="mantle.product.ProductAssoc" list="assocList" cache="true">
                        <date-filter/>
                        <econdition field-name="productId" from="product.productId"/>
                        <econdition field-name="productAssocTypeEnumId" value="PatMfgBom"/>
                    </entity-find>
                    <set field="reservedFromComponents" from="0.0"/>
                    <set field="reservedNotAvailFromComponents" from="0.0"/>
                    <iterate list="assocList" entry="assoc">
                        <set field="curResSum" from="allResSumList.find({ it.productId == assoc.toProductId })"/>
                        <!-- NOTE: digits to round? asset qty can be non-integer, but most products are and we want that -->
                        <set field="compScale" from="assoc.quantity != null ? assoc.quantity.scale() : 0"/>
                        <set field="resQuantity" from="(curResSum.quantity ?: 0.0).divide((assoc.quantity ?: 1.0), compScale, BigDecimal.ROUND_FLOOR)"/>
                        <set field="resQuantityNotAvailable" from="(curResSum.quantityNotAvailable ?: 0.0).divide((assoc.quantity ?: 1.0), compScale, BigDecimal.ROUND_FLOOR)"/>

                        <log level="warn" message="order item ${orderId}:${orderItemSeqId} comp prod ${assoc.toProductId} res qty ${curResSum.quantity} not avail ${curResSum.quantityNotAvailable} comp qty ${assoc.quantity} (scale ${compScale}) resQuantity ${resQuantity} resQuantityNotAvailable ${resQuantityNotAvailable}"/>

                        <if condition="reservedFromComponents == 0.0 || reservedFromComponents &gt; resQuantity">
                            <set field="reservedFromComponents" from="resQuantity"/></if>
                        <!-- this is different, don't want lowest number want highest number for cumulative not available qty -->
                        <if condition="reservedNotAvailFromComponents &lt; resQuantityNotAvailable">
                            <set field="reservedNotAvailFromComponents" from="resQuantityNotAvailable"/></if>
                    </iterate>
                    <set field="availableToPromiseTotal" from="(availableToPromiseTotal ?: 0.0) + reservedFromComponents - reservedNotAvailFromComponents"/>
                </if>
            </if>
        </actions>
    </service>

    <service verb="get" noun="AvailableInventoryMulti">
        <in-parameters>
            <parameter name="productIds" type="Collection"><description>At least one product required, can get from category</description></parameter>
            <parameter name="productCategoryIds" type="Collection"/>
            <parameter name="expandVariants" type="Boolean" default="false"/>
            <parameter name="productStoreId"><description>If specified get facilities and vendor from store, must specify products or categories separately</description></parameter>
            <parameter name="facilityIds" type="Collection"><description>At least one facility required, can get from store</description></parameter>
            <parameter name="vendorPartyId"><description>Defaults to ProductStore.organizationPartyId; used for ownerPartyId filter and AssetPool lookup by Vendor</description></parameter>
            <parameter name="customerPartyId"><description>Used for AssetPool lookup by Customer</description></parameter>
        </in-parameters>
        <out-parameters>
            <parameter name="availableByProductId" type="Map">
                <description>Key is productId, value is BigDecimal for available to promise total quantity</description></parameter>
        </out-parameters>
        <actions>
            <!-- compile set of productId values -->
            <set field="productIdSet" from="new HashSet()"/>
            <if condition="productIds"><script>productIdSet.addAll(productIds)</script></if>
            <if condition="productCategoryIds">
                <entity-find entity-name="mantle.product.category.ProductCategoryMember" list="pcmList" distinct="true">
                    <date-filter/>
                    <econdition field-name="productCategoryId" operator="in" from="productCategoryIds"/>
                    <select-field field-name="productId"/>
                </entity-find>
                <if condition="pcmList"><script>productIdSet.addAll(pcmList*.productId)</script></if>
            </if>
            <if condition="expandVariants">
                <set field="newProductIdSet" from="new HashSet()"/>
                <!-- go through each product, get cached product record and if productTypeEnumId = PtVirtual look up variants -->
                <iterate list="productIdSet" entry="productId">
                    <entity-find-one entity-name="mantle.product.Product" value-field="product" cache="true"/>
                    <if condition="product.productTypeEnumId == 'PtVirtual'"><then>
                        <entity-find entity-name="mantle.product.ProductAssoc" list="variantAssocList" cache="true">
                            <date-filter/>
                            <econdition field-name="productId"/>
                            <econdition field-name="productAssocTypeEnumId" value="PatVariant"/>
                        </entity-find>
                        <if condition="variantAssocList">
                            <script>newProductIdSet.addAll(variantAssocList*.toProductId)</script></if>
                    </then><else>
                        <script>newProductIdSet.add(productId)</script>
                    </else></if>
                </iterate>
                <set field="productIdSet" from="newProductIdSet"/>
            </if>

            <!-- compile set of facilityId values -->
            <set field="facilityIdSet" from="new HashSet()"/>
            <if condition="facilityIds"><script>facilityIdSet.addAll(facilityIds)</script></if>

            <!-- ProductStore based values -->
            <if condition="productStoreId">
                <entity-find-one entity-name="mantle.product.store.ProductStore" value-field="productStore"/>
                <if condition="!vendorPartyId"><set field="vendorPartyId" from="productStore?.organizationPartyId"/></if>
                <!-- get facilities from store if none specified in parameter -->
                <if condition="facilityIdSet.size() == 0">
                    <if condition="productStore.inventoryFacilityId">
                        <script>facilityIdSet.add(productStore.inventoryFacilityId)</script></if>
                    <entity-find entity-name="mantle.product.store.ProductStoreFacility" list="productStoreFacilityList">
                        <date-filter/><econdition field-name="productStoreId"/></entity-find>
                    <if condition="productStoreFacilityList">
                        <script>facilityIdSet.addAll(productStoreFacilityList*.facilityId)</script></if>
                </if>
            </if>

            <!-- compile set of ownerPartyId values -->
            <set field="ownerPartyIdSet" from="new HashSet()"/>
            <if condition="vendorPartyId">
                <script>ownerPartyIdSet.add(vendorPartyId)</script>
                <!-- look for parent org(s) if any, include assets from parent org too -->
                <entity-find entity-name="mantle.party.PartyRelationship" list="parentRelList" cache="true">
                    <date-filter/>
                    <econdition field-name="relationshipTypeEnumId" value="PrtOrgRollup"/>
                    <econdition field-name="fromPartyId" from="vendorPartyId"/>
                    <econdition field-name="toPartyId" operator="is-not-null"/>
                </entity-find>
                <script>if (parentRelList) ownerPartyIdSet.addAll(parentRelList*.toPartyId)</script>
            </if>

            <!-- compile set of assetPoolId values -->
            <service-call name="mantle.product.AssetServices.get#AssetPools" out-map="poolsOut"
                    in-map="[productStoreId:productStoreId, vendorPartyId:vendorPartyId, customerPartyId:customerPartyId]"/>
            <set field="assetPoolIdSet" from="poolsOut.assetPoolIdSet"/>

            <!-- prep the output Map -->
            <set field="availableByProductId" from="[:]"/>
            <!-- to support assetAllowOtherOwner may need to do query per Facility... -->
            <iterate list="facilityIdSet" entry="facilityId">
                <entity-find-one entity-name="mantle.facility.Facility" value-field="facility" cache="true"/>

                <entity-find entity-name="mantle.product.asset.AssetSummaryView" list="assetSummaryList">
                    <econdition field-name="facilityId"/>
                    <econdition field-name="productId" operator="in" from="productIdSet"/>
                    <econdition field-name="ownerPartyId" operator="in" from="ownerPartyIdSet"
                            ignore="facility?.assetAllowOtherOwner == 'Y' || !ownerPartyIdSet"/>
                    <econdition field-name="assetPoolId" operator="in" from="assetPoolIdSet" ignore="!assetPoolIdSet" or-null="true"/>
                    <econdition field-name="assetPoolId" operator="is-null" ignore="assetPoolIdSet"/>
                    <econdition field-name="statusId" value="AstAvailable"/>
                    <having-econditions>
                        <econdition field-name="availableToPromiseTotal" operator="not-equals" from="0.0"/>
                    </having-econditions>
                    <select-field field-name="productId,availableToPromiseTotal"/>
                    <order-by field-name="productId"/>
                </entity-find>
                <script><![CDATA[
                    for (int i = 0; i < assetSummaryList.size(); i++) {
                        Map assetSummary = (Map) assetSummaryList.get(i)
                        addToBigDecimalInMap(assetSummary.productId, assetSummary.availableToPromiseTotal, availableByProductId)
                    }
                ]]></script>

                <!-- for any Product that is a Pick Assembly (productTypeEnumId=PtPickAssembly) add available inventory from BOM components -->
                <!-- TODO: this could get a lot fancier and faster with bulk operations or where not possible perhaps multi-thread -->
                <iterate list="productIdSet" entry="productId">
                    <entity-find-one entity-name="mantle.product.Product" value-field="product" cache="true"/>

                    <if condition="product.productTypeEnumId == 'PtPickAssembly'">
                        <entity-find entity-name="mantle.product.ProductAssoc" list="assocList">
                            <date-filter/>
                            <econdition field-name="productId" from="product.productId"/>
                            <econdition field-name="productAssocTypeEnumId" value="PatMfgBom"/>
                        </entity-find>
                        <set field="availableFromComponents" from="0.0"/>
                        <iterate list="assocList" entry="assoc">
                            <service-call name="mantle.product.AssetServices.get#AvailableInventory" out-map="compAvailOut" out-map-add-to-existing="false"
                                    in-map="[productId:assoc.toProductId, facilityId:facilityId, productStoreId:productStoreId,
                                    vendorPartyId:vendorPartyId, customerPartyId:customerPartyId]"/>
                            <!-- NOTE: digits to round? asset qty can be non-integer, but most products are and we want that -->
                            <set field="compScale" from="assoc.quantity != null ? assoc.quantity.scale() : 0"/>
                            <set field="componentAvailable" from="(compAvailOut.availableToPromiseTotal ?: 0.0).divide((assoc.quantity ?: 1.0), compScale, BigDecimal.ROUND_FLOOR)"/>
                            <!-- <log level="warn" message="multi comp prod ${assoc.toProductId} ATP ${compAvailOut.availableToPromiseTotal} comp qty ${assoc.quantity} (scale ${compScale}) calc avail ${componentAvailable}"/> -->
                            <if condition="availableFromComponents == 0.0 || availableFromComponents &gt; componentAvailable">
                                <set field="availableFromComponents" from="componentAvailable"/></if>
                        </iterate>
                        <!-- <log level="warn" message="multi available pre add availableToPromiseTotal ${availableToPromiseTotal} availableFromComponents ${availableFromComponents}"/> -->
                        <script>addToBigDecimalInMap(product.productId, availableFromComponents, availableByProductId)</script>
                    </if>
                </iterate>
            </iterate>
        </actions>
    </service>

    <!-- ========== Update Services ========== -->

    <service verb="update" noun="Asset">
        <in-parameters>
            <parameter name="assetId" required="true"/>
            <auto-parameters entity-name="mantle.product.asset.Asset" include="nonpk">
                <exclude field-name="productId"/><exclude field-name="hasQuantity"/>
                <exclude field-name="quantityOnHandTotal"/><exclude field-name="availableToPromiseTotal"/>
                <!-- NOTE: use update#AssetAcquireCost to change acquireCost and ownerPartyId -->
                <exclude field-name="acquireCost"/><exclude field-name="ownerPartyId"/>
                <!-- NOTE: use move#Asset to change facilityId, locationSeqId, assetPoolId (much more complex logic there) -->
                <exclude field-name="facilityId"/><exclude field-name="locationSeqId"/>
                <exclude field-name="assetPoolId"/>
            </auto-parameters>
        </in-parameters>
        <out-parameters><parameter name="oldStatusId"/><parameter name="statusChanged" type="Boolean"/></out-parameters>
        <actions>
            <service-call name="update#mantle.product.asset.Asset" in-map="context" out-map="context"/>
        </actions>
    </service>
    <service verb="update" noun="AssetAcquireCost" transaction-timeout="600">
        <description>Update (or set) Asset.acquireCost and re-post all GL transactions for receipt, issuance, and physical inventory changes.</description>
        <in-parameters>
            <parameter name="assetId" required="true"/>
            <parameter name="acquireCost" type="BigDecimal" required="true"/>
            <parameter name="ownerPartyId"/>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="mantle.product.asset.Asset" value-field="asset" for-update="true"/>
            <set field="asset.acquireCost" from="acquireCost"/>
            <if condition="ownerPartyId"><set field="asset.ownerPartyId" from="ownerPartyId"/></if>
            <entity-update value-field="asset"/>

            <service-call name="mantle.ledger.AssetAutoPostServices.repost#Asset" in-map="[assetId:assetId]"/>
            <!-- TODO: consider re-evaluating all reservations if ownerPartyId changes, may need to bump or inventory may be available for not available reservations -->
        </actions>
    </service>
    <service verb="update" noun="ProductAcquireCost" transaction-timeout="600">
        <description>For given productId and optional facilityId, receivedDate_from, and receivedDate_thru: update (or set)
            all Asset.acquireCost and re-post all GL transactions for receipt, issuance, and physical inventory changes.</description>
        <in-parameters>
            <parameter name="productId" required="true"/>
            <parameter name="facilityId"/>
            <parameter name="receivedDate_from" type="Timestamp"/>
            <parameter name="receivedDate_thru" type="Timestamp"/>
            <parameter name="acquireCost" type="BigDecimal" required="true"/>
            <parameter name="ownerPartyId"/>
        </in-parameters>
        <actions>
            <entity-find entity-name="mantle.product.asset.Asset" list="assetList">
                <econdition field-name="productId"/>
                <econdition field-name="facilityId" ignore-if-empty="true"/>
                <econdition field-name="receivedDate" operator="greater-equals" from="receivedDate_from" ignore-if-empty="true"/>
                <econdition field-name="receivedDate" operator="less-equals" from="receivedDate_thru" ignore-if-empty="true"/>
                <select-field field-name="assetId"/>
            </entity-find>
            <iterate list="assetList" entry="asset">
                <service-call name="mantle.product.AssetServices.update#AssetAcquireCost"
                        in-map="[assetId:asset.assetId, acquireCost:acquireCost, ownerPartyId:ownerPartyId]"/>
            </iterate>
            <message>Updated Acquire Cost to ${acquireCost?.toPlainString()} on ${assetList.size()} Asset records for Product ${productId}, Facility ${facilityId?:'*'}, Received From ${receivedDate_from?:'*'} Thru ${receivedDate_thru?:'*'}</message>
        </actions>
    </service>

    <service verb="update" noun="AssetFromDetail" no-tx-cache="true">
        <description>Called by EECA rule to update Asset quantities when an AssetDetail record is created.</description>
        <in-parameters>
            <parameter name="assetId" required="true"/>
            <parameter name="availableToPromiseDiff" type="BigDecimal"/>
            <parameter name="quantityOnHandDiff" type="BigDecimal"/>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="mantle.product.asset.Asset" value-field="asset" for-update="true">
                <field-map field-name="assetId"/></entity-find-one>

            <!-- <log message="========== start update#AssetFromDetail ${assetId}: ${availableToPromiseDiff}/${quantityOnHandDiff} :: ${asset.availableToPromiseTotal}/${asset.quantityOnHandTotal}"/> -->

            <!-- View queries won't work with transaction cache (for data updated within the tx), so if active use different approach -->
            <if condition="ec.transaction.isTransactionCacheActive()"><then>
                <!-- incremental update -->
                <set field="asset.availableToPromiseTotal" from="(asset.availableToPromiseTotal ?: 0.0) + (availableToPromiseDiff ?: 0.0)"/>
                <set field="asset.quantityOnHandTotal" from="(asset.quantityOnHandTotal ?: 0.0) + (quantityOnHandDiff ?: 0.0)"/>
            </then><else>
                <!-- sum all records, update with new totals -->
                <entity-find entity-name="mantle.product.asset.AssetDetailSummary" list="assetDetailSummaryList">
                    <econdition field-name="assetId"/>
                    <select-field field-name="availableToPromiseTotal,quantityOnHandTotal"/>
                </entity-find>
                <if condition="assetDetailSummaryList.size() &gt; 0"><then>
                    <set field="assetDetailSummary" from="assetDetailSummaryList[0]"/>
                    <set field="asset.availableToPromiseTotal" from="assetDetailSummary.availableToPromiseTotal ?: 0.0"/>
                    <set field="asset.quantityOnHandTotal" from="assetDetailSummary.quantityOnHandTotal ?: 0.0"/>
                </then><else>
                    <set field="asset.availableToPromiseTotal" from="(asset.availableToPromiseTotal ?: 0.0) + (availableToPromiseDiff ?: 0.0)"/>
                    <set field="asset.quantityOnHandTotal" from="(asset.quantityOnHandTotal ?: 0.0) + (quantityOnHandDiff ?: 0.0)"/>
                </else></if>
            </else></if>

            <entity-update value-field="asset"/>

            <!-- never let quantityOnHandTotal stay negative, do a physical inventory found for the difference -->
            <!-- NOTE: this may be better to do at a higher level in some cases, but this will make sure -->
            <if condition="asset.quantityOnHandTotal &lt; 0">
                <service-call name="mantle.product.AssetServices.record#PhysicalInventoryChange"
                        in-map="[productId:asset.productId, facilityId:asset.facilityId, locationSeqId:asset.locationSeqId,
                            quantityChange:-asset.quantityOnHandTotal, varianceReasonEnumId:'InVrFound',
                            assetList:[asset]]"/>
            </if>

            <!-- <set field="message" from="'========== end update#AssetFromDetail ' + assetId + ': ' + availableToPromiseDiff + '/' + quantityOnHandDiff + ' :: ' + asset.availableToPromiseTotal + '/' + asset.quantityOnHandTotal"/><log message="${message}"/> -->
        </actions>
    </service>
    <service verb="recalculate" noun="AllAssetTotals" transaction-timeout="1800">
        <description>Recalculate availableToPromiseTotal and quantityOnHandTotal from AssetDetail records, optionally constrained by parameters</description>
        <in-parameters>
            <parameter name="facilityId"/>
            <parameter name="productId"/>
        </in-parameters>
        <actions>
            <entity-find entity-name="mantle.product.asset.Asset" list="assetList">
                <econdition field-name="hasQuantity" value="Y"/>
                <econdition field-name="facilityId" ignore-if-empty="true"/>
                <econdition field-name="productId" ignore-if-empty="true"/>
                <select-field field-name="assetId,productId,facilityId,availableToPromiseTotal,quantityOnHandTotal"/>
            </entity-find>

            <set field="recordsChecked" from="assetList.size()"/>
            <set field="recordsUpdated" from="0"/>
            <message>Checking ${recordsChecked} Asset record totals for Product ${productId?:'*'} Facility ${facilityId?:'*'}</message>

            <iterate list="assetList" entry="asset">
                <entity-find entity-name="mantle.product.asset.AssetDetailSummary" list="assetDetailSummaryList">
                    <econdition field-name="assetId" from="asset.assetId"/>
                    <select-field field-name="availableToPromiseTotal,quantityOnHandTotal"/>
                </entity-find>
                <if condition="assetDetailSummaryList.size() &gt; 0"><then>
                    <set field="assetDetailSummary" from="assetDetailSummaryList[0]"/>
                    <set field="calcAtp" from="assetDetailSummary.availableToPromiseTotal ?: 0.0"/>
                    <set field="calcQoh" from="assetDetailSummary.quantityOnHandTotal ?: 0.0"/>
                    <if condition="asset.availableToPromiseTotal != calcAtp || asset.quantityOnHandTotal != calcQoh">
                        <log message="Asset ${asset.assetId} Product ${asset.productId} Facility ${asset.facilityId} has incorrect totals: ATP is ${asset.availableToPromiseTotal}, should be ${calcAtp}; QOH is ${asset.quantityOnHandTotal}, should be ${calcQoh}; updating"/>
                        <set field="recordsUpdated" from="recordsUpdated + 1"/>
                        <set field="asset.availableToPromiseTotal" from="calcAtp"/>
                        <set field="asset.quantityOnHandTotal" from="calcQoh"/>
                        <entity-update value-field="asset"/>
                    </if>
                </then><else>
                    <if condition="asset.availableToPromiseTotal != 0.0 || asset.quantityOnHandTotal != 0.0">
                        <log message="Asset ${asset.assetId} Product ${asset.productId} Facility ${asset.facilityId} has no Detail records and non-zero totals: ATP is ${asset.availableToPromiseTotal}; QOH is ${asset.quantityOnHandTotal}; setting both to zero"/>
                        <set field="recordsUpdated" from="recordsUpdated + 1"/>
                        <set field="asset.availableToPromiseTotal" from="0.0"/>
                        <set field="asset.quantityOnHandTotal" from="0.0"/>
                        <entity-update value-field="asset"/>
                    </if>
                </else></if>

                <!-- NOTE: check reservations? for all or only those changed above? maybe better as a separate service since this is heavy/slow logic?
                  - Don't do this, instead if needed call mantle.product.AssetServices.check#FacilityReservations service.
                <service-call name="mantle.product.AssetServices.check#AssetReservations" in-map="[assetId:asset.assetId]"/> -->
            </iterate>

            <message>Checking ${recordsChecked} Asset record totals for Product ${productId?:'*'} Facility ${facilityId?:'*'}, updated ${recordsUpdated} with incorrect totals</message>
        </actions>
    </service>

    <!-- ========================================== -->
    <!-- ========== Reservation Services ========== -->
    <!-- ========================================== -->

    <service verb="get" noun="AssetPools">
        <in-parameters>
            <parameter name="productStoreId"/>
            <parameter name="vendorPartyId"/>
            <parameter name="customerPartyId"/>
        </in-parameters>
        <out-parameters>
            <parameter name="assetPoolIdSet" type="Set"/>
        </out-parameters>
        <actions>
            <set field="assetPoolIdSet" from="new TreeSet()"/>
            <if condition="productStoreId">
                <entity-find entity-name="mantle.product.asset.AssetPoolStore" list="assetPoolStoreList" cache="true">
                    <econdition field-name="productStoreId"/></entity-find>
                <if condition="assetPoolStoreList">
                    <script>assetPoolIdSet.addAll(assetPoolStoreList*.assetPoolId)</script></if>
            </if>
            <if condition="vendorPartyId">
                <entity-find entity-name="mantle.product.asset.AssetPoolParty" list="vendorPoolPartyList" cache="true">
                    <econdition field-name="partyId" from="vendorPartyId"/></entity-find>
                <!-- filter by role or null after for better caching -->
                <set field="vendorPoolPartyList" from="vendorPoolPartyList.findAll({ it.roleTypeId == null || it.roleTypeId == 'Vendor' })"/>
                <if condition="vendorPoolPartyList">
                    <script>assetPoolIdSet.addAll(vendorPoolPartyList*.assetPoolId)</script></if>
            </if>
            <if condition="customerPartyId">
                <entity-find entity-name="mantle.product.asset.AssetPoolParty" list="customerPoolPartyList" cache="true">
                    <econdition field-name="partyId" from="customerPartyId"/></entity-find>
                <!-- filter by role or null after for better caching -->
                <set field="customerPoolPartyList" from="customerPoolPartyList.findAll({ it.roleTypeId == null || it.roleTypeId == 'Customer' })"/>
                <if condition="customerPoolPartyList">
                    <script>assetPoolIdSet.addAll(customerPoolPartyList*.assetPoolId)</script></if>
            </if>
        </actions>
    </service>

    <service verb="reserve" noun="AssetsForOrder" no-tx-cache="true">
        <description>Triggered by an SECA rule on OrderHeader status change to OrderPlaced (see ProductAsset.secas.xml)</description>
        <in-parameters>
            <parameter name="orderId" required="true"/>
            <parameter name="forceReserve" type="Boolean" default="false">
                <description>Ignore validations on ProductStore.reservationAutoEnumId, presence of productStoreId or vendorPartyId in OrgInternal role</description></parameter>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="mantle.order.OrderHeader" value-field="orderHeader"/>
            <set field="productStore" from="orderHeader.'mantle.product.store.ProductStore'"/>

            <!-- return early if doesn't appear to be sales order (vendor OrgInternal) or store setting is no res -->
            <if condition="!forceReserve">
                <if condition="productStore == null"><then>
                    <set field="orderParts" from="orderHeader.parts"/>
                    <iterate list="orderParts" entry="orderPart">
                        <!-- if vendorPartyId is not an internal org this is not a sales order, so don't do inventory res (return) -->
                        <entity-find-one entity-name="mantle.party.PartyRole" value-field="orgPartyRole" cache="true">
                            <field-map field-name="partyId" from="orderPart.vendorPartyId"/>
                            <field-map field-name="roleTypeId" value="OrgInternal"/>
                        </entity-find-one>
                        <if condition="orgPartyRole == null"><return/></if>
                    </iterate>
                </then><else>
                    <!-- if store setup for no reservation return now -->
                    <if condition="productStore.reservationOrderEnumId == 'AsResOrdNoRes'"><return/></if>
                </else></if>
            </if>

            <entity-find entity-name="mantle.order.OrderPart" list="orderPartList">
                <econdition field-name="orderId"/><order-by field-name="orderPartSeqId"/></entity-find>

            <iterate list="orderPartList" entry="orderPart">
                <!-- check OrderPart.reservationAutoEnumId vs current status -->
                <set field="reservationAutoEnumId" from="orderPart.reservationAutoEnumId ?: productStore?.reservationAutoEnumId ?: 'AsResAutoPlaced'"/>
                <if condition="!forceReserve &amp;&amp; reservationAutoEnumId == 'AsResAutoNone'"><continue/></if>
                <if condition="!forceReserve &amp;&amp; reservationAutoEnumId == 'AsResAutoApproved'"><then>
                    <set field="resStatusList" from="['OrderApproved', 'OrderSent']"/>
                </then><else>
                    <set field="resStatusList" from="['OrderPlaced', 'OrderProcessing', 'OrderApproved', 'OrderSent', 'OrderHold']"/>
                </else></if>
                <if condition="!(orderHeader.statusId in resStatusList) || !(orderPart.statusId in resStatusList)"><continue/></if>

                <entity-find entity-name="mantle.order.OrderItem" list="orderItemList">
                    <econdition field-name="orderId"/>
                    <econdition field-name="orderPartSeqId" from="orderPart.orderPartSeqId"/>
                    <econdition field-name="productId" operator="is-not-null"/>
                    <!-- order by productId to avoid deadlocks -->
                    <order-by field-name="productId"/>
                </entity-find>
                <iterate list="orderItemList" entry="orderItem">
                    <service-call name="mantle.product.AssetServices.reserve#AssetForOrderItem"
                            in-map="[orderId:orderId, orderItemSeqId:orderItem.orderItemSeqId, productStore:productStore, forceReserve:forceReserve]"/>
                </iterate>
            </iterate>

        </actions>
    </service>
    <service verb="checkReserve" noun="AssetForOrderItem">
        <in-parameters>
            <parameter name="orderId" required="true"/>
            <parameter name="orderItemSeqId" required="true"/>
            <parameter name="resetReservations" type="Boolean" default="true"/>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="mantle.order.OrderItem" value-field="orderItem"/>
            <if condition="orderItem == null"><return error="true" message="Order Item ${orderId}:${orderItemSeqId} not found"/></if>
            <entity-find-one entity-name="mantle.order.OrderHeader" value-field="orderHeader"/>
            <if condition="orderHeader == null"><return error="true" message="Order ${orderId} not found"/></if>

            <entity-find-related-one value-field="orderItem" relationship-name="mantle.order.OrderPart" to-value-field="orderPart"/>

            <!-- regardless of settings only skip reservation update if there are no reservations (if reservations update for quantity changes, etc) -->
            <entity-find entity-name="mantle.product.issuance.AssetReservation" list="existingResList">
                <econdition field-name="orderId"/><econdition field-name="orderItemSeqId"/></entity-find>
            <if condition="!existingResList">
                <!-- only do this automatically if order placed or later but not completed/cancelled/etc -->
                <!-- check OrderPart.reservationAutoEnumId vs current status -->
                <set field="reservationAutoEnumId" from="orderPart.reservationAutoEnumId ?: productStore?.reservationAutoEnumId ?: 'AsResAutoPlaced'"/>
                <if condition="reservationAutoEnumId == 'AsResAutoNone'"><return/></if>
                <if condition="reservationAutoEnumId == 'AsResAutoApproved'"><then>
                    <set field="resStatusList" from="['OrderApproved', 'OrderSent']"/>
                </then><else>
                    <set field="resStatusList" from="['OrderPlaced', 'OrderProcessing', 'OrderApproved', 'OrderSent', 'OrderHold']"/>
                </else></if>
                <if condition="!(orderHeader.statusId in resStatusList) || !(orderPart.statusId in resStatusList)"><return/></if>
            </if>

            <!-- reserve assets, or update reservations as needed -->
            <service-call name="mantle.product.AssetServices.reserve#AssetForOrderItem" in-map="context"/>
        </actions>
    </service>
    <service verb="reserve" noun="AssetForOrderItem" no-tx-cache="true">
        <in-parameters>
            <parameter name="orderId" required="true"/>
            <parameter name="orderItemSeqId" required="true"/>
            <parameter name="productStore" type="EntityValue"><description>Optional, gets from OrderHeader if not passed.
                If there is no OrderHeader.productStoreId defaults to reservationOrderEnumId=AsResOrdFifoRec and gets
                inventoryFacilityId from OrderPart.facilityId and organizationPartyId from OrderPart.vendorPartyId.</description></parameter>
            <parameter name="assetId"><description>Optional assetId, reserves against this first if specified.</description></parameter>
            <parameter name="assetIdList" type="List">
                <description>Optional List of assetId values, reserves against these first (in order) if specified.</description>
                <parameter name="assetId"/>
            </parameter>
            <parameter name="resetReservations" type="Boolean" default="false"><description>If true remove existing reservations before reserving.</description></parameter>
            <parameter name="skipAssetIds" type="Collection">
                <description>Don't reserve to this Asset, for displace/etc</description>
                <parameter name="assetId"/>
            </parameter>
            <parameter name="forceReserve" type="Boolean" default="false">
                <description>Ignore validations on ProductStore.reservationAutoEnumId, presence of productStoreId or vendorPartyId in OrgInternal role</description></parameter>

            <parameter name="componentProductId"/>
            <parameter name="componentQuantity" type="BigDecimal"/>
        </in-parameters>
        <actions>
            <set field="nowTimestamp" from="ec.user.nowTimestamp"/>

            <!-- do a FOR UPDATE query on OrderItem as a semaphore (will also need on Asset records, done below) -->
            <entity-find-one entity-name="mantle.order.OrderItem" value-field="orderItem" for-update="true"/>
            <if condition="orderItem == null"><return error="true" message="Order Item ${orderId}:${orderItemSeqId} not found"/></if>

            <if condition="componentProductId"><log level="warn" message="Component Product ${componentProductId} reserve ${componentQuantity} for OrderItem ${orderId}:${orderItemSeqId} product ${orderItem.productId}"/></if>

            <!-- first check the OrderItem, make sure we have a productId otherwise don't reserve -->
            <set field="productId" from="componentProductId ?: orderItem.productId"/>
            <if condition="!productId"><return/></if>

            <!-- see if Product is a physical item -->
            <entity-find-one entity-name="mantle.product.Product" value-field="product" cache="true"/>
            <if condition="!(product.productTypeEnumId in ['PtAsset', 'PtDigitalAsset', 'PtAssetUse', 'PtPickAssembly'])"><return/></if>

            <!-- see if itemTypeEnumId is a product type -->
            <entity-find entity-name="moqui.basic.EnumGroupMember" list="productItemTypeEgms" cache="true">
                <econdition field-name="enumGroupEnumId" value="EngItemsProduct"/></entity-find>
            <set field="productItemTypes" from="productItemTypeEgms*.enumId"/>
            <if condition="!(orderItem.itemTypeEnumId in productItemTypes)"><return/></if>

            <entity-find-one entity-name="mantle.order.OrderHeader" value-field="orderHeader"/>
            <entity-find-related-one value-field="orderItem" relationship-name="mantle.order.OrderPart" to-value-field="orderPart"/>

            <!-- check OrderHeader and OrderPart status, return immediately if not Input, Placed, Processing, Approved, Sent, or Hold -->
            <set field="resStatusList" from="['OrderOpen', 'OrderRequested', 'OrderProposed', 'OrderPlaced', 'OrderProcessing', 'OrderApproved', 'OrderSent', 'OrderHold']"/>
            <if condition="!(orderHeader.statusId in resStatusList) || !(orderPart.statusId in resStatusList)">
                <return message="Not reserving, order or part not in status that allows reservation"/></if>

            <!-- before finding remaining quantity and getting existing reservations, resetReservations if specified -->
            <if condition="resetReservations">
                <service-call name="mantle.product.AssetServices.remove#OrderItemReservations" in-map="context"/></if>

            <!-- start with full item quantity -->
            <set field="quantityRemaining" from="componentQuantity != null ? componentQuantity : orderItem.quantity"/>

            <!-- if componentProductId skip the AssetIssuance check, should be handled in calling instance for Pick Assembly type Product -->
            <if condition="!componentProductId">
                <!-- reduce quantity for already packed/issued -->
                <entity-find entity-name="mantle.product.issuance.AssetIssuance" list="assetIssuanceList">
                    <econdition field-name="orderId"/><econdition field-name="orderItemSeqId"/>
                </entity-find>
                <iterate list="assetIssuanceList" entry="assetIssuance">
                    <set field="quantityRemaining" from="quantityRemaining - assetIssuance.quantity"/>
                </iterate>
            </if>

            <!-- if there are any existing reservations, deduct their quantity -->
            <!-- NOTE this was for-update=true but should not be needed, we already locked the OrderItem -->
            <entity-find entity-name="mantle.product.issuance.AssetReservation" list="existingResList">
                <econdition field-name="orderId"/><econdition field-name="orderItemSeqId"/>
                <!-- if PickAssembly Product or PA component must filter by productId -->
                <econdition field-name="productId" from="product.productId" ignore="!(componentProductId || product.productTypeEnumId == 'PtPickAssembly')"/>
                <!-- get most recent first for reducing reservation quantities -->
                <order-by field-name="-reservedDate"/>
            </entity-find>
            <iterate list="existingResList" entry="existingRes">
                <set field="quantityRemaining" from="quantityRemaining - existingRes.quantity"/>
            </iterate>

            <!-- if nothing to reserve or un-reserve return now -->
            <if condition="quantityRemaining &lt;= 0"><return/></if>

            <!-- handle too much reserved -->
            <if condition="quantityRemaining &lt; 0">
                <set field="quantityToDeduct" from="-quantityRemaining"/>
                <iterate list="existingResList" entry="existingRes">
                    <service-call name="mantle.product.AssetServices.reduce#AssetReservation" out-map="reduceArOut" out-map-add-to-existing="false"
                            in-map="[assetReservationId:existingRes.assetReservationId, quantityToDeduct:quantityToDeduct, reserveIncreasedAsset:true]"/>
                    <set field="quantityToDeduct" from="quantityToDeduct - reduceArOut.quantityDeducted"/>
                    <if condition="quantityToDeduct == 0"><break/></if>
                </iterate>

                <if condition="quantityToDeduct != 0">
                    <return error="true" message="Unable to remove reservations for ${quantityToDeduct} out of ${-quantityRemaining} attempted, not enough quantity reserved and not issued"/>
                    <else><return/></else>
                </if>
            </if>
            <if condition="quantityRemaining &lt; 0">
                <log level="error" message="Quantity to reserve ${quantityRemaining} is less than zero; order item ${orderId}:${orderItemSeqId}, quantity ${orderItem.quantity}; existingResList: ${existingResList}"/>
                <return error="true" message="Quantity to reserve ${quantityRemaining} is less than zero"/>
            </if>

            <!-- no store passed? find it from OrderHeader -->
            <if condition="productStore == null">
                <entity-find-related-one value-field="orderHeader" relationship-name="mantle.product.store.ProductStore"
                        to-value-field="productStore" cache="true"/>
            </if>
            <!-- if store setup for no reservation return now -->
            <if condition="productStore?.reservationOrderEnumId == 'AsResOrdNoRes'"><return/></if>
            <!-- otherwise set assetOrderBy field based on reservationOrderEnumId -->
            <set field="reservationOrderEnumId" from="productStore?.reservationOrderEnumId ?: 'AsResOrdFifoRec'"/>
            <entity-find-one entity-name="moqui.basic.Enumeration" value-field="resOrderEnum">
                <field-map field-name="enumId" from="reservationOrderEnumId"/></entity-find-one>
            <set field="assetOrderBy" from="resOrderEnum?.enumCode ?: 'receivedDate'"/><!-- default: FIFO by received date -->

            <set field="inventoryFacilityId" from="orderPart?.facilityId ?: productStore?.inventoryFacilityId"/>
            <entity-find-one entity-name="mantle.facility.Facility" value-field="inventoryFacility" cache="true">
                <field-map field-name="facilityId" from="inventoryFacilityId"/></entity-find-one>
            <set field="assetAllowOtherOwner" from="inventoryFacility?.assetAllowOtherOwner"/>

            <!-- determine organizationPartyId -->
            <set field="organizationPartyId" from="orderPart?.vendorPartyId ?: productStore?.organizationPartyId"/>
            <!-- if organizationPartyId is not an internal org this is not a sales order, so don't do inventory res (return) -->
            <entity-find-one entity-name="mantle.party.PartyRole" value-field="orgPartyRole" cache="true">
                <field-map field-name="partyId" from="organizationPartyId"/>
                <field-map field-name="roleTypeId" value="OrgInternal"/>
            </entity-find-one>
            <if condition="productStore == null &amp;&amp; orgPartyRole == null">
                <if condition="forceReserve"><then>
                    <log message="Reserving inventory for order ${orderId} item ${orderItemSeqId} with no productStoreId and vendor is not OrgInternal (forceReserve is true)"/>
                </then><else>
                    <return/>
                </else></if>
            </if>

            <!-- get ownerPartyId values to include -->
            <set field="ownerPartyIdSet" from="new HashSet()"/>
            <script>if (organizationPartyId) ownerPartyIdSet.add(organizationPartyId)</script>
            <if condition="organizationPartyId &amp;&amp; assetAllowOtherOwner != 'Y'">
                <!-- look for parent org(s) if any, include assets from parent org too -->
                <entity-find entity-name="mantle.party.PartyRelationship" list="parentRelList" cache="true">
                    <date-filter/>
                    <econdition field-name="relationshipTypeEnumId" value="PrtOrgRollup"/>
                    <econdition field-name="fromPartyId" from="organizationPartyId"/>
                    <econdition field-name="toPartyId" operator="is-not-null"/>
                </entity-find>
                <script>if (parentRelList) ownerPartyIdSet.addAll(parentRelList*.toPartyId)</script>
            </if>

            <!-- get assetPoolId values this order qualifies for (by store, vendor, customer) -->
            <service-call name="mantle.product.AssetServices.get#AssetPools" out-map="poolsOut"
                    in-map="[productStoreId:orderHeader.productStoreId, vendorPartyId:orderPart?.vendorPartyId,
                        customerPartyId:orderPart?.customerPartyId]"/>
            <set field="assetPoolIdSet" from="poolsOut.assetPoolIdSet"/>

            <!-- check and lock individual Asset records -->
            <set field="lockedAssetList" from="[]"/>
            <set field="checkQuantityRemaining" from="quantityRemaining"/>

            <!-- check/lock explicit assetIds -->
            <set field="explicitAssetIdList" from="[]"/>
            <if condition="assetId"><script>explicitAssetIdList.add(assetId)</script></if>
            <if condition="assetIdList"><script>explicitAssetIdList.addAll(assetIdList)</script></if>
            <if condition="explicitAssetIdList">
                <entity-find entity-name="mantle.product.asset.Asset" list="explicitAssetList">
                    <econdition field-name="assetId" operator="in" from="explicitAssetIdList"/>
                    <econdition field-name="productId"/>
                    <econdition field-name="quantityOnHandTotal" operator="greater" from="0.0"/>
                </entity-find>
                <set field="sortedExplicitAssetList" from="[]"/>
                <iterate list="explicitAssetIdList" entry="explicitAssetId">
                    <set field="explicitAsset" from="explicitAssetList.find({ it.assetId == explicitAssetId })"/>
                    <script>if (explicitAsset != null) sortedExplicitAssetList.add(explicitAsset)</script>
                </iterate>
                <!-- <log level="warn" message="explicitAssetIdList ${explicitAssetIdList}"/><log level="warn" message="sortedExplicitAssetList ${sortedExplicitAssetList}"/> -->
                <iterate list="sortedExplicitAssetList" entry="checkAsset">
                    <if condition="checkQuantityRemaining &lt;= 0.0"><break/></if>

                    <!-- if checkAsset.assetPoolId make sure order qualifies for pool -->
                    <if condition="checkAsset.assetPoolId &amp;&amp; !assetPoolIdSet.contains(checkAsset.assetPoolId)">
                        <message type="danger">Not reserving specified asset ${checkAsset.assetId} in pool ${checkAsset.assetPoolId} which is not available to this order</message>
                        <continue/>
                    </if>

                    <!-- here we do the lock query, check the ATP using the locked value -->
                    <entity-find-one entity-name="mantle.product.asset.Asset" value-field="asset" for-update="true">
                        <field-map field-name="assetId" from="checkAsset.assetId"/></entity-find-one>
                    <set field="quantityToReserve" from="asset.quantityOnHandTotal &gt; checkQuantityRemaining ? checkQuantityRemaining : asset.quantityOnHandTotal"/>
                    <if condition="quantityToReserve &gt; asset.availableToPromiseTotal">
                        <!-- displace existing reservations for explicit assetIds -->
                        <service-call name="mantle.product.AssetServices.displace#AssetReservations"
                                in-map="[assetId:asset.assetId, orderId:orderId, orderItemSeqId:orderItemSeqId, quantity:quantityToReserve]"/>
                        <entity-find-one entity-name="mantle.product.asset.Asset" value-field="asset" for-update="true">
                            <field-map field-name="assetId" from="asset.assetId"/></entity-find-one>
                    </if>

                    <if condition="quantityToReserve &gt; 0.0">
                        <set field="checkQuantityRemaining" from="checkQuantityRemaining - quantityToReserve"/>
                        <script>lockedAssetList.add(asset)</script>
                    </if>
                </iterate>
            </if>
            <if condition="checkQuantityRemaining &gt; 0.0">
                <set field="baseAssetCond" from="[productId:productId, statusId:'AstAvailable']"/>
                <if condition="inventoryFacilityId"><set field="baseAssetCond.facilityId" from="inventoryFacilityId"/></if>
                <!-- TODO 20180503 remove this at some point, added to monitor corner case issue -->
                <if condition="!baseAssetCond.facilityId"><log level="warn" message="Reserving inventory for order ${orderId} item ${orderItemSeqId} with no facilityId"/></if>

                <!-- see if we need to try for single lot and newer inventory, done via lotsToUse list -->
                <set field="lotsToUse" from="null"/>
                <set field="singleLot" from="false"/>
                <set field="newerInventory" from="false"/>
                <if condition="orderPart.customerPartyId">
                    <set field="singleLot" from="'BlY'.equals(ec.service.sync().name('mantle.party.PartyServices.get#PartySettingValue')
                        .parameter('partySettingTypeId', 'CustomerSingleLot').parameter('partyId', orderPart.customerPartyId).call()?.get('settingValue'))"/>
                    <set field="newerInventory" from="'BlY'.equals(ec.service.sync().name('mantle.party.PartyServices.get#PartySettingValue')
                        .parameter('partySettingTypeId', 'CustomerNewerInventory').parameter('partyId', orderPart.customerPartyId).call()?.get('settingValue'))"/>
                </if>

                <if condition="singleLot || newerInventory">
                    <set field="newerThanExpireDate" from="null"/>
                    <if condition="newerInventory">
                        <!-- get most recent asset issued and lot expire date for it -->
                        <entity-find entity-name="mantle.product.issuance.AssetIssuanceLotSummary" list="issuanceLotList" limit="1">
                            <econdition field-name="toPartyId" from="orderPart.customerPartyId"/>
                            <econdition field-name="productId"/>
                            <select-field field-name="expirationDate,expectedEndOfLife"/>
                            <order-by field-name="-issuedDate"/>
                        </entity-find>
                        <if condition="issuanceLotList">
                            <set field="newerThanExpireDate" from="issuanceLotList[0].expirationDate ?: issuanceLotList[0].expectedEndOfLife"/></if>
                    </if>
                    <!-- do pre-query to find sufficient lots, or if no sufficient largest lots by order to minimize lots -->
                    <entity-find entity-name="mantle.product.asset.AssetLotSummary" list="lotSummaryList">
                        <econdition-object field="baseAssetCond"/>
                        <econdition field-name="ownerPartyId" operator="in" from="ownerPartyIdSet" ignore="assetAllowOtherOwner == 'Y' || !ownerPartyIdSet"/>
                        <econdition field-name="assetPoolId" operator="in" from="assetPoolIdSet" ignore="!assetPoolIdSet" or-null="true"/>
                        <econdition field-name="assetPoolId" operator="is-null" ignore="assetPoolIdSet"/>
                        <econdition field-name="expirationDate" operator="greater-equals" from="newerThanExpireDate" ignore-if-empty="true"/>
                        <select-field field-name="lotId,availableToPromiseTotal,manufacturedDate,expirationDate"/>
                        <!-- order to get fewest but sufficient available in a lot -->
                        <order-by field-name="availableToPromiseTotal"/>
                    </entity-find>
                    <set field="availableFoundByLot" from="0.0"/>
                    <iterate list="lotSummaryList" entry="lotSummary">
                        <set field="availableFoundByLot" from="availableFoundByLot + lotSummary.availableToPromiseTotal"/></iterate>
                    <!-- if no or insufficient records found and newerThanExpireDate, search again without -->
                    <if condition="availableFoundByLot &lt; checkQuantityRemaining &amp;&amp; newerThanExpireDate != null">
                        <!-- in this case we could get most recent inventory (-expirationDate) since we failed the newer than
                            constraint, but that would prioritize age over single lot so only do if !singleLot -->
                        <!-- when finding minimal lot or newest results are used in reverse order, so use expirationDate and not -expirationDate -->
                        <set field="lotRetryOrderBy" from="singleLot ? 'availableToPromiseTotal' : 'expirationDate'"/>
                        <entity-find entity-name="mantle.product.asset.AssetLotSummary" list="lotSummaryList">
                            <econdition-object field="baseAssetCond"/>
                            <econdition field-name="ownerPartyId" operator="in" from="ownerPartyIdSet" ignore="assetAllowOtherOwner == 'Y' || !ownerPartyIdSet"/>
                            <econdition field-name="assetPoolId" operator="in" from="assetPoolIdSet" ignore="!assetPoolIdSet" or-null="true"/>
                            <econdition field-name="assetPoolId" operator="is-null" ignore="assetPoolIdSet"/>
                            <select-field field-name="lotId,availableToPromiseTotal,manufacturedDate,expirationDate"/>
                            <order-by field-name="${lotRetryOrderBy}"/>
                        </entity-find>
                    </if>
                    <!-- if we found any lots look for singleLotId if singleLot, else use best candidate lots based on queries above -->
                    <if condition="lotSummaryList">
                        <set field="singleLotId" from="null"/>
                        <if condition="singleLot">
                            <!-- find first in list (smallest) lot with sufficient inventory and use it -->
                            <iterate list="lotSummaryList" entry="lotSummary">
                                <if condition="lotSummary.availableToPromiseTotal &gt;= checkQuantityRemaining">
                                    <set field="singleLotId" from="lotSummary.lotId"/><break/></if>
                            </iterate>
                        </if>
                        <if condition="singleLotId"><then>
                            <!-- <log level="warn" message="Found single lot ${singleLotId}"/> -->
                            <set field="lotsToUse" from="[singleLotId]"/>
                        </then><else><script><![CDATA[
                            // no single lot found? go end to beginning and use as many lots as needed
                            lotsToUse = []
                            BigDecimal lotQuantityRemaining = checkQuantityRemaining
                            for (int i = lotSummaryList.size() - 1; i >= 0; i--) {
                                def curLotSummary = lotSummaryList.get(i)
                                lotQuantityRemaining -= curLotSummary.availableToPromiseTotal
                                lotsToUse.add(curLotSummary.lotId)
                                if (lotQuantityRemaining <= 0.0) break
                            }
                        ]]></script></else></if>
                        <log level="warn" message="Order ${orderId} Lots to use: ${lotsToUse}"/>
                    </if>
                </if>

                <!-- ========== main available query ========== -->
                <!-- reserve against pick locations first, then against other types or no location -->
                <if condition="checkQuantityRemaining &gt; 0.0">
                    <entity-find entity-name="mantle.product.asset.AssetLocationDetail" list="checkAssetList">
                        <!-- don't lock here, we'll lock records we need individually to avoid contention -->
                        <econdition-object field="baseAssetCond"/>
                        <econdition field-name="ownerPartyId" operator="in" from="ownerPartyIdSet" ignore="assetAllowOtherOwner == 'Y' || !ownerPartyIdSet"/>
                        <econdition field-name="assetPoolId" operator="in" from="assetPoolIdSet" ignore="!assetPoolIdSet" or-null="true"/>
                        <econdition field-name="assetPoolId" operator="is-null" ignore="assetPoolIdSet"/>
                        <!-- only look for Assets with available quantity, to reduce lock contention we'll create new records for negative ATP -->
                        <econdition field-name="availableToPromiseTotal" operator="greater" from="0.0"/>
                        <econdition field-name="assetId" operator="not-in" from="explicitAssetIdList" ignore-if-empty="true"/>
                        <econdition field-name="assetId" operator="not-in" from="skipAssetIds" ignore-if-empty="true"/>
                        <econdition field-name="lotId" operator="in" from="lotsToUse" ignore-if-empty="true"/>
                        <econdition field-name="statusId" value="AstAvailable"/>
                        <econdition field-name="locationTypeEnumId" value="FltPick"/>
                        <select-field field-name="${assetOrderBy},assetId"/>
                        <order-by field-name="${assetOrderBy},assetId"/>
                    </entity-find>
                    <!-- <log level="warn" message="checkAssetList find ${checkAssetList_xafind}\nSQL ${checkAssetList_xafind.getQueryTextList()}"/> -->
                    <iterate list="checkAssetList" entry="checkAsset">
                        <if condition="checkQuantityRemaining &lt;= 0.0"><break/></if>
                        <!-- here we do the lock query, check the ATP using the locked value -->
                        <entity-find-one entity-name="mantle.product.asset.Asset" value-field="asset" for-update="true">
                            <field-map field-name="assetId" from="checkAsset.assetId"/></entity-find-one>

                        <!-- TODO 20180503 remove this at some point, added to monitor corner case issue -->
                        <if condition="inventoryFacilityId != asset.facilityId">
                            <log level="warn" message="Inventory Facility ${inventoryFacilityId} did not match asset ${asset?.assetId} facility ${asset?.facilityId} reserving for order ${orderId} item ${orderItemSeqId}"/></if>

                        <set field="quantityToReserve" from="asset.availableToPromiseTotal &gt; checkQuantityRemaining ? checkQuantityRemaining : asset.availableToPromiseTotal"/>
                        <if condition="quantityToReserve &gt; 0.0">
                            <set field="checkQuantityRemaining" from="checkQuantityRemaining - quantityToReserve"/>
                            <script>lockedAssetList.add(asset)</script>
                        </if>
                        <!-- <log level="warn" message="Locked Asset ${asset.assetId} with ATP ${asset.availableToPromiseTotal} for Reservation quantityToReserve=${quantityToReserve}, checkQuantityRemaining=${checkQuantityRemaining}"/> -->
                    </iterate>
                </if>
                <!-- now use other location types or no location -->
                <if condition="checkQuantityRemaining &gt; 0.0">
                    <entity-find entity-name="mantle.product.asset.AssetLocationDetail" list="checkAssetList">
                        <!-- don't lock here, we'll lock records we need individually to avoid contention -->
                        <econdition-object field="baseAssetCond"/>
                        <econdition field-name="ownerPartyId" operator="in" from="ownerPartyIdSet" ignore="assetAllowOtherOwner == 'Y' || !ownerPartyIdSet"/>
                        <econdition field-name="assetPoolId" operator="in" from="assetPoolIdSet" ignore="!assetPoolIdSet" or-null="true"/>
                        <econdition field-name="assetPoolId" operator="is-null" ignore="assetPoolIdSet"/>
                        <!-- only look for Assets with available quantity, to reduce lock contention we'll create new records for negative ATP -->
                        <econdition field-name="availableToPromiseTotal" operator="greater" from="0.0"/>
                        <econdition field-name="assetId" operator="not-in" from="explicitAssetIdList" ignore-if-empty="true"/>
                        <econdition field-name="assetId" operator="not-in" from="skipAssetIds" ignore-if-empty="true"/>
                        <econdition field-name="lotId" operator="in" from="lotsToUse" ignore-if-empty="true"/>
                        <econdition field-name="statusId" value="AstAvailable"/>
                        <econdition field-name="locationTypeEnumId" operator="not-equals" value="FltPick" or-null="true"/>
                        <select-field field-name="${assetOrderBy},assetId"/>
                        <order-by field-name="${assetOrderBy},assetId"/>
                    </entity-find>
                    <!-- <log level="warn" message="checkAssetList find ${checkAssetList_xafind}\nSQL ${checkAssetList_xafind.getQueryTextList()}"/> -->
                    <iterate list="checkAssetList" entry="checkAsset">
                        <if condition="checkQuantityRemaining &lt;= 0.0"><break/></if>
                        <!-- here we do the lock query, check the ATP using the locked value -->
                        <entity-find-one entity-name="mantle.product.asset.Asset" value-field="asset" for-update="true">
                            <field-map field-name="assetId" from="checkAsset.assetId"/></entity-find-one>

                        <!-- TODO 20180503 remove this at some point, added to monitor corner case issue -->
                        <if condition="inventoryFacilityId != asset.facilityId">
                            <log level="warn" message="Inventory Facility ${inventoryFacilityId} did not match asset ${asset?.assetId} facility ${asset?.facilityId} reserving for order ${orderId} item ${orderItemSeqId}"/></if>

                        <set field="quantityToReserve" from="asset.availableToPromiseTotal &gt; checkQuantityRemaining ? checkQuantityRemaining : asset.availableToPromiseTotal"/>
                        <if condition="quantityToReserve &gt; 0.0">
                            <set field="checkQuantityRemaining" from="checkQuantityRemaining - quantityToReserve"/>
                            <script>lockedAssetList.add(asset)</script>
                        </if>
                        <!-- <log level="warn" message="Locked Asset ${asset.assetId} with ATP ${asset.availableToPromiseTotal} for Reservation quantityToReserve=${quantityToReserve}, checkQuantityRemaining=${checkQuantityRemaining}"/> -->
                    </iterate>
                </if>
            </if>

            <!-- <log level="warn" message="Reserve order ${orderId}:${orderItemSeqId} asset ${assetId} lockedAssetList: ${lockedAssetList*.assetId} ${lockedAssetList*.availableToPromiseTotal}"/> -->

            <!-- do the reservations... -->
            <set field="baseMap" from="[orderId:orderId, orderItemSeqId:orderItemSeqId, productId:productId]"/>
            <iterate list="lockedAssetList" entry="asset">
                <if condition="quantityRemaining &gt; 0.0">
                    <set field="quantityToReserve" from="asset.availableToPromiseTotal &gt; quantityRemaining ? quantityRemaining : asset.availableToPromiseTotal"/>
                    <if condition="quantityToReserve == 0.0"><continue/></if>
                    <set field="quantityRemaining" from="quantityRemaining - quantityToReserve"/>
                    <if condition="quantityToReserve &lt; 0.0">
                        <return error="true" message="In reserve#AssetForOrderItem (with assets found) got negative quantityToReserve ${quantityToReserve}"/></if>
                    <service-call name="create#mantle.product.issuance.AssetReservation" out-map="resOut" in-map="baseMap +
                            [assetId:asset.assetId, reservedDate:nowTimestamp, quantity:quantityToReserve,
                                quantityNotAvailable:0.0, quantityNotIssued:quantityToReserve, priority:orderItem.priority,
                                sequenceNum:asset_index, reservationOrderEnumId:reservationOrderEnumId]"/>
                    <service-call name="create#mantle.product.asset.AssetDetail" in-map="baseMap +
                            [assetId:asset.assetId, effectiveDate:nowTimestamp,
                                availableToPromiseDiff:-quantityToReserve, assetReservationId:resOut.assetReservationId]"/>
                    <!-- <log level="warn" message="Reserved Asset ${asset.assetId} with ATP ${asset.availableToPromiseTotal}, quantityToReserve=${quantityToReserve}, quantityRemaining=${quantityRemaining}"/> -->
                </if>
            </iterate>

            <!-- if Product is a Pick Assembly (productTypeEnumId=PtPickAssembly):
                - reservations may be against PA Product and/or against BOM component Products
                - if any already assembled in stock will have used above
                - instead of not available reservation try to reserve each BOM component
                - if a BOM component does not have sufficient inventory do not available reservation per component
            -->
            <if condition="quantityRemaining &gt; 0.0 &amp;&amp; product.productTypeEnumId == 'PtPickAssembly'">
                <entity-find entity-name="mantle.product.ProductAssoc" list="assocList">
                    <date-filter/>
                    <econdition field-name="productId" from="product.productId"/>
                    <econdition field-name="productAssocTypeEnumId" value="PatMfgBom"/>
                </entity-find>
                <iterate list="assocList" entry="assoc">
                    <if condition="assoc.productId == assoc.toProductId">
                        <return error="true" message="Pick Assembly Product ${assoc.productId} has itself for a component product, remove the Manufacturing BOM Association"/></if>

                    <service-call name="mantle.product.AssetServices.reserve#AssetForOrderItem"
                            in-map="[orderId:orderId, orderItemSeqId:orderItemSeqId, productStore:productStore, forceReserve:forceReserve,
                                componentProductId:assoc.toProductId, componentQuantity:((assoc.quantity ?: 1.0) * quantityRemaining)]"/>
                </iterate>

                <set field="quantityRemaining" from="0.0"/>
            </if>

            <if condition="quantityRemaining &gt; 0.0">
                <!-- look for qualifying Asset even if no available quantity and do 'not available' reservation on that instead of creating new ad-hoc -->
                <entity-find entity-name="mantle.product.asset.Asset" list="existingResAssetList" limit="1">
                    <econdition field-name="productId"/>
                    <econdition field-name="facilityId" from="inventoryFacilityId"/>
                    <econdition field-name="ownerPartyId" from="organizationPartyId"/>
                    <econdition field-name="assetPoolId" from="null"/>
                    <econdition field-name="locationSeqId" from="null"/>
                    <econdition field-name="containerId" from="null"/>
                    <econdition field-name="lotId" from="null"/>
                    <!-- may be populated even for negative availability placeholder records: <econdition field-name="acquireCost" from="null"/> -->
                    <econdition field-name="statusId" value="AstAvailable"/>
                    <econdition field-name="hasQuantity" value="Y"/>
                    <econdition field-name="availableToPromiseTotal" operator="less-equals" from="0.0"/>
                    <select-field field-name="assetId"/>
                    <!-- NOTE: order by ATP ascending, expect to be negative so highest negative value first -->
                    <order-by field-name="availableToPromiseTotal"/>
                </entity-find>
                <set field="newResAssetId" from="existingResAssetList ? existingResAssetList.get(0).assetId : null"/>
                <if condition="!newResAssetId">
                    <!-- no asset... create a shell one to record the reservation and detail against -->
                    <service-call name="mantle.product.AssetServices.create#ProductAssetAdHoc" out-map="assetOut"
                            in-map="[productId:productId, facilityId:inventoryFacilityId, ownerPartyId:organizationPartyId,
                                createdDate:nowTimestamp]"/>
                    <set field="newResAssetId" from="assetOut.assetId"/>
                </if>

                <service-call name="create#mantle.product.issuance.AssetReservation" out-map="resOut" in-map="baseMap +
                        [assetId:newResAssetId, reservedDate:nowTimestamp, quantity:quantityRemaining,
                            quantityNotAvailable:quantityRemaining, quantityNotIssued:quantityRemaining,
                            priority:orderItem.priority, sequenceNum:0,
                            reservationOrderEnumId:reservationOrderEnumId]"/>
                <service-call name="create#mantle.product.asset.AssetDetail" in-map="baseMap +
                        [assetId:newResAssetId, effectiveDate:nowTimestamp,
                            availableToPromiseDiff:-quantityRemaining, assetReservationId:resOut.assetReservationId]"/>
            </if>
        </actions>
    </service>

    <service verb="remove" noun="OrderItemReservations">
        <in-parameters>
            <parameter name="orderId" required="true"/>
            <parameter name="orderItemSeqId" required="true"/>
        </in-parameters>
        <actions>
            <!-- do a FOR UPDATE query on OrderItem as a semaphore -->
            <entity-find-one entity-name="mantle.order.OrderItem" value-field="orderItem" for-update="true"/>

            <entity-find entity-name="mantle.product.issuance.AssetReservation" list="existingResList" for-update="true">
                <econdition field-name="orderId"/><econdition field-name="orderItemSeqId"/></entity-find>
            <iterate list="existingResList" entry="existingRes">
                <service-call name="mantle.product.AssetServices.reduce#AssetReservation"
                        in-map="[assetReservationId:existingRes.assetReservationId, reserveIncreasedAsset:true]"/>
            </iterate>
        </actions>
    </service>
    <service verb="remove" noun="OrderReservations">
        <in-parameters>
            <parameter name="orderId" required="true"/>
        </in-parameters>
        <actions>
            <!-- do a FOR UPDATE query on OrderItem as a semaphore -->
            <entity-find entity-name="mantle.order.OrderItem" list="orderItemList" for-update="true">
                <econdition field-name="orderId"/></entity-find>

            <entity-find entity-name="mantle.product.issuance.AssetReservation" list="existingResList" for-update="true">
                <econdition field-name="orderId"/></entity-find>
            <iterate list="existingResList" entry="existingRes">
                <service-call name="mantle.product.AssetServices.reduce#AssetReservation"
                        in-map="[assetReservationId:existingRes.assetReservationId, reserveIncreasedAsset:true]"/>
            </iterate>
        </actions>
    </service>

    <service verb="reduce" noun="AssetReservation" no-tx-cache="true">
        <description>Reduce quantity on AssetReservation, if reduced to zero delete.</description>
        <in-parameters>
            <parameter name="assetReservationId" required="true"/>
            <parameter name="quantityToDeduct" type="BigDecimal">
                <description>Defaults to entire quantityNotIssued, limited to quantityNotIssued</description></parameter>
            <parameter name="reserveIncreasedAsset" type="Boolean" default="false"/>
        </in-parameters>
        <out-parameters><parameter name="quantityDeducted" type="BigDecimal"/></out-parameters>
        <actions>
            <entity-find-one entity-name="mantle.product.issuance.AssetReservation" value-field="existingRes"/>

            <!-- <log level="warn" message="reduce by ${quantityToDeduct} AssetRes ${existingRes}\n${ec.artifactExecution.getStack().collect({it.toBasicString()}).join('\n')}"/> -->

            <if condition="!quantityToDeduct"><set field="quantityToDeduct" from="existingRes.quantityNotIssued"/></if>
            <if condition="quantityToDeduct &gt;= existingRes.quantity &amp;&amp; existingRes.quantity == existingRes.quantityNotIssued"><then>
                <service-call name="create#mantle.product.asset.AssetDetail" in-map="[assetId:existingRes.assetId,
                                effectiveDate:ec.user.nowTimestamp, availableToPromiseDiff:existingRes.quantity,
                                assetReservationId:existingRes.assetReservationId, productId:existingRes.productId, orderId:existingRes.orderId]"/>

                <set field="quantityDeducted" from="existingRes.quantity"/>
                <entity-delete value-field="existingRes"/>
            </then><else>
                <set field="curQuantityToDeduct" from="existingRes.quantityNotIssued &gt; quantityToDeduct ?
                                quantityToDeduct : existingRes.quantityNotIssued"/>
                <!-- add to ATP on Asset through a detail record, if curQuantityToDeduct not null and not zero -->
                <if condition="curQuantityToDeduct">
                    <service-call name="create#mantle.product.asset.AssetDetail" in-map="[assetId:existingRes.assetId,
                            effectiveDate:ec.user.nowTimestamp, availableToPromiseDiff:curQuantityToDeduct,
                            assetReservationId:existingRes.assetReservationId, productId:existingRes.productId,
                            orderId:existingRes.orderId, orderItemSeqId:existingRes.orderItemSeqId]"/>
                </if>
                <!-- reduce quantities on AssetReservation -->
                <set field="existingRes.quantity" from="existingRes.quantity - curQuantityToDeduct"/>
                <set field="existingRes.quantityNotAvailable"
                        from="existingRes.quantityNotAvailable &gt; curQuantityToDeduct ?
                                    existingRes.quantityNotAvailable - curQuantityToDeduct : 0.0"/>
                <set field="existingRes.quantityNotIssued" from="existingRes.quantityNotIssued - curQuantityToDeduct"/>
                <if condition="existingRes.quantity &lt; 0.0">
                    <return error="true" message="In reduce#AssetReservation got negative quantity ${existingRes.quantity}, quantity deducted ${curQuantityToDeduct}"/></if>
                <if condition="existingRes.quantity == 0.0 || existingRes.quantityNotIssued == 0.0"><then>
                    <entity-delete value-field="existingRes"/>
                </then><else>
                    <entity-update value-field="existingRes"/>
                </else></if>

                <set field="quantityDeducted" from="curQuantityToDeduct"/>
            </else></if>

            <if condition="reserveIncreasedAsset">
                <!-- with ATP increased reserve newly available inventory -->
                <service-call name="mantle.product.AssetServices.reserve#IncreasedAsset" in-map="[assetId:existingRes.assetId]"/>
            </if>
        </actions>
    </service>

    <service verb="reReserve" noun="Assets" transaction-timeout="3600">
        <in-parameters>
            <parameter name="facilityId"/>
            <parameter name="productId"/>
            <parameter name="orderId"/>
            <parameter name="reserveOrderStatusIds" default-value="OrderPlaced,OrderHold,OrderProcessing,OrderApproved,OrderSent"/>
            <!-- TODO: for now re-reserve order by OrderPart.priority, OrderHeader.placedDate, make that configurable or use store/etc settings somehow? -->
            <!-- TODO: consider OrderItem.priority for reservation order? concept not yet used elsewhere... -->
        </in-parameters>
        <actions>
            <set field="reserveOrderStatusIdSet" from="new HashSet(((String) reserveOrderStatusIds).split(',') as List)"/>

            <entity-find entity-name="mantle.product.issuance.AssetAndReservation" list="resOrderItemList" distinct="true">
                <econdition field-name="facilityId" ignore-if-empty="true"/>
                <econdition field-name="productId" ignore-if-empty="true"/>
                <econdition field-name="orderId" ignore-if-empty="true"/>
                <select-field field-name="orderId,orderItemSeqId"/>
            </entity-find>
            <log message="reReserve#Assets facilityId ${facilityId} productId ${productId} orderId ${orderId} OrderItems with reservations ${resOrderItemList.size()}"/>

            <set field="orderItemInfoList" from="[]"/>
            <iterate list="resOrderItemList" entry="resOrderItem">
                <entity-find-one entity-name="mantle.order.OrderItem" value-field="orderItem">
                    <field-map field-name="orderId" from="resOrderItem.orderId"/>
                    <field-map field-name="orderItemSeqId" from="resOrderItem.orderItemSeqId"/>
                </entity-find-one>
                <if condition="orderItem == null">
                    <log level="warn" message="In reReserve#Assets could not find OrderItem ${orderId}:${orderItemSeqId}"/>
                    <continue/>
                </if>

                <!-- remove item reservations -->
                <service-call name="mantle.product.AssetServices.remove#OrderItemReservations"
                        in-map="[orderId:resOrderItem.orderId, orderItemSeqId:resOrderItem.orderItemSeqId]"/>

                <!-- look up OrderPart, OrderHeader to see if item qualifies for re-reserve, and get order by fields -->
                <set field="orderPart" from="orderItem.part"/>
                <if condition="orderPart.statusId in reserveOrderStatusIdSet">
                    <set field="orderHeader" from="orderItem.header"/>
                    <script>orderItemInfoList.add([orderId:orderItem.orderId, orderItemSeqId:orderItem.orderItemSeqId,
                            priority:orderPart.priority, placedDate:orderHeader.placedDate])</script>
                </if>
            </iterate>

            <order-map-list list="orderItemInfoList"><order-by field-name="priority"/><order-by field-name="placedDate"/>
                <order-by field-name="orderId"/><order-by field-name="orderItemSeqId"/></order-map-list>

            <iterate list="orderItemInfoList" entry="orderItemInfo">
                <!-- NOTE: a reservation existed so forceReserve:true -->
                <service-call name="mantle.product.AssetServices.reserve#AssetForOrderItem"
                        in-map="[orderId:orderItemInfo.orderId, orderItemSeqId:orderItemInfo.orderItemSeqId, forceReserve:true]"/>
            </iterate>
        </actions>
    </service>

    <service verb="reserve" noun="IncreasedAsset" no-tx-cache="true">
        <description>For Asset with availableToPromiseTotal > 0 find AssetReservation with quantityNotAvailable and reserve against it</description>
        <in-parameters><parameter name="assetId" required="true"/></in-parameters>
        <out-parameters><parameter name="quantityMoved" type="BigDecimal"/></out-parameters>
        <actions>
            <set field="quantityMoved" from="0.0"/>

            <entity-find-one entity-name="mantle.product.asset.Asset" value-field="asset" for-update="true"/>
            <if condition="asset.statusId != 'AstAvailable'"><return/></if>
            <if condition="asset.availableToPromiseTotal &lt;= 0.0"><return/></if>
            <if condition="!asset.productId"><return/></if>

            <entity-find-one entity-name="mantle.facility.Facility" value-field="inventoryFacility">
                <field-map field-name="facilityId" from="asset.facilityId"/></entity-find-one>
            <set field="assetAllowOtherOwner" from="inventoryFacility?.assetAllowOtherOwner"/>

            <set field="ownerPartyIdSet" from="new HashSet()"/>
            <script>if (asset.ownerPartyId) ownerPartyIdSet.add(asset.ownerPartyId)</script>
            <if condition="asset.ownerPartyId &amp;&amp; assetAllowOtherOwner != 'Y'">
                <!-- look for child org(s) if any, include assets from child org(s) too to pick up reservations against temporary Asset records owned by child orgs -->
                <entity-find entity-name="mantle.party.PartyRelationship" list="childRelList" cache="true">
                    <date-filter/>
                    <econdition field-name="relationshipTypeEnumId" value="PrtOrgRollup"/>
                    <econdition field-name="toPartyId" from="asset.ownerPartyId"/>
                    <econdition field-name="fromPartyId" operator="is-not-null"/>
                </entity-find>
                <script>if (childRelList) ownerPartyIdSet.addAll(childRelList*.fromPartyId)</script>
            </if>

            <!-- NOTE: if Asset.assetPoolId only move reservations for orders that qualify for the pool,
                tough to do in advance so handle via move#AssetReservation and move no quantity if doesn't qualify -->
            <set field="availableRemaining" from="asset.availableToPromiseTotal"/>
            <entity-find entity-name="mantle.product.issuance.AssetAndReservation" list="resList">
                <econdition field-name="productId" from="asset.productId"/>
                <econdition field-name="facilityId" from="asset.facilityId"/>
                <econdition field-name="ownerPartyId" from="asset.ownerPartyId" ignore="assetAllowOtherOwner == 'Y' || !ownerPartyIdSet"/>
                <econdition field-name="quantityNotAvailable" operator="greater" from="0.0"/>
                <order-by field-name="priority"/><order-by field-name="reservedDate"/>
            </entity-find>
            <iterate list="resList" entry="res">
                <set field="quantityToMove" from="availableRemaining &lt; res.quantityNotAvailable ?
                        availableRemaining : res.quantityNotAvailable"/>
                <!-- quantityNotAvailable > 0 from query so if 0 means nothing left -->
                <if condition="quantityToMove == 0.0"><break/></if>
                <!-- make sure quantityToMove is less than res.quantityNotIssued, don't move issued quantities! -->
                <if condition="quantityToMove &gt; res.quantityNotIssued"><set field="quantityToMove" from="res.quantityNotIssued"/></if>
                <if condition="quantityToMove &gt; 0.0">
                    <service-call name="mantle.product.AssetServices.move#AssetReservation"
                            out-map="moveArOut" out-map-add-to-existing="false"
                            in-map="[assetId:assetId, assetReservationId:res.assetReservationId, quantity:quantityToMove]"/>
                    <set field="availableRemaining" from="availableRemaining - (moveArOut.quantityMoved ?: 0.0)"/>
                    <set field="quantityMoved" from="quantityMoved + (moveArOut.quantityMoved ?: 0.0)"/>
                </if>
            </iterate>
        </actions>
    </service>
    <service verb="move" noun="AssetReservation" no-tx-cache="true">
        <description>Move partial or full reservation quantity to another asset.</description>
        <in-parameters>
            <parameter name="assetReservationId" required="true"/>
            <parameter name="assetId" required="true"/>
            <parameter name="quantity" type="BigDecimal" required="true"/>
            <parameter name="forceFullQuantity" type="Boolean" default="false"><description>If true ignore
                available to promise on asset and moves the quantity to it anyway.</description></parameter>
        </in-parameters>
        <out-parameters><parameter name="quantityMoved"/></out-parameters>
        <actions>
            <entity-find-one entity-name="mantle.product.asset.Asset" value-field="asset" for-update="true"/>
            <entity-find-one entity-name="mantle.product.issuance.AssetReservation" value-field="assetReservation" for-update="true"/>

            <!-- if Asset.assetPoolId make sure AssetReservation is for an order that qualifies for the pool -->
            <if condition="asset.assetPoolId">
                <if condition="!assetReservation.orderId || !assetReservation.orderItemSeqId">
                    <log level="warn" message="Cannot move reservation ${assetReservationId} with no orderId or orderItemSeqId to asset ${assetId} with assetPoolId ${asset.assetPoolId}"/>
                    <set field="quantityMoved" from="0.0"/>
                    <return/>
                </if>
                <set field="orderItem" from="assetReservation.orderItem"/>
                <set field="orderPart" from="orderItem.part"/>
                <set field="orderHeader" from="orderItem.header"/>
                <service-call name="mantle.product.AssetServices.get#AssetPools" out-map="poolsOut"
                        in-map="[productStoreId:orderHeader.productStoreId, vendorPartyId:orderPart?.vendorPartyId,
                            customerPartyId:orderPart?.customerPartyId]"/>
                <set field="assetPoolIdSet" from="poolsOut.assetPoolIdSet"/>
                <if condition="!assetPoolIdSet || !assetPoolIdSet.contains(asset.assetPoolId)">
                    <set field="quantityMoved" from="0.0"/>
                    <return/>
                </if>
            </if>

            <if condition="quantity &gt; assetReservation.quantityNotIssued">
                <return error="true" message="Quantity to move (${quantity}) is greater than reservation [${assetReservationId}] quantity not yet issued (${assetReservation.quantityNotIssued}), not moving reservation"/></if>

            <if condition="forceFullQuantity"><then>
                <set field="quantityToMove" from="quantity"/>
            </then><else>
                <set field="quantityToMove" from="asset.availableToPromiseTotal &lt; quantity ? asset.availableToPromiseTotal : quantity"/>
                <if condition="quantityToMove &lt; 0.0"><set field="quantityToMove" from="0.0"/></if>
            </else></if>

            <set field="quantityMoved" from="quantityToMove"/>
            <if condition="quantityToMove == 0.0"><return/></if>

            <if condition="quantityToMove == assetReservation.quantity"><then>
                <!-- move over the whole reservation -->

                <!-- increment old Asset ATP -->
                <service-call name="create#mantle.product.asset.AssetDetail" in-map="[assetId:assetReservation.assetId,
                        effectiveDate:ec.user.nowTimestamp, availableToPromiseDiff:quantityToMove,
                        assetReservationId:assetReservationId, productId:assetReservation.productId,
                        orderId:assetReservation.orderId, orderItemSeqId:assetReservation.orderItemSeqId]"/>
                <!-- decrement new Asset ATP -->
                <service-call name="create#mantle.product.asset.AssetDetail" in-map="[assetId:assetId,
                        effectiveDate:ec.user.nowTimestamp, availableToPromiseDiff:-quantityToMove,
                        assetReservationId:assetReservationId, productId:assetReservation.productId,
                        orderId:assetReservation.orderId, orderItemSeqId:assetReservation.orderItemSeqId]"/>

                <!-- set the new assetId and decrease quantityNotAvailable (should be to 0!) -->
                <set field="assetReservation.assetId" from="assetId"/>
                <set field="assetReservation.quantityNotAvailable"
                        from="assetReservation.quantityNotAvailable &gt; quantityToMove ?
                            assetReservation.quantityNotAvailable - quantityToMove : 0.0"/>
                <entity-update value-field="assetReservation"/>
            </then><else>
                <!-- see if there is an existing reservation on the target assetId to add to -->
                <entity-find entity-name="mantle.product.issuance.AssetReservation" list="existingReservationList">
                    <econdition field-name="assetId"/>
                    <econdition field-name="orderId" from="assetReservation.orderId"/>
                    <econdition field-name="orderItemSeqId" from="assetReservation.orderItemSeqId"/>
                    <order-by field-name="assetReservationId"/>
                </entity-find>
                <if condition="existingReservationList"><then>
                    <set field="existingRes" from="existingReservationList[0]"/>
                    <set field="newAssetReservationId" from="existingRes.assetReservationId"/>
                    <service-call name="update#mantle.product.issuance.AssetReservation" out-map="newResOut"
                            in-map="[assetReservationId:newAssetReservationId,
                                quantity:((existingRes.quantity ?: 0.0) + quantityToMove),
                                quantityNotIssued:((existingRes.quantityNotIssued ?: 0.0) + quantityToMove)]"/>
                </then><else>
                    <!-- create a new reservation, split the quantity -->
                    <service-call name="create#mantle.product.issuance.AssetReservation" out-map="newResOut"
                            in-map="assetReservation.getMap() + [assetReservationId:null, assetId:assetId,
                                quantity:quantityToMove, quantityNotAvailable:0.0, quantityNotIssued:quantityToMove]"/>
                    <set field="newAssetReservationId" from="newResOut.assetReservationId"/>
                </else></if>

                <!-- decrement old reservation quantities -->
                <set field="assetReservation.quantity" from="assetReservation.quantity - quantityToMove"/>
                <set field="assetReservation.quantityNotAvailable"
                        from="assetReservation.quantityNotAvailable &gt; quantityToMove ?
                            assetReservation.quantityNotAvailable - quantityToMove : 0.0"/>
                <set field="assetReservation.quantityNotIssued" from="assetReservation.quantityNotIssued - quantityToMove"/>
                <if condition="assetReservation.quantity &lt; 0.0">
                    <return error="true" message="In move#AssetReservation got negative quantity ${assetReservation.quantity}, quantity to move ${quantityToMove}"/></if>
                <entity-update value-field="assetReservation"/>

                <!-- increment old Asset ATP -->
                <service-call name="create#mantle.product.asset.AssetDetail" in-map="[assetId:assetReservation.assetId,
                    effectiveDate:ec.user.nowTimestamp, availableToPromiseDiff:quantityToMove,
                    assetReservationId:assetReservationId, productId:assetReservation.productId,
                    orderId:assetReservation.orderId, orderItemSeqId:assetReservation.orderItemSeqId]"/>
                <!-- decrement new Asset ATP -->
                <service-call name="create#mantle.product.asset.AssetDetail" in-map="[assetId:assetId,
                    effectiveDate:ec.user.nowTimestamp, availableToPromiseDiff:-quantityToMove,
                    assetReservationId:newAssetReservationId, productId:assetReservation.productId,
                    orderId:assetReservation.orderId, orderItemSeqId:assetReservation.orderItemSeqId]"/>
            </else></if>
        </actions>
    </service>

    <service verb="move" noun="ReservationsFromNonPickLocations">
        <in-parameters>
            <parameter name="assetId" required="true"><description>Should be in a FltPick type FacilityLocation but not enforced,
                must have positive availableToPromiseTotal or does nothing</description></parameter>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="mantle.product.asset.Asset" value-field="asset" for-update="true"/>
            <entity-find-related-one value-field="asset" relationship-name="location" to-value-field="facilityLocation" cache="true"/>

            <entity-find entity-name="mantle.product.asset.AssetLocationDetail" list="nonPickAssetList">
                <!-- assets in non-pick locations, or no location -->
                <econdition field-name="locationTypeEnumId" operator="not-equals" value="FltPick" or-null="true"/>
                <!-- exclude current assetId just in case is not in a Pick type locations -->
                <econdition field-name="assetId" operator="not-equals" from="assetId"/>
                <!-- only look for Assets with reservations, ie ATP < QOH (more efficient than joining in AssetReservation) -->
                <econdition field-name="availableToPromiseTotal" operator="less" to-field-name="quantityOnHandTotal"/>
                <!-- asset group distinguishing fields, excluding locationSeqId because we want to look in all of Facility -->
                <!-- NOTE fields like assetPoolId and ownerPartyId may be null and if null should only match other Asset records with null values -->
                <econdition field-name="productId" from="asset.productId"/>
                <econdition field-name="facilityId" from="asset.facilityId"/>
                <econdition field-name="ownerPartyId" from="asset.ownerPartyId"/>
                <econdition field-name="assetPoolId" from="asset.assetPoolId"/>
                <!-- lotId is NOT restricted on purpose, possible for inventory allocation to older lot to get allocated to newer
                    lot if newer lot assets are moved to a pick location (being in a pick location trumps lot, receive date, etc) -->
                <select-field field-name="assetId,availableToPromiseTotal,quantityOnHandTotal"/>
                <select-field field-name="locationSeqId,locationTypeEnumId,description,areaId,aisleId,sectionId,levelId,positionId"/>
                <!-- order by receivedDate to match default reservation sort of oldest inventory first;
                    consider something more fancy like least convenient locations or smallest quantity reserved to better consolidate -->
                <order-by field-name="receivedDate"/>
            </entity-find>

            <set field="remainingQuantity" from="asset.availableToPromiseTotal ?: 0.0"/>
            <iterate list="nonPickAssetList" entry="nonPickAsset">
                <if condition="remainingQuantity == 0.0"><break/></if>
                <set field="remainingQuantityBefore" from="remainingQuantity"/>
                <!-- for each AssetReservation move lesser of remainingQuantity and quantityNotIssued -->
                <entity-find entity-name="mantle.product.issuance.AssetReservation" list="resList">
                    <econdition field-name="assetId" from="nonPickAsset.assetId"/>
                    <order-by field-name="reservedDate"/>
                </entity-find>
                <iterate list="resList" entry="assetRes">
                    <set field="quantityReserved" from="assetRes.quantityNotIssued"/>
                    <set field="quantityToMove" from="quantityReserved &gt; remainingQuantity ? remainingQuantity : quantityReserved"/>
                    <if condition="quantityToMove &gt; 0.0">
                        <service-call name="mantle.product.AssetServices.move#AssetReservation" out-map="moveArOut" out-map-add-to-existing="false"
                                in-map="[assetId:assetId, assetReservationId:assetRes.assetReservationId, quantity:quantityToMove]"/>
                        <set field="remainingQuantity" from="remainingQuantity - quantityToMove"/>
                    </if>
                    <if condition="remainingQuantity == 0.0"><break/></if>
                </iterate>
                <set field="resQuantityMoved" from="remainingQuantityBefore - remainingQuantity"/>
                <if condition="resQuantityMoved &gt; 0.0">
                    <message>Moved other reservations for total quantity ${resQuantityMoved} from location ${ec.resource.expand("FacilityLocationNameTemplate", null, facilityLocation)} to Pick location ${ec.resource.expand("FacilityLocationNameTemplate", null, nonPickAsset)}</message>
                </if>
            </iterate>

        </actions>
    </service>

    <service verb="check" noun="AssetReservations">
        <description>Make sure all reservations are valid, and if there is ATP available after that
            check for not available reservations that can be moved to this Asset</description>
        <in-parameters>
            <parameter name="assetId" required="true"/>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="mantle.product.asset.Asset" value-field="asset" for-update="true"/>
            <entity-find entity-name="mantle.product.issuance.AssetReservation" list="assetReservationList">
                <econdition field-name="assetId"/></entity-find>
            <iterate list="assetReservationList" entry="assetReservation">
                <service-call name="mantle.product.AssetServices.check#AssetReservationValid"
                        in-map="[assetReservationId:assetReservation.assetReservationId,
                            assetReservation:assetReservation, asset:asset]"/>
            </iterate>

            <!-- refresh Asset, check ATP -->
            <entity-find-one entity-name="mantle.product.asset.Asset" value-field="asset" for-update="true"/>
            <if condition="asset.availableToPromiseTotal &gt; 0.0">
                <service-call name="mantle.product.AssetServices.reserve#IncreasedAsset" in-map="[assetId:assetId]"/>
            </if>
        </actions>
    </service>
    <service verb="check" noun="AssetReservationValid">
        <description>Check an AssetReservation to see if it is still valid for the Asset it is reserved against, if not re-reserve</description>
        <in-parameters>
            <parameter name="assetReservationId" required="true"/>
            <parameter name="assetReservation" type="EntityValue"/>
            <parameter name="asset" type="EntityValue"/>
            <parameter name="orderItem" type="EntityValue"/>
        </in-parameters>
        <out-parameters>
            <parameter name="reservationInvalid" type="Boolean"/>
            <parameter name="quantityNotValid" type="BigDecimal"/>
        </out-parameters>
        <actions>
            <set field="reservationInvalid" from="false"/>
            <set field="quantityNotValid" from="0.0"/>

            <if condition="assetReservation == null">
                <entity-find-one entity-name="mantle.product.issuance.AssetReservation" value-field="assetReservation"/></if>
            <if condition="assetReservation == null"><return message="Reservation not found for ID ${assetReservationId}"/></if>

            <if condition="asset == null">
                <set field="asset" from="assetReservation.asset"/></if>
            <if condition="asset == null"><return message="Asset not found for ID ${assetId}"/></if>

            <if condition="orderItem == null"><set field="orderItem" from="assetReservation.orderItem"/></if>

            <if condition="!reservationInvalid &amp;&amp; asset.statusId != 'AstAvailable'">
                <log message="AssetReservation ${assetReservationId} for OrderItem ${orderItem.orderId}:${orderItem.orderItemSeqId} is no longer valid for Asset ${asset.assetId} in status ${asset.statusId}"/>
                <set field="reservationInvalid" from="true"/>
            </if>

            <if condition="!reservationInvalid &amp;&amp; asset.facilityId">
                <!-- see ff matches OrderPart.facilityId, if there is one -->
                <if condition="orderItem != null">
                    <if condition="orderPart == null"><set field="orderPart" from="orderItem.part"/></if>

                    <if condition="orderPart.facilityId"><then>
                        <if condition="asset.facilityId != orderPart.facilityId">
                            <log message="AssetReservation ${assetReservationId} for OrderItem ${orderItem.orderId}:${orderItem.orderItemSeqId} is no longer valid for Asset ${asset.assetId} with facilityId ${asset.facilityId}, order part facilityId ${orderPart.facilityId}"/>
                            <set field="reservationInvalid" from="true"/>
                        </if>
                    </then><else>
                        <!-- otherwise check ProductStore associated facilities -->
                        <if condition="orderHeader == null"><set field="orderHeader" from="orderItem.header"/></if>
                        <set field="productStore" from="orderHeader.productStore"/>

                        <set field="facilityIdSet" from="new TreeSet()"/>
                        <if condition="productStore.inventoryFacilityId">
                            <script>facilityIdSet.add(productStore.inventoryFacilityId)</script></if>
                        <entity-find entity-name="mantle.product.store.ProductStoreFacility" list="productStoreFacilityList">
                            <date-filter/><econdition field-name="productStoreId"/></entity-find>
                        <if condition="productStoreFacilityList">
                            <script>facilityIdSet.addAll(productStoreFacilityList*.facilityId)</script></if>

                        <if condition="!facilityIdSet.contains(asset.facilityId)">
                            <log message="AssetReservation ${assetReservationId} for OrderItem ${orderItem.orderId}:${orderItem.orderItemSeqId} is no longer valid for Asset ${asset.assetId} with facilityId ${asset.facilityId}, ProductStore facilities available ${facilityIdSet}"/>
                            <set field="reservationInvalid" from="true"/>
                        </if>
                    </else></if>
                </if>
            </if>

            <!-- if Asset.assetPoolId make sure AssetReservation is for an order that qualifies for the pool -->
            <if condition="!reservationInvalid &amp;&amp; asset.assetPoolId">
                <if condition="!assetReservation.orderId || !assetReservation.orderItemSeqId"><then>
                    <log message="AssetReservation ${assetReservationId} with no orderId or orderItemSeqId to asset ${assetId} with assetPoolId ${asset.assetPoolId} is not valid"/>
                    <set field="reservationInvalid" from="true"/>
                </then><else>
                    <if condition="orderItem == null"><set field="orderItem" from="assetReservation.orderItem"/></if>
                    <if condition="orderPart == null"><set field="orderPart" from="orderItem.part"/></if>
                    <if condition="orderHeader == null"><set field="orderHeader" from="orderItem.header"/></if>
                    <service-call name="mantle.product.AssetServices.get#AssetPools" out-map="poolsOut"
                            in-map="[productStoreId:orderHeader.productStoreId, vendorPartyId:orderPart?.vendorPartyId,
                                customerPartyId:orderPart?.customerPartyId]"/>
                    <set field="assetPoolIdSet" from="poolsOut.assetPoolIdSet"/>
                    <if condition="!assetPoolIdSet || !assetPoolIdSet.contains(asset.assetPoolId)">
                        <log message="AssetReservation ${assetReservationId} for OrderItem ${orderItem.orderId}:${orderItem.orderItemSeqId} is no longer valid for Asset ${asset.assetId} with assetPoolId ${asset.assetPoolId}, available pools ${assetPoolIdSet}"/>
                        <set field="reservationInvalid" from="true"/>
                    </if>
                </else></if>
            </if>

            <if condition="reservationInvalid">
                <set field="quantityNotValid" from="assetReservation.quantity"/>

                <!-- reservation not valid, delete and try to re-reserve for OrderItem -->
                <service-call name="mantle.product.AssetServices.reduce#AssetReservation"
                        in-map="[assetReservationId:assetReservationId, reserveIncreasedAsset:true]"/>
                <if condition="!assetReservation.orderId || !assetReservation.orderItemSeqId"><then>
                    <log level="warn" message="AssetReservation ${assetReservationId} has no order item and is no longer valid but cannot re-reserve"/>
                </then><else>
                    <service-call name="mantle.product.AssetServices.reserve#AssetForOrderItem"
                            in-map="[orderId:assetReservation.orderId, orderItemSeqId:assetReservation.orderItemSeqId,
                                skipAssetIds:[asset.assetId]]"/>
                </else></if>
            </if>
        </actions>
    </service>
    <service verb="check" noun="FacilityReservations" transaction-timeout="1800">
        <description>Make sure all reservations are valid, and if there is ATP available after that
            check for not available reservations that can be moved to this Asset</description>
        <in-parameters>
            <parameter name="facilityId" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="invalidReservationCount" type="Integer"/>
            <parameter name="quantityNotValid" type="BigDecimal"/>
            <parameter name="quantityMoved" type="BigDecimal"/>
        </out-parameters>
        <actions>
            <set field="invalidReservationCount" from="0"/>
            <set field="quantityNotValid" from="0.0"/>
            <set field="quantityMoved" from="0.0"/>

            <!-- get big list of only assetReservationId, then check each for validity -->
            <entity-find entity-name="mantle.product.issuance.AssetAndReservation" list="assetReservationList">
                <econdition field-name="facilityId"/>
                <select-field field-name="assetReservationId"/>
            </entity-find>
            <iterate list="assetReservationList" entry="assetReservation">
                <service-call name="mantle.product.AssetServices.check#AssetReservationValid"
                        out-map="checkValidOut" out-map-add-to-existing="false"
                        in-map="[assetReservationId:assetReservation.assetReservationId]"/>
                <if condition="checkValidOut.reservationInvalid">
                    <set field="invalidReservationCount" from="invalidReservationCount + 1"/>
                    <set field="quantityNotValid" from="quantityNotValid + (checkValidOut.quantityNotValid ?: 0.0)"/>
                </if>
            </iterate>

            <!-- find all Asset with availableToPromiseTotal and move not available reservations -->
            <entity-find entity-name="mantle.product.asset.Asset" list="assetList">
                <econdition field-name="facilityId"/>
                <econdition field-name="availableToPromiseTotal" operator="greater" from="0.0"/>
                <select-field field-name="assetId"/>
            </entity-find>
            <iterate list="assetList" entry="asset">
                <service-call name="mantle.product.AssetServices.reserve#IncreasedAsset"
                        out-map="reserveOut" out-map-add-to-existing="false"
                        in-map="[assetId:asset.assetId]"/>
                <set field="quantityMoved" from="quantityMoved + (reserveOut.quantityMoved ?: 0.0)"/>
            </iterate>

            <if condition="invalidReservationCount">
                <message>In check facility ${facilityId} reservations found ${invalidReservationCount} invalid reservations with total quantity ${quantityNotValid}</message>
            </if>
            <if condition="quantityMoved">
                <message>In check facility ${facilityId} reservations moved ${quantityMoved} not available reservations to available inventory</message>
            </if>
        </actions>
    </service>

    <service verb="displace" noun="AssetReservations" no-tx-cache="true">
        <description>When forcing the use of a certain Asset for an OrderItem, move other reservations as needed to
            handle quantity that the given OrderItem will be using (note that this doesn't do an additional reservation,
            just removes reservations from other OrderItems).</description>
        <in-parameters>
            <parameter name="assetId" required="true"/>
            <parameter name="quantity" type="BigDecimal" required="true"><description>The full quantity, for an OrderItem
                quantity already on asset specified and the asset's availableToPromiseTotal will be subtracted</description></parameter>
            <parameter name="orderId"/>
            <parameter name="orderItemSeqId"/>
        </in-parameters>
        <actions>
            <!-- get quantity available for the asset, don't need to move reservations to cover this quantity -->
            <entity-find-one entity-name="mantle.product.asset.Asset" value-field="asset" for-update="true"/>
            <set field="availableToPromiseTotal" from="asset.availableToPromiseTotal"/>

            <!-- get quantity already reserved on this asset -->
            <set field="assetQuantityReserved" from="0.0"/>
            <entity-find entity-name="mantle.product.issuance.AssetReservation" list="assetAllResList">
                <econdition field-name="quantityNotIssued" operator="greater" from="0.0"/>
                <econdition field-name="assetId"/>
                <order-by field-name="-reservedDate"/><!-- so that newest reservations are moved first -->
            </entity-find>
            <if condition="orderId &amp;&amp; orderItemSeqId"><then>
                <filter-map-list list="assetAllResList" to-list="assetReservationList">
                    <field-map field-name="orderId"/><field-map field-name="orderItemSeqId"/></filter-map-list>
                <set field="assetOtherResList" from="assetAllResList - assetReservationList"/>

                <iterate list="assetReservationList" entry="assetReservation">
                    <set field="assetQuantityReserved" from="assetQuantityReserved + assetReservation.quantityNotIssued"/></iterate>
            </then><else>
                <set field="assetOtherResList" from="assetAllResList"/>
            </else></if>

            <!-- calc quantity of reservations we need to move -->
            <set field="resQuantityToMove" from="quantity - assetQuantityReserved - availableToPromiseTotal"/>

            <!-- <log level="warn" message="Displace asset ${assetId} order ${orderId} assetQuantityReserved ${assetQuantityReserved} resQuantityToMove ${resQuantityToMove}"/> -->

            <if condition="resQuantityToMove &gt; 0.0">
                <!-- move from the most recent, but remove res and re-reserve oldest first -->
                <set field="resQuantityRemaining" from="resQuantityToMove"/>
                <set field="resToMoveList" from="[]"/>
                <iterate list="assetOtherResList" entry="assetOtherRes">
                    <if condition="resQuantityRemaining == 0.0"><break/></if>
                    <set field="curMoveQuantity" from="resQuantityRemaining &gt; assetOtherRes.quantityNotIssued ? assetOtherRes.quantityNotIssued : resQuantityRemaining"/>
                    <script>resToMoveList.add(assetOtherRes)</script>
                    <set field="resQuantityRemaining" from="resQuantityRemaining - curMoveQuantity"/>
                </iterate>
                <!-- <log level="warn" message="Displace asset ${assetId} resToMoveList ${resToMoveList.collect({[assetReservationId:it.assetReservationId, assetId:it.assetId, orderId:it.orderId, quantity:it.quantity]})}"/> -->

                <!-- now reverse resToMoveList and move 'em -->
                <script>Collections.reverse(resToMoveList)</script>
                <!-- remove the reservation and re-reserve to any asset available -->
                <set field="resQuantityRemaining" from="resQuantityToMove"/>
                <iterate list="resToMoveList" entry="resToMove">
                    <if condition="resQuantityRemaining == 0.0"><break/></if>
                    <set field="curMoveQuantity" from="resQuantityRemaining &gt; resToMove.quantityNotIssued ? resToMove.quantityNotIssued : resQuantityRemaining"/>

                    <!-- NOTE in this case we want to reduce#AssetReservation but not reserveIncreasedAsset so that still available for the displace -->
                    <service-call name="mantle.product.AssetServices.reduce#AssetReservation" out-map="reduceArOut" out-map-add-to-existing="false"
                            in-map="[assetReservationId:resToMove.assetReservationId, quantityToDeduct:curMoveQuantity, reserveIncreasedAsset:false]"/>

                    <service-call name="mantle.product.AssetServices.reserve#AssetForOrderItem"
                            in-map="[orderId:resToMove.orderId, orderItemSeqId:resToMove.orderItemSeqId, skipAssetIds:[assetId]]"/>

                    <set field="resQuantityRemaining" from="resQuantityRemaining - reduceArOut.quantityDeducted"/>
                </iterate>
            </if>

            <!-- also clear out other reservations for this OrderItem -->
            <set field="resQuantityToClear" from="quantity - assetQuantityReserved"/>
            <if condition="resQuantityToClear &gt; 0.0 &amp;&amp; orderId &amp;&amp; orderItemSeqId">
                <entity-find entity-name="mantle.product.issuance.AssetReservation" list="oiOtherResList">
                    <econdition field-name="assetId" operator="not-equals"/>
                    <econdition field-name="orderId"/><econdition field-name="orderItemSeqId"/>
                    <!-- productId filter critical for PtPickAssembly products -->
                    <econdition field-name="productId" from="asset.productId"/>
                    <econdition field-name="quantityNotIssued" operator="greater" from="0.0"/>
                </entity-find>
                <iterate list="oiOtherResList" entry="oiOtherRes">
                    <if condition="resQuantityToClear == 0.0"><break/></if>
                    <set field="curReduceQuantity" from="resQuantityToClear &gt; oiOtherRes.quantityNotIssued ? oiOtherRes.quantityNotIssued : resQuantityToClear"/>
                    <!-- NOTE in this case we want to reduce#AssetReservation but not reserveIncreasedAsset so that still available for the displace -->
                    <service-call name="mantle.product.AssetServices.reduce#AssetReservation" out-map="reduceArOut"
                            in-map="[assetReservationId:oiOtherRes.assetReservationId, quantityToDeduct:curReduceQuantity, reserveIncreasedAsset:false]"/>
                    <set field="resQuantityToClear" from="resQuantityToClear - reduceArOut.quantityDeducted"/>
                </iterate>
            </if>

            <!-- for debugging
            <entity-find entity-name="mantle.product.issuance.AssetReservation" list="assetAllResList">
                <econdition field-name="assetId"/></entity-find>
            <log level="warn" message="Post Displace asset ${assetId} assetAllResList ${assetAllResList.collect({[assetReservationId:it.assetReservationId, assetId:it.assetId, orderId:it.orderId, quantity:it.quantity]})}"/>
            -->
        </actions>
    </service>

    <service verb="change" noun="AssetQuantity" no-tx-cache="true">
        <in-parameters>
            <auto-parameters entity-name="mantle.product.asset.AssetDetail" include="nonpk">
                <exclude field-name="quantityOnHandDiff"/><exclude field-name="availableToPromiseDiff"/></auto-parameters>
            <parameter name="assetId" required="true"/>
            <parameter name="quantityDiff" type="BigDecimal" required="true"/>
            <parameter name="effectiveDate" type="Timestamp" default="ec.user.nowTimestamp"/>
        </in-parameters>
        <actions>
            <if condition="quantityDiff == 0.0"><return type="warning" message="Not changing quantity for Asset ${assetId}, quantityDiff is zero"/></if>

            <entity-find-one entity-name="mantle.product.asset.Asset" value-field="asset" for-update="true">
                <field-map field-name="assetId"/></entity-find-one>

            <!-- NOTE: AssetDetail must be created before potentially changing the status below; in condition below it uses the prior asset record (ie not refreshed from DB to update QOH) -->
            <service-call name="create#mantle.product.asset.AssetDetail" in-map="context +
                    [quantityOnHandDiff:quantityDiff, availableToPromiseDiff:quantityDiff]"/>

            <!-- if this is serialized inventory update status and set ownerPartyId to customer party -->
            <if condition="asset.serialNumber &amp;&amp; quantityDiff == -1.0 &amp;&amp; (asset.quantityOnHandTotal == 1.0 || asset.hasQuantity == 'N')">
                <set field="ownerPartyId" from="null"/>
                <if condition="orderId &amp;&amp; orderItemSeqId">
                    <entity-find-one entity-name="mantle.order.OrderItem" value-field="orderItem"/>
                    <set field="orderPart" from="orderItem?.part"/>
                    <set field="ownerPartyId" from="orderPart?.customerPartyId"/>
                </if>
                <if condition="!ownerPartyId &amp;&amp; shipmentId">
                    <entity-find-one entity-name="mantle.shipment.Shipment" value-field="shipment"/>
                    <set field="ownerPartyId" from="shipment?.toPartyId"/>
                </if>
                <service-call name="update#mantle.product.asset.Asset"
                        in-map="[assetId:asset.assetId, statusId:'AstDelivered', ownerPartyId:(ownerPartyId ?: asset.ownerPartyId)]"/>
            </if>

            <!-- reserve the newly available Asset, if needed -->
            <if condition="quantityDiff &gt; 0.0 &amp;&amp; asset.productId">
                <service-call name="mantle.product.AssetServices.reserve#IncreasedAsset" in-map="[assetId:assetId]"/></if>

            <!-- on decrease adjust reservations down and re-reserve -->
            <if condition="quantityDiff &lt; 0.0 &amp;&amp; asset.productId">
                <entity-find-one entity-name="mantle.product.asset.Asset" value-field="asset" for-update="true">
                    <field-map field-name="assetId"/></entity-find-one>
                <if condition="asset.availableToPromiseTotal &lt; 0.0">
                    <set field="negativeAvailable" from="-asset.availableToPromiseTotal"/>
                    <set field="reduceQuantityRemaining" from="-quantityDiff"/>
                    <if condition="reduceQuantityRemaining &gt; negativeAvailable">
                        <set field="reduceQuantityRemaining" from="negativeAvailable"/></if>

                    <entity-find entity-name="mantle.product.issuance.AssetReservation" list="existingResList">
                        <econdition field-name="assetId"/>
                        <order-by field-name="-reservedDate"/><!-- get most recent first for reducing reservation quantities -->
                    </entity-find>
                    <iterate list="existingResList" entry="res">
                        <if condition="reduceQuantityRemaining == 0.0"><break/></if>

                        <!-- don't just adjust quantityNotAvailable, try to re-reserve against other assets:
                        <set field="quantityAvailable" from="res.quantity - (res.quantityNotAvailable ?: 0.0)"/>
                        <set field="quantityToReduce" from="quantityAvailable &gt; reduceQuantityRemaining ? reduceQuantityRemaining : quantityAvailable"/>
                        <set field="res.quantityNotAvailable" from="res.quantityNotAvailable + quantityToReduce"/>
                        <entity-update value-field="res"/>
                        <set field="reduceQuantityRemaining" from="reduceQuantityRemaining - quantityToReduce"/>
                        -->

                        <set field="quantityToReduce" from="reduceQuantityRemaining &gt; res.quantityNotIssued ? res.quantityNotIssued : reduceQuantityRemaining"/>

                        <!-- NOTE could reserveIncreasedAsset here but would do no good, point is to bring ATP from negative to zero -->
                        <service-call name="mantle.product.AssetServices.reduce#AssetReservation" out-map="reduceArOut" out-map-add-to-existing="false"
                                in-map="[assetReservationId:res.assetReservationId, quantityToDeduct:quantityToReduce, reserveIncreasedAsset:false]"/>
                        <service-call name="mantle.product.AssetServices.reserve#AssetForOrderItem"
                                in-map="[orderId:res.orderId, orderItemSeqId:res.orderItemSeqId, skipAssetIds:[assetId]]"/>

                        <set field="reduceQuantityRemaining" from="reduceQuantityRemaining - reduceArOut.quantityDeducted"/>
                    </iterate>
                    <!-- NOTE DEJ 20190413 this call is not needed since reserve#AssetForOrderItem is called for each reduced reservation, and it is a dangerous service so best to avoid: -->
                    <!-- now that quantityNotAvailable is updated see if we can reserve those on other assets -->
                    <!-- <service-call name="mantle.product.AssetServices.checkReserve#ProductAssets" in-map="[productId:asset.productId]"/> -->
                </if>
            </if>
        </actions>
    </service>
    <!-- WARNING: don't use this service. The general concept is flawed, needs to be more constrained and/or better handle more complex data scenarios
    <service verb="checkReserve" noun="ProductAssets">
        <description>
            WARNING: don't use this service. The general concept is flawed, needs to be more constrained and/or better handle more complex data scenarios
            For a given productId see if there are AssetReservation.quantityNotAvailable and Asset.availableToPromiseTotal, if so update reservations
        </description>
        <in-parameters><parameter name="productId" required="true"/></in-parameters>
        <actions>
            <entity-find-count entity-name="mantle.product.issuance.AssetReservation" count-field="notAvailResCount">
                <econdition field-name="productId"/><econdition field-name="quantityNotAvailable" operator="greater" from="0.0"/></entity-find-count>
            <if condition="notAvailResCount == 0"><return/></if>

            <while condition="notAvailResCount &gt; 0">
                <entity-find entity-name="mantle.product.asset.Asset" list="availAssetList" limit="1">
                    <econdition field-name="productId"/>
                    <econdition field-name="availableToPromiseTotal" operator="greater" from="0.0"/>
                    <order-by field-name="receivedDate"/><!- - get oldest first for filling quantityNotAvailable - ->
                </entity-find>
                <if condition="availAssetList.size() == 0"><break/></if>
                <!- - move reservation(s) to this asset - ->
                <service-call name="mantle.product.AssetServices.reserve#IncreasedAsset" in-map="[assetId:availAssetList[0].assetId]"/>
                <!- - see if we have any more not available reservations - ->
                <entity-find-count entity-name="mantle.product.issuance.AssetReservation" count-field="notAvailResCount">
                    <econdition field-name="productId"/><econdition field-name="quantityNotAvailable" operator="greater" from="0.0"/></entity-find-count>
            </while>
        </actions>
    </service>
    -->

    <!-- ======================================= -->
    <!-- ========== Issuance Services ========== -->
    <!-- ======================================= -->

    <service verb="issue" noun="AssetReservation" no-tx-cache="true">
        <description>Issue an Asset based on a reservation (AssetReservation). This is currently called by
            ShipmentServices.pack#ShipmentItemSource and pack#ShipmentAssemblyComponent.
            All callers should query and lock all Asset records planned to
            issue from before from issuing any (as ShipmentServices.pack#ShipmentItemSource does).</description>
        <in-parameters>
            <parameter name="assetReservation" type="EntityValue" required="true"/>
            <parameter name="shipmentId"/>
            <parameter name="shipmentItemSourceId"/>
            <parameter name="workEffortId"/>
            <parameter name="quantity" type="BigDecimal" required="true"/>
            <parameter name="issuedDate" type="Timestamp" default="ec.user.nowTimestamp"/>
        </in-parameters>
        <actions>
            <if condition="quantity == 0.0"><return type="warning" message="Not issuing zero quantity against AssetReservation ${assetReservation?.assetReservationId}"/></if>

            <if condition="quantity &gt; assetReservation.quantityNotIssued">
                <return error="true" message="For reservation ${assetReservation.assetReservationId} tried to issue quantity ${quantity} which is greater than quantity not issued ${assetReservation.quantityNotIssued} for the reservation"/></if>

            <!-- if allow over QOH not allowed check now -->
            <set field="asset" from="assetReservation.asset"/>
            <entity-find-one entity-name="mantle.facility.Facility" value-field="facility" cache="true">
                <field-map field-name="facilityId" from="asset?.facilityId"/></entity-find-one>
            <if condition="facility?.assetAllowIssueOverQoh != 'Y'">
                <if condition="quantity &gt; asset.quantityOnHandTotal">
                    <return error="true" message="For reservation ${assetReservation.assetReservationId} tried to issue quantity ${quantity} which is greater than quantity on hand ${asset.quantityOnHandTotal} for asset ${asset.assetId}"/></if>
            </if>

            <if condition="shipmentItemSourceId">
                <entity-find-one entity-name="mantle.shipment.ShipmentItemSource" value-field="shipmentItemSource"/>
                <if condition="!shipmentId"><set field="shipmentId" from="shipmentItemSource.shipmentId"/></if>
            </if>

            <!-- see if there is another issuance we can add to -->
            <entity-find entity-name="mantle.product.issuance.AssetIssuance" list="existingIssuanceList">
                <econdition field-name="shipmentId" ignore-if-empty="true"/>
                <econdition field-name="shipmentItemSourceId" ignore-if-empty="true"/>
                <econdition field-name="workEffortId" ignore-if-empty="true"/>
                <econdition field-name="assetReservationId" from="assetReservation.assetReservationId"/>
                <!-- these 3 shouldn't be necessary when constrained by assetReservationId but just in case -->
                <econdition field-name="assetId" from="assetReservation.assetId"/>
                <econdition field-name="orderId" from="assetReservation.orderId" ignore-if-empty="true"/>
                <econdition field-name="orderItemSeqId" from="assetReservation.orderItemSeqId" ignore-if-empty="true"/>
            </entity-find>
            <if condition="existingIssuanceList"><then>
                <!-- add to existing issuance -->
                <set field="existingIssuance" from="existingIssuanceList[0]"/>
                <set field="assetIssuanceId" from="existingIssuance.assetIssuanceId"/>
                <service-call name="update#mantle.product.issuance.AssetIssuance"
                        in-map="[assetIssuanceId:assetIssuanceId, quantity:(existingIssuance.quantity + quantity),
                            invoiceId:(existingIssuance.invoiceId ?: shipmentItemSource?.invoiceId),
                            invoiceItemSeqId:(existingIssuance.invoiceItemSeqId ?: shipmentItemSource?.invoiceItemSeqId)]"/>
            </then><else>
                <!-- create an issuance, get back assetIssuanceId -->
                <service-call name="create#mantle.product.issuance.AssetIssuance" out-map="context"
                        in-map="[assetId:assetReservation.assetId, assetReservationId:assetReservation.assetReservationId,
                            orderId:assetReservation.orderId, orderItemSeqId:assetReservation.orderItemSeqId,
                            invoiceId:shipmentItemSource?.invoiceId, invoiceItemSeqId:shipmentItemSource?.invoiceItemSeqId,
                            shipmentId:shipmentId, shipmentItemSourceId:shipmentItemSourceId,
                            workEffortId:workEffortId, productId:assetReservation.productId,
                            issuedDate:issuedDate, issuedByUserId:ec.user.userId, quantity:quantity]"/>
            </else></if>

            <!-- create AssetDetail to decrement quantityOnHand -->
            <!-- NOTE: no availableToPromiseDiff because that was modified during the reservation -->
            <service-call name="create#mantle.product.asset.AssetDetail" in-map="[assetId:assetReservation.assetId,
                    effectiveDate:issuedDate, quantityOnHandDiff:-quantity,
                    assetReservationId:assetReservation.assetReservationId, shipmentId:shipmentId, workEffortId:workEffortId,
                    productId:assetReservation.productId, assetIssuanceId:assetIssuanceId,
                    orderId:assetReservation.orderId, orderItemSeqId:assetReservation.orderItemSeqId]"/>

            <set field="assetReservation.quantityNotIssued" from="assetReservation.quantityNotIssued - quantity"/>
            <if condition="assetReservation.quantityNotIssued == 0.0"><then>
                <entity-delete value-field="assetReservation"/>
            </then><else>
                <entity-update value-field="assetReservation"/>
            </else></if>

            <!-- if this is serialized inventory update status and set ownerPartyId to customer party -->
            <!-- NOTE: do after AssetDetail create and AssetReservation update so status change does not mess up ATP -->
            <if condition="asset.serialNumber &amp;&amp; quantity == 1.0 &amp;&amp; (asset.quantityOnHandTotal == 1.0 || asset.hasQuantity == 'N')">
                <set field="ownerPartyId" from="asset.ownerPartyId"/>
                <if condition="assetReservation.orderId &amp;&amp; assetReservation.orderItemSeqId">
                    <set field="orderItem" from="assetReservation.orderItem"/>
                    <set field="orderPart" from="orderItem?.part"/>
                    <if condition="orderPart?.customerPartyId"><set field="ownerPartyId" from="orderPart.customerPartyId"/></if>
                </if>
                <service-call name="update#mantle.product.asset.Asset"
                        in-map="[assetId:asset.assetId, statusId:'AstDelivered', ownerPartyId:ownerPartyId]"/>
            </if>
        </actions>
    </service>
    <service verb="issue" noun="Asset" no-tx-cache="true">
        <description>Issue an Asset (with no reservation) to a Shipment.</description>
        <in-parameters>
            <parameter name="assetId"><description>Optional assetId, issues against this first if specified.</description></parameter>
            <parameter name="shipmentId" required="true"/>
            <parameter name="shipmentItemSourceId"/>
            <parameter name="orderId"/>
            <parameter name="orderItemSeqId"/>
            <parameter name="invoiceId"/>
            <parameter name="invoiceItemSeqId"/>
            <parameter name="quantity" type="BigDecimal" required="true"/>
            <parameter name="issuedDate" type="Timestamp" default="ec.user.nowTimestamp"/>
        </in-parameters>
        <actions>
            <if condition="assetId"><entity-find-one entity-name="mantle.product.asset.Asset" value-field="passedAsset"/></if>
            <if condition="quantity == 0.0"><return message="Not issuing zero quantity for shipment ${shipmentId}"/></if>

            <!-- get facilityId from SRS.originFacilityId -->
            <entity-find entity-name="mantle.shipment.ShipmentRouteSegment" list="srsList" limit="1">
                <econdition field-name="shipmentId"/><order-by field-name="shipmentRouteSegmentSeqId"/></entity-find>
            <if condition="srsList"><set field="facilityId" from="srsList[0].originFacilityId"/></if>

            <if condition="orderId &amp;&amp; orderItemSeqId"><then>
                <entity-find-one entity-name="mantle.order.OrderHeader" value-field="orderHeader"/>
                <entity-find-one entity-name="mantle.order.OrderItem" value-field="orderItem"/>
                <!-- get productId from OrderItem -->
                <set field="productId" from="orderItem.productId"/>

                <!-- if no facilityId look at OrderPart -->
                <if condition="!facilityId">
                    <entity-find-related-one value-field="orderItem" relationship-name="mantle.order.OrderPart" to-value-field="orderPart"/>
                    <set field="facilityId" from="orderPart.facilityId"/>
                </if>
                <!-- still no facilityId? look at ProductStore.inventoryFacilityId -->
                <if condition="!facilityId">
                    <set field="productStore" from="orderHeader.'mantle.product.store.ProductStore'"/>
                    <set field="facilityId" from="productStore?.inventoryFacilityId"/>
                </if>

                <if condition="!facilityId"><return error="true" message="Could not find inventory facility for shipment ${shipmentId} and order item ${ec.resource.expand('OrderItemNameTemplate','')}"/></if>
            </then><else>
                <if condition="passedAsset != null"><then>
                    <set field="productId" from="passedAsset.productId"/>
                    <set field="facilityId" from="passedAsset.facilityId"/>
                    <set field="ownerPartyId" from="passedAsset.ownerPartyId"/>
                </then><else>
                    <return error="true" message="Cannot issue asset for Shipment ${shipmentId} without either assetId or orderId and orderItemSeqId"/>
                </else></if>
            </else></if>

            <if condition="!productId"><return error="true" message="Could not find product for shipment ${shipmentId} asset ${assetId} order item ${orderId}:${orderItemSeqId}"/></if>

            <entity-find-one entity-name="mantle.facility.Facility" value-field="facility" cache="true"/>
            <if condition="facility == null"><return error="true" message="Could not find facility to issue asset from for shipment ${shipmentId}"/></if>

            <set field="baseMap" from="[productId:productId, orderId:orderId, orderItemSeqId:orderItemSeqId,
                    invoiceId:invoiceId, invoiceItemSeqId:invoiceItemSeqId, shipmentId:shipmentId, shipmentItemSourceId:shipmentItemSourceId]"/>

            <set field="ownerPartyId" from="productStore?.organizationPartyId"/>
            <!-- no ProductStore organizationPartyId? try OrderPart.vendorPartyId (for sales orders should be an internal org) -->
            <if condition="!ownerPartyId &amp;&amp; orderItem != null">
                <if condition="orderPart == null"><set field="orderPart" from="orderItem.'mantle.order.OrderPart'"/></if>
                <set field="ownerPartyId" from="orderPart.vendorPartyId"/>
                <!-- if still not found, ignore -->
            </if>

            <entity-find entity-name="mantle.product.asset.Asset" list="assetList">
                <econdition field-name="productId"/>
                <econdition field-name="facilityId"/>
                <econdition field-name="ownerPartyId" ignore-if-empty="true"/>
                <econdition field-name="statusId" value="AstAvailable"/>
                <!-- TODO: honor AssetPool (use get#AssetPools service), others? -->
                <!-- reserve from oldest first (ascending receivedDate) -->
                <!-- TODO: this may be configurable in the future -->
                <order-by field-name="receivedDate"/>
            </entity-find>
            <!-- if assetId specified add it to the list -->
            <if condition="passedAsset != null"><script>assetList.add(0, passedAsset)</script></if>

            <if condition="assetList"><then>
                <!-- reserve by availableToPromiseTotal (no reservation here, but respect others) -->
                <set field="quantityRemaining" from="quantity"/>
                <iterate list="assetList" entry="asset">
                    <set field="lastAsset" from="asset"/>
                    <if condition="quantityRemaining &gt; 0.0">
                        <!-- always check ATP (we don't have a reservation) -->
                        <set field="quantityToIssue" from="asset.availableToPromiseTotal &gt; quantityRemaining ? quantityRemaining : asset.availableToPromiseTotal"/>
                        <if condition="quantityToIssue &lt;= 0.0"><continue/></if>

                        <!-- if not configured to allow also check QOH -->
                        <if condition="facility.assetAllowIssueOverQoh != 'Y'">
                            <!-- if no QOH skip this asset -->
                            <if condition="asset.quantityOnHandTotal &lt;= 0.0"><continue/></if>
                            <!-- otherwise just reduce to QOH -->
                            <if condition="quantityToIssue &gt; asset.quantityOnHandTotal">
                                <set field="quantityToIssue" from="asset.quantityOnHandTotal"/></if>
                        </if>

                        <set field="quantityRemaining" from="quantityRemaining - quantityToIssue"/>

                        <!-- see if there is another issuance we can add to -->
                        <entity-find entity-name="mantle.product.issuance.AssetIssuance" list="existingIssuanceList">
                            <econdition field-name="shipmentId"/>
                            <econdition field-name="assetId" from="asset.assetId"/>
                            <econdition field-name="shipmentItemSourceId" from="baseMap.shipmentItemSourceId" ignore-if-empty="true"/>
                            <econdition field-name="orderId" from="baseMap.orderId" ignore-if-empty="true"/>
                            <econdition field-name="orderItemSeqId" from="baseMap.orderItemSeqId" ignore-if-empty="true"/>
                            <econdition field-name="invoiceId" from="baseMap.invoiceId" ignore-if-empty="true"/>
                            <econdition field-name="invoiceItemSeqId" from="baseMap.invoiceItemSeqId" ignore-if-empty="true"/>
                        </entity-find>
                        <if condition="existingIssuanceList"><then>
                            <!-- add to existing issuance -->
                            <set field="existingIssuance" from="existingIssuanceList[0]"/>
                            <service-call name="update#mantle.product.issuance.AssetIssuance"
                                    in-map="[assetIssuanceId:existingIssuance.assetIssuanceId, quantity:(existingIssuance.quantity + quantityToIssue)]"/>
                            <service-call name="mantle.product.AssetServices.change#AssetQuantity" in-map="baseMap + [assetId:asset.assetId,
                                effectiveDate:issuedDate, quantityDiff:-quantityToIssue, assetIssuanceId:existingIssuance.assetIssuanceId]"/>
                        </then><else>
                            <!-- create an issuance -->
                            <service-call name="create#mantle.product.issuance.AssetIssuance" out-map="issueOut" in-map="baseMap +
                                [assetId:asset.assetId, issuedDate:issuedDate, issuedByUserId:ec.user.userId, quantity:quantityToIssue]"/>
                            <service-call name="mantle.product.AssetServices.change#AssetQuantity" in-map="baseMap + [assetId:asset.assetId,
                                effectiveDate:issuedDate, quantityDiff:-quantityToIssue, assetIssuanceId:issueOut.assetIssuanceId]"/>
                        </else></if>
                    </if>
                </iterate>
                <!-- not all issued? issue from last (most recent) Asset -->
                <if condition="quantityRemaining &gt; 0.0 &amp;&amp; lastAsset != null">
                    <!-- if not configured to allow stop now because we didn't find on hand inventory -->
                    <if condition="facility.assetAllowIssueOverQoh != 'Y'">
                        <log level="warn" message="Unable to issue ${quantityRemaining} of ${quantity}, insufficient inventory on hand for shipment ${shipmentId} order ${orderId} asset ${assetId} lastAsset ${lastAsset?.assetId} ${lastAsset?.availableToPromiseTotal}/${lastAsset?.quantityOnHandTotal} stack: ${ec.artifactExecution.getStackNameString()}"/>
                        <return error="true" message="Unable to issue ${quantityRemaining} out of quantity requested ${quantity}, insufficient inventory on hand for shipment ${shipmentId}"/>
                    </if>

                    <!-- see if there is another issuance we can add to -->
                    <entity-find entity-name="mantle.product.issuance.AssetIssuance" list="existingIssuanceList">
                        <econdition field-name="shipmentId"/>
                        <econdition field-name="assetId" from="lastAsset.assetId"/>
                        <econdition field-name="shipmentItemSourceId" from="baseMap.shipmentItemSourceId" ignore-if-empty="true"/>
                        <econdition field-name="orderId" from="baseMap.orderId" ignore-if-empty="true"/>
                        <econdition field-name="orderItemSeqId" from="baseMap.orderItemSeqId" ignore-if-empty="true"/>
                        <econdition field-name="invoiceId" from="baseMap.invoiceId" ignore-if-empty="true"/>
                        <econdition field-name="invoiceItemSeqId" from="baseMap.invoiceItemSeqId" ignore-if-empty="true"/>
                    </entity-find>
                    <if condition="existingIssuanceList"><then>
                        <!-- add to existing issuance -->
                        <set field="existingIssuance" from="existingIssuanceList[0]"/>
                        <service-call name="update#mantle.product.issuance.AssetIssuance"
                                in-map="[assetIssuanceId:existingIssuance.assetIssuanceId, quantity:(existingIssuance.quantity + quantityRemaining)]"/>
                        <service-call name="mantle.product.AssetServices.change#AssetQuantity" in-map="baseMap + [assetId:asset.assetId,
                                effectiveDate:issuedDate, quantityDiff:-quantityRemaining, assetIssuanceId:existingIssuance.assetIssuanceId]"/>
                    </then><else>
                        <!-- create an issuance -->
                        <service-call name="create#mantle.product.issuance.AssetIssuance" out-map="issueOut" in-map="baseMap +
                            [assetId:lastAsset.assetId, issuedDate:issuedDate, issuedByUserId:ec.user.userId, quantity:quantityRemaining]"/>
                        <service-call name="mantle.product.AssetServices.change#AssetQuantity" in-map="baseMap + [assetId:lastAsset.assetId,
                            effectiveDate:issuedDate, quantityDiff:-quantityRemaining, assetIssuanceId:issueOut.assetIssuanceId]"/>
                    </else></if>
                </if>
            </then><else>
                <!-- if not configured to allow stop now because we didn't find on hand inventory -->
                <if condition="facility.assetAllowIssueOverQoh != 'Y'">
                    <return error="true" message="No assets found to issue to shipment ${shipmentId} with product ${productId} facility ${facilityId} and owner ${ownerPartyId}"/>
                </if>

                <!-- no asset... create a shell one to record the issuance and detail against -->
                <service-call name="create#mantle.product.asset.Asset" out-map="context"
                        in-map="[assetTypeEnumId:'AstTpInventory', hasQuantity:'Y', statusId:'AstAvailable',
                            productId:productId, facilityId:productStore.inventoryFacilityId,
                            ownerPartyId:productStore?.organizationPartyId, receivedDate:ec.user.nowTimestamp,
                            availableToPromiseTotal:0, quantityOnHandTotal: 0]"/>
                <service-call name="create#mantle.product.issuance.AssetIssuance" out-map="issueOut"
                        in-map="baseMap + [assetId:assetId, issuedDate:issuedDate, issuedByUserId:ec.user.userId, quantity:quantity]"/>
                <!-- create AssetDetail to decrement QOH and ATP -->
                <service-call name="create#mantle.product.asset.AssetDetail" in-map="baseMap + [assetId:assetId,
                        effectiveDate:issuedDate, quantityOnHandDiff:-quantity,
                        availableToPromiseDiff:-quantity, assetIssuanceId:issueOut.assetIssuanceId]"/>
            </else></if>
        </actions>
    </service>

    <service verb="issue" noun="AssetToWorkEffort" no-tx-cache="true">
        <!-- NOTE: tested with transaction="cache" and works fine, but only a small performance improvement (this is a fairly small service) -->
        <description>Issue an Asset to a WorkEffort (production run, etc).</description>
        <in-parameters>
            <parameter name="assetId" required="true" default="defaultAssetId"/>
            <parameter name="asset" type="EntityValue"/>
            <parameter name="defaultAssetId"/>
            <parameter name="workEffortId" required="true"/>
            <parameter name="quantity" type="BigDecimal"><description>If not specified entire quantity of given Asset record will be used.</description></parameter>
            <parameter name="quantityUomId"><description>If not specified product Uom Id will be used.</description></parameter>
            <parameter name="issuedDate" type="Timestamp" default="ec.user.nowTimestamp"/>
            <parameter name="noConsumeProduct" default-value="error"><description>If the asset has a productId that is
                not one of the WorkEffort consume products, "add" it, "ignore" it, or return an "error"?</description></parameter>
            <parameter name="noOriginFacility" default-value="error"><description>If the asset has a originFacilityId that is
                not one of the WorkEffort origin facilities, "add" it, "ignore" it, or return an "error"?</description></parameter>
        </in-parameters>
        <actions>
            <if condition="asset == null">
                <entity-find-one entity-name="mantle.product.asset.Asset" value-field="asset" for-update="true">
                    <field-map field-name="assetId"/></entity-find-one>
            </if>
            <if condition="asset == null"><return error="true" message="Asset not found with ID ${assetId}"/></if>

            <if condition="quantity &amp;&amp; quantityUomId"><then>
                <service-call name="mantle.shipment.ShipmentServices.convert#ProductBoxQuantity" out-map="cvtQty"
                        in-map="[productId:asset.productId, originalQuantity:quantity, originalQuantityUomId:quantityUomId]"/>
                <set field="quantity" from="cvtQty.convertedQuantity"/>
            </then><else-if condition="!quantity">
                <set field="quantity" from="asset.availableToPromiseTotal"/>
            </else-if></if>

            <!-- reserve by availableToPromiseTotal (no reservation here, but respect others) -->
            <if condition="quantity &gt; asset.availableToPromiseTotal">
                <set field="uomDescription" from="asset?.product?.amountUom?' '+(ec.resource.expand('UomNameTemplate','',asset.product.amountUom)):''"/>
                <message error="true">Quantity specified (${ec.l10n.format(quantity, '#,##0.00')}${uomDescription}) is greater than the quantity available (${ec.l10n.format(asset.availableToPromiseTotal, '#,##0.00')}${uomDescription})</message>
            </if>

            <!-- if allow over QOH not allowed check now -->
            <entity-find-one entity-name="mantle.facility.Facility" value-field="facility" cache="true">
                <field-map field-name="facilityId" from="asset.facilityId"/></entity-find-one>
            <if condition="facility?.assetAllowIssueOverQoh != 'Y'">
                <if condition="quantity &gt; asset.quantityOnHandTotal">
                    <return error="true" message="For work effort ${workEffortId} tried to issue quantity ${quantity} which is greater than quantity on hand ${asset.quantityOnHandTotal} for asset ${asset.assetId}"/></if>
            </if>

            <!-- check consume product -->
            <entity-find entity-name="mantle.work.effort.WorkEffortProduct" list="consumeProductList">
                <econdition field-name="workEffortId"/><econdition field-name="productId" from="asset.productId"/>
                <econdition field-name="typeEnumId" value="WeptConsume"/>
            </entity-find>
            <if condition="!consumeProductList">
                <if condition="noConsumeProduct == 'add'"><then>
                    <service-call name="create#mantle.work.effort.WorkEffortProduct" in-map="[workEffortId:workEffortId,
                            productId:asset.productId, typeEnumId:'WeptConsume', estimatedQuantity:quantity]"/>
                </then><else-if condition="noConsumeProduct != 'ignore'">
                    <entity-find-one entity-name="mantle.product.Product" value-field="product">
                        <field-map field-name="productId" from="asset.productId"/></entity-find-one>
                    <message error="true">Not issuing Asset [${assetId}], Product ${ec.resource.expand('ProductNameTemplate','',product)} is not a product to consume</message>
                </else-if></if>
            </if>

            <!-- check origin facility -->
            <if condition="asset.originFacilityId">
                <entity-find entity-name="mantle.work.effort.WorkEffortFacility" list="originFacilityList">
                    <econdition field-name="workEffortId"/><econdition field-name="facilityId" from="asset.originFacilityId"/>
                    <econdition field-name="typeEnumId" value="WeftOrigin"/>
                </entity-find>
                <if condition="!originFacilityList">
                    <if condition="noOriginFacility == 'add'"><then>
                        <service-call name="create#mantle.work.effort.WorkEffortFacility" in-map="[workEffortId:workEffortId,
                            facilityId:asset.originFacilityId, typeEnumId:'WeftOrigin']"/>
                    </then><else-if condition="noOriginFacility != 'ignore'">
                        <entity-find-one entity-name="mantle.facility.Facility" value-field="facility">
                            <field-map field-name="facilityId" from="asset.originFacilityId"/></entity-find-one>
                        <message error="true">Not issuing Asset [${assetId}], Origin Facility ${ec.resource.expand('FacilityNameTemplate','',facility)} is not an origin facility</message>
                    </else-if></if>
                </if>
            </if>

            <check-errors/>

            <set field="baseMap" from="[workEffortId:workEffortId, assetId:asset.assetId, productId:asset.productId]"/>

            <!-- look for existing AssetIssuance to add to -->
            <entity-find entity-name="mantle.product.issuance.AssetIssuance" list="existingIssuanceList">
                <econdition field-name="assetId"/>
                <econdition field-name="workEffortId"/>
                <econdition field-name="shipmentId" ignore-if-empty="true"/>
                <econdition field-name="shipmentItemSourceId" ignore-if-empty="true"/>
                <econdition field-name="orderId" ignore-if-empty="true"/>
                <econdition field-name="orderItemSeqId" ignore-if-empty="true"/>
                <econdition field-name="invoiceId" ignore-if-empty="true"/>
                <econdition field-name="invoiceItemSeqId" ignore-if-empty="true"/>
            </entity-find>
            <if condition="existingIssuanceList"><then>
                <!-- add to existing issuance -->
                <set field="existingIssuance" from="existingIssuanceList[0]"/>
                <service-call name="update#mantle.product.issuance.AssetIssuance" in-map="baseMap +
                        [assetIssuanceId:existingIssuance.assetIssuanceId, quantity:(existingIssuance.quantity + quantity)]"/>
                <service-call name="mantle.product.AssetServices.change#AssetQuantity" in-map="baseMap +
                        [effectiveDate:issuedDate, quantityDiff:-quantity, assetIssuanceId:existingIssuance.assetIssuanceId]"/>
            </then><else>
                <!-- create an issuance -->
                <service-call name="create#mantle.product.issuance.AssetIssuance" out-map="issueOut"
                        in-map="baseMap + [issuedDate:issuedDate, issuedByUserId:ec.user.userId, quantity:quantity]"/>
                <service-call name="mantle.product.AssetServices.change#AssetQuantity" in-map="baseMap +
                        [effectiveDate:issuedDate, quantityDiff:-quantity, assetIssuanceId:issueOut.assetIssuanceId]"/>
            </else></if>
        </actions>
    </service>

    <service verb="issue" noun="AnyAssetToWorkEffort" no-tx-cache="true">
        <in-parameters>
            <parameter name="productId" required="true"/>
            <parameter name="facilityId" required="true"/>
            <parameter name="workEffortId" required="true"/>
            <parameter name="quantity" type="BigDecimal" required="true"/>
            <parameter name="issuedDate" type="Timestamp" default="ec.user.nowTimestamp"/>
        </in-parameters>
        <out-parameters><parameter name="assetIdList" type="List"><parameter name="assetId"/></parameter></out-parameters>
        <actions>
            <entity-find entity-name="mantle.product.asset.Asset" list="assetList">
                <econdition field-name="productId"/><econdition field-name="facilityId"/>
                <econdition field-name="availableToPromiseTotal" operator="greater" from="0"/>
                <econdition field-name="statusId" value="AstAvailable"/>
                <order-by field-name="receivedDate"/>
            </entity-find>
            <set field="assetIdList" from="[]"/>
            <set field="remainingQuantity" from="quantity"/>
            <iterate list="assetList" entry="asset">
                <set field="curQuantity" from="asset.availableToPromiseTotal &gt; remainingQuantity ? remainingQuantity : asset.availableToPromiseTotal"/>
                <if condition="curQuantity">
                    <service-call name="mantle.product.AssetServices.issue#AssetToWorkEffort"
                            in-map="[workEffortId:workEffortId, assetId:asset.assetId, issuedDate:issuedDate, quantity:curQuantity]"/>
                    <set field="remainingQuantity" from="remainingQuantity - curQuantity"/>
                    <if condition="remainingQuantity == 0"><break/></if>
                </if>
            </iterate>
            <if condition="remainingQuantity &gt; 0"><message>Could not find available inventory for ${remainingQuantity} out of ${quantity}</message></if>
        </actions>
    </service>
    <service verb="issue" noun="AnyAssetForShipmentItemSource" no-tx-cache="true">
        <description>Issue from available inventory only, if not able to issue all returns quantityRemaining</description>
        <in-parameters>
            <parameter name="shipmentItemSourceId" required="true"/>
            <parameter name="quantity" type="BigDecimal" required="true"/>
            <parameter name="issuedDate" type="Timestamp" default="ec.user.nowTimestamp"/>
            <parameter name="forceIssueOther" type="Boolean" default="false"/>

            <parameter name="workEffortId"/>
            <parameter name="workEffortOnly" type="Boolean" default="false">
                <description>Issue only to WorkEffort, not to Order, Shipment, or Invoice</description></parameter>
        </in-parameters>
        <out-parameters>
            <parameter name="quantityRemaining" type="BigDecimal"/>
        </out-parameters>
        <actions>
            <set field="quantityRemaining" from="quantity"/>

            <entity-find-one entity-name="mantle.shipment.ShipmentItemSource" value-field="shipmentItemSource"/>
            <if condition="shipmentItemSource == null"><return error="true" message="Could not find ShipmentItemSource with ID ${shipmentItemSourceId}"/></if>

            <set field="shipmentId" from="shipmentItemSource.shipmentId"/>
            <set field="shipment" from="shipmentItemSource.shipment"/>

            <entity-find entity-name="mantle.shipment.ShipmentRouteSegment" list="shipmentRouteSegmentList">
                <econdition field-name="shipmentId"/><order-by field-name="-shipmentRouteSegmentSeqId"/></entity-find>
            <set field="facilityId" from="shipmentRouteSegmentList?.first?.originFacilityId"/>
            <if condition="!facilityId">
                <return type="warning" message="No origin Facility found for Shipment ${shipmentId}, ShipmentItemSource ${shipmentItemSourceId}, not trying to issue other inventory"/></if>
            <entity-find-one entity-name="mantle.facility.Facility" value-field="facility" cache="true"/>

            <set field="productId" from="shipmentItemSource.productId"/>
            <set field="productStoreId" from="shipment.productStoreId"/>
            <set field="vendorPartyId" from="shipment.fromPartyId"/>
            <set field="customerPartyId" from="shipment.toPartyId"/>

            <if condition="productStoreId &amp;&amp; !vendorPartyId">
                <entity-find-one entity-name="mantle.product.store.ProductStore" value-field="productStore"/>
                <set field="vendorPartyId" from="productStore?.organizationPartyId"/>
            </if>

            <!-- compile set of ownerPartyId values -->
            <set field="ownerPartyIdSet" from="new HashSet()"/>
            <if condition="vendorPartyId">
                <script>ownerPartyIdSet.add(vendorPartyId)</script>
                <!-- look for parent org(s) if any, include assets from parent org too -->
                <entity-find entity-name="mantle.party.PartyRelationship" list="parentRelList" cache="true">
                    <date-filter/>
                    <econdition field-name="relationshipTypeEnumId" value="PrtOrgRollup"/>
                    <econdition field-name="fromPartyId" from="vendorPartyId"/>
                    <econdition field-name="toPartyId" operator="is-not-null"/>
                </entity-find>
                <script>if (parentRelList) ownerPartyIdSet.addAll(parentRelList*.toPartyId)</script>
            </if>

            <!-- compile set of assetPoolId values -->
            <service-call name="mantle.product.AssetServices.get#AssetPools" out-map="poolsOut"
                    in-map="[productStoreId:productStoreId, vendorPartyId:vendorPartyId, customerPartyId:customerPartyId]"/>
            <set field="assetPoolIdSet" from="poolsOut.assetPoolIdSet"/>

            <if condition="workEffortOnly"><then>
                <set field="baseMap" from="[workEffortId:workEffortId]"/>
            </then><else>
                <set field="baseMap" from="[shipmentId:shipmentId, shipmentItemSourceId:shipmentItemSourceId,
                        orderId:shipmentItemSource.orderId, orderItemSeqId:shipmentItemSource.orderItemSeqId,
                        invoiceId:shipmentItemSource.invoiceId, invoiceItemSeqId:shipmentItemSource.invoiceItemSeqId]"/>
            </else></if>

            <!-- start with available inventory -->
            <entity-find entity-name="mantle.product.asset.Asset" list="assetList">
                <econdition field-name="productId"/>
                <econdition field-name="facilityId"/>
                <econdition field-name="ownerPartyId" operator="in" from="ownerPartyIdSet"
                        ignore="facility?.assetAllowOtherOwner == 'Y' || !ownerPartyIdSet"/>
                <econdition field-name="assetPoolId" operator="in" from="assetPoolIdSet" ignore="!assetPoolIdSet" or-null="true"/>
                <econdition field-name="assetPoolId" operator="is-null" ignore="assetPoolIdSet"/>
                <econdition field-name="statusId" value="AstAvailable"/>
                <econdition field-name="availableToPromiseTotal" operator="greater" from="0.0"/>
                <order-by field-name="receivedDate,assetId"/>
            </entity-find>
            <iterate list="assetList" entry="asset">
                <set field="curQuantity" from="asset.availableToPromiseTotal &gt; quantityRemaining ? quantityRemaining : asset.availableToPromiseTotal"/>
                <if condition="curQuantity">
                    <service-call name="mantle.product.AssetServices.issue#Asset"
                            in-map="baseMap + [quantity:curQuantity, issuedDate:issuedDate, assetId:asset.assetId]"/>
                    <set field="quantityRemaining" from="quantityRemaining - curQuantity"/>
                    <if condition="quantityRemaining == 0.0"><break/></if>
                </if>
            </iterate>

            <!-- handle forceIssueOther -->
            <if condition="quantityRemaining &amp;&amp; forceIssueOther">
                <entity-find entity-name="mantle.product.asset.Asset" list="assetList">
                    <econdition field-name="productId"/>
                    <econdition field-name="facilityId"/>
                    <econdition field-name="ownerPartyId" operator="in" from="ownerPartyIdSet"
                            ignore="facility?.assetAllowOtherOwner == 'Y' || !ownerPartyIdSet"/>
                    <econdition field-name="assetPoolId" operator="in" from="assetPoolIdSet" ignore="!assetPoolIdSet" or-null="true"/>
                    <econdition field-name="assetPoolId" operator="is-null" ignore="assetPoolIdSet"/>
                    <econdition field-name="statusId" value="AstAvailable"/>
                    <econdition field-name="quantityOnHandTotal" operator="greater" from="0.0"/>
                    <order-by field-name="receivedDate,assetId"/>
                </entity-find>
                <iterate list="assetList" entry="asset">
                    <set field="curQuantity" from="asset.quantityOnHandTotal &gt; quantityRemaining ? quantityRemaining : asset.quantityOnHandTotal"/>
                    <if condition="curQuantity">
                        <!-- handle reservations, moving other reservations as needed to handle current quantity assumed to be physically present -->
                        <service-call name="mantle.product.AssetServices.displace#AssetReservations"
                                in-map="[assetId:asset.assetId, quantity:curQuantity]"/>

                        <service-call name="mantle.product.AssetServices.issue#Asset"
                                in-map="baseMap + [quantity:curQuantity, issuedDate:issuedDate, assetId:asset.assetId]"/>
                        <set field="quantityRemaining" from="quantityRemaining - curQuantity"/>
                        <if condition="quantityRemaining == 0.0"><break/></if>
                    </if>
                </iterate>

                <!-- if still quantityRemaining and Facility allows issue over QOH, issue to send negative and let ECA rule catch it and do auto physical inventory found -->
                <if condition="quantityRemaining &amp;&amp; facility?.assetAllowIssueOverQoh == 'Y'">
                    <!-- find most recent qualifying Asset, ignore ATP and QOH, use that if found (sending QOH negative) -->
                    <entity-find entity-name="mantle.product.asset.Asset" list="recentAssetList" limit="1">
                        <econdition field-name="productId"/>
                        <econdition field-name="facilityId"/>
                        <econdition field-name="ownerPartyId" operator="in" from="ownerPartyIdSet"
                                ignore="facility?.assetAllowOtherOwner == 'Y' || !ownerPartyIdSet"/>
                        <econdition field-name="assetPoolId" operator="in" from="assetPoolIdSet" ignore="!assetPoolIdSet" or-null="true"/>
                        <econdition field-name="assetPoolId" operator="is-null" ignore="assetPoolIdSet"/>
                        <econdition field-name="statusId" value="AstAvailable"/>
                        <order-by field-name="-receivedDate,-assetId"/>
                    </entity-find>
                    <if condition="recentAssetList"><then>
                        <service-call name="mantle.product.AssetServices.issue#Asset"
                                in-map="baseMap + [quantity:quantityRemaining, issuedDate:issuedDate, assetId:recentAssetList[0].assetId]"/>
                        <set field="quantityRemaining" from="0.0"/>
                    </then><else>
                        <!-- no asset... create a shell one to record the reservation and detail against -->
                        <service-call name="mantle.product.AssetServices.create#ProductAssetAdHoc" out-map="createAssetOut"
                                in-map="[productId:productId, facilityId:facilityId, ownerPartyId:vendorPartyId,
                                    createdDate:nowTimestamp]"/>
                        <service-call name="mantle.product.AssetServices.issue#Asset"
                                in-map="baseMap + [quantity:quantityRemaining, issuedDate:issuedDate, assetId:createAssetOut.assetId]"/>
                        <set field="quantityRemaining" from="0.0"/>
                    </else></if>
                </if>
            </if>
        </actions>
    </service>

    <service verb="move" noun="IssuancesToNewShipment">
        <description>Move AssetIssuance details to new records for another Shipment. Doesn't delete original record or
            receive assets back into inventory, just moves quantity to AssetIssuance.quantityCancelled and then creates
            a new record with the same assetId, etc for the new Shipment and corresponding Order.</description>
        <in-parameters>
            <parameter name="shipmentId" required="true"/>
            <parameter name="newOrderId" required="true"/>
            <parameter name="newShipmentId" required="true"/>
            <parameter name="issuedDate" type="Timestamp" default="ec.user.nowTimestamp"/>
        </in-parameters>
        <actions>
            <entity-find entity-name="mantle.product.issuance.AssetIssuance" list="issuanceList" for-update="true">
                <econdition field-name="shipmentId"/></entity-find>
            <entity-find entity-name="mantle.order.OrderItem" list="orderItemList">
                <econdition field-name="orderId" from="newOrderId"/></entity-find>
            <iterate list="issuanceList" entry="issuance">
                <!-- cancel original issuance quantity -->
                <service-call name="update#mantle.product.issuance.AssetIssuance"
                        in-map="[assetIssuanceId:issuance.assetIssuanceId, quantityCancelled:issuance.quantity, quantity:0]"/>
                <!-- create new issuance -->
                <filter-map-list list="orderItemList" to-list="prodOrderItemList">
                    <field-map field-name="productId" from="issuance.productId"/></filter-map-list>
                <if condition="!prodOrderItemList">
                    <return error="true" message="In move issuance to new shipment no Order Item found on order ${newOrderId} for product ${issuance.productId}"/></if>
                <service-call name="create#mantle.product.issuance.AssetIssuance"
                        in-map="[assetId:issuance.assetId, quantity:issuance.quantity, orderId:newOrderId,
                            orderItemSeqId:prodOrderItemList[0].orderItemSeqId, shipmentId:newShipmentId,
                            productId:issuance.productId, issuedDate:issuedDate, issuedByUserId:ec.user.userId]"/>

                <!-- TODO check GL inventory transactions on cancel, direct issuance create; need any since this is a direct replacement? -->
            </iterate>
        </actions>
    </service>

    <service verb="cancel" noun="AssetIssuance">
        <in-parameters>
            <parameter name="assetIssuanceId" required="true"/>
            <parameter name="quantityToCancel" type="BigDecimal"><description>Defaults to AssetIssuance.quantity</description></parameter>
            <parameter name="reserveAsset" type="Boolean" default="true"/>
            <parameter name="orderId"><description>For reservation after cancel issuance if AssetReservation no longer exists, defaults to AssetIssuance.orderId</description></parameter>
            <parameter name="orderItemSeqId"><description>For reservation after cancel issuance if AssetReservation no longer exists, defaults to AssetIssuance.orderItemSeqId</description></parameter>
        </in-parameters>
        <out-parameters><parameter name="assetReservationId"/></out-parameters>
        <actions>
            <entity-find-one entity-name="mantle.product.issuance.AssetIssuance" value-field="assetIssuance" for-update="true"/>
            <!-- lock the Asset record to prevent concurrent reservations, etc -->
            <entity-find-one entity-name="mantle.product.asset.Asset" value-field="asset" for-update="true">
                <field-map field-name="assetId" from="assetIssuance.assetId"/></entity-find-one>

            <if condition="quantityToCancel == null"><set field="quantityToCancel" from="assetIssuance.quantity"/></if>
            <if condition="!quantityToCancel"><return message="No quantity to cancel for issuance ${assetIssuanceId} of asset ${assetIssuance.assetId}"/></if>
            <if condition="quantityToCancel &gt; assetIssuance.quantity">
                <return error="true" message="Quantity to cancel ${quantityToCancel} is greater than quantity ${assetIssuance.quantity} for asset issuance ${assetIssuanceId}"/></if>

            <if condition="assetIssuance.invoiceId">
                <return error="true" message="Cannot cancel issuance ${assetIssuanceId}, already on invoice ${assetIssuance.invoiceId}"/></if>

            <set field="quantityCancelled" from="(assetIssuance.quantityCancelled ?: 0.0) + quantityToCancel"/>
            <set field="quantityRemaining" from="assetIssuance.quantity - quantityToCancel"/>
            <service-call name="update#mantle.product.issuance.AssetIssuance" in-map="[assetIssuanceId:assetIssuanceId,
                    quantity:quantityRemaining, quantityCancelled:quantityCancelled]"/>

            <!-- NOTE: used to look at "assetIssuance.issuedDate ?:" but better to stick with actual time for easier tracking and figuring out time lines -->
            <set field="cancelDate" from="ec.user.nowTimestamp"/>

            <if condition="assetIssuance.assetReservationId">
                <entity-find-one entity-name="mantle.product.issuance.AssetReservation" value-field="oldReservation">
                    <field-map field-name="assetReservationId" from="assetIssuance.assetReservationId"/></entity-find-one>
            </if>
            <!-- create AssetDetail to increment QOH and if there is no reservation also ATP -->
            <service-call name="create#mantle.product.asset.AssetDetail" in-map="[assetId:assetIssuance.assetId,
                        effectiveDate:cancelDate, quantityOnHandDiff:quantityToCancel,
                        availableToPromiseDiff:(oldReservation != null ? 0.0 : quantityToCancel),
                        productId:assetIssuance.productId, assetIssuanceId:assetIssuanceId,
                        shipmentId:assetIssuance.shipmentId, workEffortId:assetIssuance.workEffortId,
                        assetMaintenanceId:assetIssuance.assetMaintenanceId]"/>
            <if condition="oldReservation != null"><then>
                <!-- if issuance was from a reservation increase not issued quantity -->
                <set field="oldReservation.quantityNotIssued" from="(oldReservation.quantityNotIssued ?: 0.0) + quantityToCancel"/>
                <entity-update value-field="oldReservation"/>
            </then><else>
                <if condition="reserveAsset &amp;&amp; (orderId || assetIssuance.orderId)">
                    <!-- no reservation, try reserve for order item using this asset with freshly available inventory -->
                    <service-call name="mantle.product.AssetServices.reserve#AssetForOrderItem"
                            in-map="[orderId:(orderId ?: assetIssuance.orderId), orderItemSeqId:(orderItemSeqId ?: assetIssuance.orderItemSeqId),
                                assetId:assetIssuance.assetId]"/>
                </if>
            </else></if>

            <!-- if this is serialized inventory update status and set ownerPartyId back to prior values (assuming statusId and ownerPartyId are audit logged) -->
            <if condition="asset.serialNumber &amp;&amp; quantityToCancel == 1.0">
                <!-- NOTE: get most recent (-changedDate) audit log with an old value for ownerPartyId and statusId -->
                <set field="oldOwnerPartyId" from="asset.ownerPartyId"/>
                <entity-find entity-name="moqui.entity.EntityAuditLog" list="ownerAuditLogList" limit="1">
                    <econdition field-name="changedEntityName" value="mantle.product.asset.Asset"/>
                    <econdition field-name="changedFieldName" value="ownerPartyId"/>
                    <econdition field-name="pkPrimaryValue" from="asset.assetId"/>
                    <econdition field-name="newValueText" from="asset.ownerPartyId"/>
                    <econdition field-name="oldValueText" operator="is-not-null"/>
                    <order-by field-name="-changedDate"/>
                </entity-find>
                <if condition="ownerAuditLogList"><then>
                    <set field="oldOwnerPartyId" from="ownerAuditLogList[0].oldValueText"/>
                </then><else>
                    <message type="warning">No prior Owner Party for Asset ${asset.assetId} while canceling issuance ${assetIssuanceId}, leaving current owner</message>
                </else></if>

                <set field="oldStatusId" from="asset.statusId"/>
                <entity-find entity-name="moqui.entity.EntityAuditLog" list="statusAuditLogList" limit="1">
                    <econdition field-name="changedEntityName" value="mantle.product.asset.Asset"/>
                    <econdition field-name="changedFieldName" value="statusId"/>
                    <econdition field-name="pkPrimaryValue" from="asset.assetId"/>
                    <econdition field-name="newValueText" from="asset.statusId"/>
                    <econdition field-name="oldValueText" operator="is-not-null"/>
                    <order-by field-name="-changedDate"/>
                </entity-find>
                <if condition="statusAuditLogList"><then>
                    <set field="oldStatusId" from="statusAuditLogList[0].oldValueText"/>
                </then><else>
                    <message type="warning">No prior Status for Asset ${asset.assetId} while canceling issuance ${assetIssuanceId}, leaving current status</message>
                </else></if>

                <if condition="ownerAuditLogList || statusAuditLogList">
                    <service-call name="update#mantle.product.asset.Asset"
                            in-map="[assetId:asset.assetId, statusId:oldStatusId, ownerPartyId:oldOwnerPartyId]"/>
                </if>
            </if>
        </actions>
    </service>
    <service verb="update" noun="AssetIssuedDate">
        <in-parameters>
            <parameter name="assetIssuanceId" required="true"/>
            <parameter name="issuedDate" type="Timestamp" required="true"/>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="mantle.product.issuance.AssetIssuance" value-field="assetIssuance" for-update="true"/>
            <if condition="assetIssuance.issuedDate == issuedDate"><return/></if>
            <set field="assetIssuance.issuedDate" from="issuedDate"/>
            <entity-update value-field="assetIssuance"/>
            <!-- if issuedDate was changed then after updating the AssetIssuance record repost the GL TX -->
            <service-call name="mantle.ledger.AssetAutoPostServices.repost#AssetIssuance"
                    in-map="[assetIssuanceId:assetIssuance.assetIssuanceId]"/>
            <!-- AssetDetail.effectiveDate is based on issuedDate, so update those too -->
            <entity-find entity-name="mantle.product.asset.AssetDetail" list="assetDetailList" for-update="true">
                <econdition field-name="assetIssuanceId"/></entity-find>
            <iterate list="assetDetailList" entry="assetDetail">
                <set field="assetDetail.effectiveDate" from="issuedDate"/>
                <entity-update value-field="assetDetail"/>
            </iterate>
        </actions>
    </service>

    <!-- ====================================== -->
    <!-- ========== Receipt Services ========== -->
    <!-- ====================================== -->

    <service verb="receive" noun="Asset" no-tx-cache="true">
        <!-- NOTE: tested with transaction="cache" and works fine, but only a small performance improvement (this is a fairly small service) -->
        <description>Receive an Asset</description>
        <in-parameters>
            <parameter name="assetId"><description>If specified receives to that Asset (uncommon) otherwise creates a new one.</description></parameter>
            <auto-parameters entity-name="mantle.product.asset.Asset" include="nonpk"/>

            <parameter name="productId" required="true" default="defaultProductId"/>
            <parameter name="defaultProductId"><description>Field for special forms, if passed can be used as a default for the productId parameter.</description></parameter>
            <parameter name="quantity" type="BigDecimal" required="true"/>
            <parameter name="assetTypeEnumId"><description>Defaults to Product.assetTypeEnumId</description></parameter>
            <parameter name="classEnumId"><description>Defaults to Product.assetClassEnumId</description></parameter>
            <parameter name="statusId"><description>If assetTypeEnumId == AstTpInventory then defaults to AstAvailable,
                otherwise defaults to AstInStorage unless there is a FacilityLocationType.autoStatusId that applies and that will override this parameter.</description></parameter>
            <parameter name="receivedDate"><description>If statusId == AstIncoming then defaults to null, otherwise defaults to now.</description></parameter>

            <parameter name="assetName"><description>Defaults to OrderItem.itemDescription if available.</description></parameter>
            <parameter name="facilityId" required="true"/>
            <parameter name="ownerPartyId"><description>If not passed in and orderId and orderItemSeqId are then uses
                OrderPart.customerPartyId, otherwise uses Facility.ownerPartyId.</description></parameter>

            <parameter name="shipmentId"/>
            <parameter name="shipmentItemSourceId"/>
            <parameter name="shipmentPackageSeqId"/>
            <parameter name="orderId"/>
            <parameter name="orderItemSeqId"/>
            <parameter name="returnId"/>
            <parameter name="returnItemSeqId"/>
            <parameter name="workEffortId"/>
            <parameter name="noProduceProduct" default-value="add"><description>If the asset has a productId that is
                not one of the WorkEffort produce products, "add" it, "ignore" it, or return an "error"?</description></parameter>

            <!-- Container fields -->
            <parameter name="containerId"><description>Put the new Asset in this Container, set its Facility and Location if not set.</description></parameter>
            <parameter name="containerTypeEnumId"><description>If specified and there is no containerId create a
                Container of this type (with Facility and Location) and put Asset in it (set Asset.containerId).</description></parameter>
            <parameter name="containerSerialNumber"><description>Lookup Container with this ID as an alternative to the
                containerId (if not specified), if none found create a Container with this serialNumber.</description></parameter>
            <!-- AssetReceipt fields -->
            <parameter name="quantityRejected" type="BigDecimal"/>
            <parameter name="rejectionReasonEnumId"/>
            <!-- Lot fields (note that both Asset and Lot have manufacturedDate; Asset.expectedEndOfLife is equivalent to Lot.expirationDate) -->
            <parameter name="lotNumber"><description>If specified and no there is no lotId create a Lot with this number and the
                expirationDate and mfgPartyId parameters.</description></parameter>
            <parameter name="expirationDate" type="Date"><description>Used when creating a lot, defaults to expectedEndOfLife.
                If this is specified and no expectedEndOfLife is then set expectedEndOfLife to this (regardless of whether Lot is created).</description></parameter>
            <parameter name="mfgPartyId"/>
        </in-parameters>
        <out-parameters>
            <parameter name="assetId"/>
            <parameter name="assetReceiptId"/>
            <parameter name="assetDetailId"/>
        </out-parameters>
        <actions>
            <if condition="quantity == 0.0"><return type="warning" message="Not receiving zero quantity for Product ${productId}"/></if>

            <entity-find-one entity-name="mantle.product.Product" value-field="product"><field-map field-name="productId"/></entity-find-one>
            <entity-find-one entity-name="mantle.order.OrderHeader" value-field="orderHeader"><field-map field-name="orderId"/></entity-find-one>
            <entity-find-one entity-name="mantle.order.OrderItem" value-field="orderItem">
                <field-map field-name="orderId"/><field-map field-name="orderItemSeqId"/></entity-find-one>
            <entity-find-one entity-name="mantle.work.effort.WorkEffort" value-field="workEffort"><field-map field-name="workEffortId"/></entity-find-one>
            <entity-find-one entity-name="mantle.facility.Facility" value-field="facility"><field-map field-name="facilityId"/></entity-find-one>

            <!-- set type and class from product if not passed in -->
            <set field="assetTypeEnumId" from="assetTypeEnumId ?: (product.assetTypeEnumId ?: 'AstTpInventory')"/>
            <set field="classEnumId" from="classEnumId ?: product.assetClassEnumId"/>

            <!-- get ownerPartyId from OrderPart.customerPartyId if needed (who bought it) -->
            <if condition="!ownerPartyId &amp;&amp; orderItem">
                <set field="orderPart" from="orderItem?.'mantle.order.OrderPart'"/>
                <set field="ownerPartyId" from="orderPart?.customerPartyId"/>
            </if>
            <!-- get ownerPartyId from WorkEffort if needed (who made it within the system on a production run WorkEffort) -->
            <if condition="!ownerPartyId"><set field="ownerPartyId" from="workEffort?.ownerPartyId"/></if>
            <!-- get ownerPartyId from Facility if needed (final default, who owns the facility it's going into) -->
            <if condition="!ownerPartyId"><set field="ownerPartyId" from="facility?.ownerPartyId"/></if>

            <if condition="locationSeqId"><then>
                <!-- make sure location exists -->
                <entity-find-one entity-name="mantle.facility.FacilityLocation" value-field="checkFacLoc">
                    <field-map field-name="facilityId"/><field-map field-name="locationSeqId"/></entity-find-one>
                <if condition="checkFacLoc == null"><return error="true" message="Location [${locationSeqId}] is not valid in facility ${ec.resource.expand('FacilityNameTemplate', '', asset.facility)}"/></if>

                <!-- see if the target location's type has an autoStatusId in the Facility -->
                <if condition="checkFacLoc.locationTypeEnumId">
                    <entity-find-one entity-name="mantle.facility.FacilityLocationType" value-field="facLocType">
                        <field-map field-name="facilityId"/>
                        <field-map field-name="locationTypeEnumId" from="checkFacLoc.locationTypeEnumId"/>
                    </entity-find-one>
                    <set field="autoStatusId" from="facLocType?.autoStatusId"/>
                    <if condition="autoStatusId"><set field="statusId" from="autoStatusId"/></if>
                </if>
            </then><else>
                <if condition="facility?.assetInventoryLocRequire == 'Y' &amp;&amp; assetTypeEnumId == 'AstTpInventory'">
                    <return error="true" message="No location specified, Facility ${facilityId} requires a location for inventory"/></if>
            </else></if>

            <!-- set default status, receivedDate, hasQuantity, and assetName -->
            <if condition="!statusId"><set field="statusId" from="assetTypeEnumId == 'AstTpInventory' ? 'AstAvailable' : 'AstInStorage'"/></if>
            <if condition="!receivedDate &amp;&amp; statusId != 'AstIncoming'"><set field="receivedDate" from="ec.user.nowTimestamp"/></if>
            <set field="hasQuantity" from="!serialNumber &amp;&amp; quantity > 1 ? 'Y' : 'N'"/>
            <set field="assetName" from="assetName ?: orderItem?.itemDescription"/>

            <if condition="expectedEndOfLife == null"><set field="expectedEndOfLife" from="expirationDate"/></if>

            <!-- create a Lot if needed -->
            <if condition="lotId"><then>
                <entity-find-one entity-name="mantle.product.asset.Lot" value-field="lot"><field-map field-name="lotId"/></entity-find-one>
                <if condition="manufacturedDate == null"><set field="manufacturedDate" from="lot.manufacturedDate"/></if>
                <if condition="expectedEndOfLife == null"><set field="expectedEndOfLife" from="lot.expirationDate"/></if>
            </then><else-if condition="lotNumber">
                <entity-find entity-name="mantle.product.asset.Lot" list="existingLots">
                    <econdition field-name="lotNumber"/><econdition field-name="mfgPartyId"/></entity-find>
                <if condition="existingLots"><then>
                    <set field="lotId" from="existingLots[0].lotId"/>
                    <if condition="expectedEndOfLife == null"><set field="expectedEndOfLife" from="existingLots[0].expirationDate"/></if>
                </then><else>
                    <if condition="!mfgPartyId &amp;&amp; shipmentId">
                        <entity-find-one entity-name="mantle.shipment.Shipment" value-field="shipment"/>
                        <set field="mfgPartyId" from="shipment.fromPartyId"/>
                    </if>
                    <if condition="expirationDate == null"><set field="expirationDate" from="expectedEndOfLife"/></if>
                    <service-call name="create#mantle.product.asset.Lot" out-map="context"
                            in-map="[lotNumber:lotNumber, mfgPartyId:mfgPartyId, manufacturedDate:manufacturedDate, expirationDate:expirationDate]"/>
                </else></if>
            </else-if></if>

            <!-- create a Container if needed -->
            <if condition="!containerId &amp;&amp; (containerTypeEnumId || containerSerialNumber)">
                <!-- will put containerId for the new record in the context -->
                <service-call name="create#mantle.product.asset.Container" out-map="context"
                        in-map="[containerTypeEnumId:containerTypeEnumId, serialNumber:containerSerialNumber,
                            facilityId:facilityId, locationSeqId:locationSeqId, geoPointId:geoPointId]"/>
            </if>

            <!-- have originalQuantity default to quantity received -->
            <set field="originalQuantity" from="originalQuantity ?: quantity"/>

            <!-- create or update the Asset record -->
            <if condition="!assetId"><then>
                <!-- TODO: if this has a workEffortId and not an orderId get acquireCost from WorkEffort based on cost? -->
                <service-call name="create#mantle.product.asset.Asset" out-map="context"
                        in-map="context + [quantityOnHandTotal:0, availableToPromiseTotal:0,
                            acquiredDate:(orderHeader?.placedDate ?: ec.user.nowTimestamp),
                            acquireOrderId:orderId, acquireOrderItemSeqId:orderItemSeqId,
                            acquireShipmentId:shipmentId, acquireCost:(acquireCost ?: orderItem?.standardCost ?: orderItem?.unitAmount),
                            acquireCostUomId:orderHeader?.currencyUomId, acquireWorkEffortId:workEffortId]"/>
            </then><else>
                <entity-find-one entity-name="mantle.product.asset.Asset" value-field="asset"/>
                <set field="asset.originalQuantity" from="(asset.originalQuantity ?: 0) + originalQuantity"/>
                <set field="asset.containerId" from="asset.containerId ?: containerId"/>
                <set field="asset.assetPoolId" from="asset.assetPoolId ?: assetPoolId"/>
                <set field="asset.geoPointId" from="asset.geoPointId ?: geoPointId"/>
                <set field="asset.acquireWorkEffortId" from="asset.acquireWorkEffortId ?: workEffortId"/>
                <set field="asset.acquireOrderId" from="asset.acquireOrderId ?: orderId"/>
                <set field="asset.acquireOrderItemSeqId" from="asset.acquireOrderItemSeqId ?: orderItemSeqId"/>
                <set field="asset.acquireShipmentId" from="asset.acquireShipmentId ?: shipmentId"/>
                <set field="asset.acquireCost" from="asset.acquireCost ?: orderItem?.standardCost ?: orderItem?.unitAmount"/>
                <set field="asset.acquireCostUomId" from="asset.acquireCostUomId ?: orderHeader?.currencyUomId"/>
                <entity-update value-field="asset"/>
            </else></if>

            <!-- create AssetReceipt -->
            <service-call name="create#mantle.product.receipt.AssetReceipt" out-map="context"
                    in-map="[assetId:assetId, productId:productId, orderId:orderId, orderItemSeqId:orderItemSeqId,
                        returnId:returnId, returnItemSeqId:returnItemSeqId, workEffortId:workEffortId,
                        shipmentId:shipmentId, shipmentItemSourceId:shipmentItemSourceId,
                        shipmentPackageSeqId:shipmentPackageSeqId, receivedByUserId:ec.user.userId,
                        receivedDate:receivedDate, quantityAccepted:quantity, quantityRejected:quantityRejected,
                        rejectionReasonEnumId:rejectionReasonEnumId]"/>

            <!-- if there are OrderItemBilling records matching orderId, orderItemSeqId, and shipmentId set assetReceiptId -->
            <if condition="orderId &amp;&amp; orderItemSeqId &amp;&amp; shipmentId">
                <entity-find entity-name="mantle.order.OrderItemBilling" list="orderItemBillingList">
                    <econdition field-name="orderId"/><econdition field-name="orderItemSeqId"/>
                    <econdition field-name="shipmentId"/><econdition field-name="assetReceiptId" from="null"/>
                </entity-find>
                <iterate list="orderItemBillingList" entry="orderItemBilling">
                    <set field="orderItemBilling.assetReceiptId" from="assetReceiptId"/>
                    <entity-update value-field="orderItemBilling"/>
                </iterate>
            </if>

            <!-- create AssetDetail -->
            <!-- don't do this, better to make always available given how ATP is used for issuance/etc: <set field="availableToPromiseDiff" from="statusId == 'AstAvailable' ? quantity : 0"/> -->
            <set field="availableToPromiseDiff" from="quantity"/>
            <service-call name="create#mantle.product.asset.AssetDetail" out-map="context"
                    in-map="[assetId:assetId, effectiveDate:(receivedDate ?: ec.user.nowTimestamp), quantityOnHandDiff:quantity,
                        availableToPromiseDiff:availableToPromiseDiff, unitCost:orderItem?.unitAmount,
                        shipmentId:shipmentId, productId:productId, returnId:returnId, returnItemSeqId:returnItemSeqId,
                        workEffortId:workEffortId, assetReceiptId:assetReceiptId]"/>

            <!-- if this is for a WorkEffort (production run, etc)  -->
            <if condition="workEffortId">
                <entity-find entity-name="mantle.work.effort.WorkEffortProduct" list="produceProductList">
                    <date-filter/>
                    <econdition field-name="workEffortId"/><econdition field-name="productId"/>
                    <econdition field-name="typeEnumId" value="WeptProduce"/>
                </entity-find>
                <if condition="!produceProductList">
                    <if condition="noProduceProduct == 'error'"><then>
                        <message error="true">Not issuing Asset [${assetId}], Product ${ec.resource.expand('ProductNameTemplate','',product)} is not a product to produce</message>
                    </then><else-if condition="noProduceProduct != 'ignore'">
                        <service-call name="create#mantle.work.effort.WorkEffortProduct" in-map="[workEffortId:workEffortId,
                            productId:productId, typeEnumId:'WeptProduce', estimatedQuantity:quantity]"/>
                    </else-if></if>
                </if>
            </if>

            <!-- call through AssetDetail create? NO, would get called from the move#AssetReservation record recursively -->
            <!-- reserve the newly available Asset, if needed -->
            <service-call name="mantle.product.AssetServices.reserve#IncreasedAsset" in-map="[assetId:assetId]"/>
        </actions>
    </service>

    <service verb="update" noun="AssetAndReceipt" no-tx-cache="true">
        <in-parameters>
            <parameter name="assetId" required="true"/>
            <parameter name="assetReceiptId"><description>If not specified will look it up with assetId and shipmentId.</description></parameter>
            <parameter name="shipmentId"/>
            <parameter name="workEffortId"/>
            <auto-parameters entity-name="mantle.product.receipt.AssetReceipt" include="nonpk"/>
            <auto-parameters entity-name="mantle.product.asset.AssetDetail" include="nonpk">
                <exclude field-name="availableToPromiseDiff"/>
                <exclude field-name="quantityOnHandDiff"/>
            </auto-parameters>
            <auto-parameters entity-name="mantle.product.asset.Asset" include="nonpk">
                <exclude field-name="availableToPromiseTotal"/>
                <exclude field-name="quantityOnHandTotal"/>
            </auto-parameters>
            <parameter name="receivedDate"><description>If statusId == AstIncoming then no default, otherwise defaults to now.</description></parameter>
            <!-- Lot fields (note that both Asset and Lot have manufacturedDate; Asset.expectedEndOfLife is equivalent to Lot.expirationDate) -->
            <parameter name="lotNumber"><description>If specified and no there is no lotId create a Lot with this number and the
                expirationDate and mfgPartyId parameters.</description></parameter>
            <parameter name="expirationDate" type="Date"><description>Used when creating a lot, defaults to expectedEndOfLife.
                If this is specified and no expectedEndOfLife is then set expectedEndOfLife to this (regardless of whether Lot is created).</description></parameter>
            <parameter name="mfgPartyId"/>
        </in-parameters>
        <out-parameters><parameter name="assetDetailId"/></out-parameters>
        <actions>
            <if condition="quantityAccepted &lt; 0.0"><return error="true" message="Quantity Accepted may not be negative"/></if>
            <if condition="quantityRejected != null &amp;&amp; quantityRejected &lt; 0.0"><return error="true" message="Quantity Rejected may not be negative"/></if>

            <entity-find-one entity-name="mantle.product.asset.Asset" value-field="asset"/>
            <set field="oldStatusId" from="asset.statusId"/>
            <set field="oldAtp" from="asset.availableToPromiseTotal"/>
            <set field="oldQoh" from="asset.quantityOnHandTotal"/>
            <set field="oldAcquireCost" from="asset.acquireCost"/>
            <set field="oldReceivedDate" from="asset.receivedDate"/>

            <!-- update the AssetReceipt -->
            <if condition="!assetReceiptId &amp;&amp; shipmentId"><then>
                <entity-find entity-name="mantle.product.receipt.AssetReceipt" list="assetReceiptList">
                    <econdition field-name="assetId"/><econdition field-name="shipmentId"/>
                    <order-by field-name="assetReceiptId"/>
                </entity-find>
                <set field="originalAssetReceipt" from="assetReceiptList?.first"/>
                <set field="assetReceiptId" from="originalAssetReceipt?.assetReceiptId"/>
            </then><else>
                <entity-find-one entity-name="mantle.product.receipt.AssetReceipt" value-field="originalAssetReceipt"/>
            </else></if>
            <if condition="!assetReceiptId"><return error="true" message="Cannot update Asset and Receipt, could not find AssetReceipt record for assetId [${assetId}], shipmentId [${shipmentId}]"/></if>

            <!-- calculate the quantityAccepted difference, will be set in quantityOnHandDiff and availableToPromiseDiff -->
            <set field="quantityDiff" from="(quantityAccepted != null ? quantityAccepted : (originalAssetReceipt.quantityAccepted ?: 0.0)) - (originalAssetReceipt.quantityAccepted ?: 0.0)"/>
            <set field="quantityRejectedDiff" from="(quantityRejected != null ? quantityRejected : (originalAssetReceipt.quantityRejected ?: 0.0)) - (originalAssetReceipt.quantityRejected ?: 0.0)"/>

            <!-- <log level="warn" message="======= quantityAccepted ${quantityAccepted}, quantityRejected ${quantityRejected}, quantityDiff ${quantityDiff}, originalAssetReceipt: ${originalAssetReceipt}"/> -->

            <!-- Ensure the ShipmentItem has sufficient remaining quantity -->
            <set field="newQuantityRemaining" from="(quantityDiff ?: 0) + (quantityRejectedDiff ?: 0)"/>
            <if condition="newQuantityRemaining &amp;&amp; shipmentId">
                <service-call name="mantle.shipment.ShipmentServices.ensure#ShipmentItemQuantityRemaining"
                        in-map="[shipmentId:shipmentId, productId:asset.productId, newQuantityRemaining:newQuantityRemaining]"/>
            </if>

            <if condition="expectedEndOfLife == null"><set field="expectedEndOfLife" from="expirationDate"/></if>

            <!-- create a Lot if needed -->
            <if condition="lotId"><then>
                <entity-find-one entity-name="mantle.product.asset.Lot" value-field="lot"><field-map field-name="lotId"/></entity-find-one>
                <if condition="manufacturedDate == null"><set field="manufacturedDate" from="lot.manufacturedDate"/></if>
                <if condition="expectedEndOfLife == null"><set field="expectedEndOfLife" from="lot.expirationDate"/></if>
            </then><else-if condition="lotNumber">
                <entity-find entity-name="mantle.product.asset.Lot" list="existingLots">
                    <econdition field-name="lotNumber"/><econdition field-name="mfgPartyId"/></entity-find>
                <if condition="existingLots"><then>
                    <set field="lotId" from="existingLots[0].lotId"/>
                    <if condition="expectedEndOfLife == null"><set field="expectedEndOfLife" from="existingLots[0].expirationDate"/></if>
                </then><else>
                    <if condition="!mfgPartyId &amp;&amp; shipmentId">
                        <entity-find-one entity-name="mantle.shipment.Shipment" value-field="shipment"/>
                        <set field="mfgPartyId" from="shipment.fromPartyId"/>
                    </if>
                    <if condition="expirationDate == null"><set field="expirationDate" from="expectedEndOfLife"/></if>
                    <service-call name="create#mantle.product.asset.Lot" out-map="context"
                            in-map="[lotNumber:lotNumber, mfgPartyId:mfgPartyId, manufacturedDate:manufacturedDate, expirationDate:expirationDate]"/>
                </else></if>
            </else-if></if>

            <if condition="!receivedDate &amp;&amp; statusId &amp;&amp; statusId != 'AstIncoming'">
                <set field="receivedDate" from="ec.user.nowTimestamp"/></if>

            <!-- update AssetReceipt -->
            <service-call name="update#mantle.product.receipt.AssetReceipt" in-map="context" out-map="context"/>

            <!-- update ShipmentItemSource -->
            <entity-find-one entity-name="mantle.shipment.ShipmentItemSource" value-field="shipmentItemSource" for-update="true">
                <field-map field-name="shipmentItemSourceId" from="originalAssetReceipt.shipmentItemSourceId"/></entity-find-one>
            <if condition="shipmentItemSource != null">
                <set field="shipmentItemSource.quantityNotHandled" from="shipmentItemSource.quantityNotHandled - quantityDiff - quantityRejectedDiff"/>
                <if condition="shipmentItemSource.quantityNotHandled &amp;&amp; shipmentItemSource.statusId == 'SisReceived'">
                    <set field="shipmentItemSource.statusId" value="SisPending"/></if>
                <if condition="!shipmentItemSource.quantityNotHandled &amp;&amp; shipmentItemSource.statusId == 'SisPending'">
                    <set field="shipmentItemSource.statusId" value="SisReceived"/></if>
                <entity-update value-field="shipmentItemSource"/>
            </if>

            <!-- update the Asset record -->
            <service-call name="update#mantle.product.asset.Asset" in-map="context" out-map="context"/>

            <!-- before adjusting new quantity see if we just changed status to Available and if so set ATP to QOH -->
            <if condition="oldAtp &lt;= 0 &amp;&amp; statusId == 'AstAvailable' &amp;&amp; oldStatusId != 'AstAvailable'">
                <service-call name="create#mantle.product.asset.AssetDetail" out-map="context"
                        in-map="[assetId:assetId, effectiveDate:receivedDate, quantityOnHandDiff:0,
                            availableToPromiseDiff:oldQoh, shipmentId:shipmentId, productId:asset.productId,
                            assetReceiptId:assetReceiptId]"/>

                <!-- reserve the newly available Asset, if needed -->
                <service-call name="mantle.product.AssetServices.reserve#IncreasedAsset" in-map="[assetId:assetId]"/>
            </if>

            <if condition="quantityDiff != 0"><service-call name="mantle.product.AssetServices.change#AssetQuantity" in-map="context"/></if>

            <!-- if acquireCost is updated adjust the GL, if set from null do GL posting -->
            <!-- if quantityAccepted is updated and GL entry exists adjust the GL! -->
            <if condition="(acquireCost != null &amp;&amp; acquireCost != oldAcquireCost) ||
                    (quantityAccepted != null &amp;&amp; quantityAccepted != originalAssetReceipt.quantityAccepted) ||
                    (receivedDate != null &amp;&amp; oldReceivedDate != receivedDate)">
                <service-call name="mantle.ledger.AssetAutoPostServices.repost#Asset" in-map="[assetId:assetId]"/>
            </if>
        </actions>
    </service>

    <!-- ==================================== -->
    <!-- ========== Other Services ========== -->
    <!-- ==================================== -->

    <service verb="replace" noun="AssetPartyAssignment">
        <in-parameters>
            <parameter name="assetId" required="true"/>
            <parameter name="roleTypeId" required="true"/>
            <parameter name="newPartyId" required="true"/>
        </in-parameters>
        <actions>
            <entity-find entity-name="mantle.product.asset.AssetPartyAssignment" list="apaList">
                <date-filter/><econdition field-name="assetId"/><econdition field-name="roleTypeId"/></entity-find>
            <set field="foundExisting" from="false"/>
            <iterate list="apaList" entry="apaValue">
                <if condition="apaValue.partyId != newPartyId"><then>
                    <set field="apaValue.thruDate" from="ec.user.nowTimestamp"/>
                    <entity-update value-field="apaValue"/>
                </then><else>
                    <set field="foundExisting" from="true"/>
                </else></if>
            </iterate>
            <if condition="!foundExisting">
                <service-call name="create#mantle.product.asset.AssetPartyAssignment" in-map="[assetId:assetId,
                    partyId:newPartyId, roleTypeId:roleTypeId, fromDate:ec.user.nowTimestamp]"/>
            </if>
        </actions>
    </service>
    <service verb="move" noun="Product">
        <in-parameters>
            <parameter name="productId"><description>If not specified and there is more than one product in location/container will do nothing and return with a message</description></parameter>
            <parameter name="quantity" type="BigDecimal" required="true"/>
            <parameter name="facilityId" required="true"/>
            <parameter name="assetPoolId"/>
            <parameter name="locationSeqId"><description>Specify either location or container, if neither specified will look for assets with no location</description></parameter>
            <parameter name="containerId"><description>May be actual containerId or serialNumber</description></parameter>
            <parameter name="lotId"/>
            <parameter name="toAssetPoolId"/>
            <parameter name="toLocationSeqId"/>
            <parameter name="toContainerId"><description>May be actual containerId or serialNumber</description></parameter>
            <parameter name="toScanLocation"><description>May be locationSeqId within facility, containerId, or container serialNumber</description></parameter>
            <parameter name="createContainerId"/>
            <parameter name="containerTypeEnumId" default-value="CtBinShelf"/>
        </in-parameters>
        <out-parameters>
            <parameter name="assetIdList" type="List"><parameter name="assetId"/></parameter>
        </out-parameters>
        <actions>
            <if condition="toScanLocation">
                <service-call name="mantle.product.AssetServices.check#ScanLocation" out-map="toScanOut"
                        in-map="[facilityId:facilityId, locationSeqId:toLocationSeqId, containerId:toContainerId, scanLocation:toScanLocation]"/>
                <set field="toLocationSeqId" from="toLocationSeqId ?: toScanOut.locationSeqId"/>
                <set field="toContainerId" from="toContainerId ?: toScanOut.containerId"/>
            </if>

            <if condition="!locationSeqId &amp;&amp; !containerId">
                <message>No location or container specified, moving only assets with no location</message></if>
            <if condition="!toLocationSeqId &amp;&amp; !toContainerId">
                <return type="warning" message="Not moving, no valid location or container found to move to"/></if>

            <if condition="createContainerId">
                <if condition="toContainerId"><return type="warning" message="Create Container ID and to Container ID both specified, not creating container or moving assets"/></if>
                <if condition="!toLocationSeqId">
                    <if condition="toScanLocation"><then>
                        <return type="warning" message="Create Container ID specified but scanned location ${toScanLocation} not a known location"/>
                    </then><else>
                        <return type="warning" message="Create Container ID specified but no location specified, must specify location to create a container and move to"/>
                    </else></if>
                </if>

                <service-call name="create#mantle.product.asset.Container" out-map="createContOut"
                        in-map="[serialNumber:createContainerId, containerTypeEnumId:containerTypeEnumId, facilityId:facilityId, locationSeqId:toLocationSeqId]"/>
                <set field="toContainerId" from="createContOut.containerId"/>
                <message type="success">Created container with serial number ${createContainerId} (internal ID ${toContainerId})</message>
            </if>

            <if condition="containerId">
                <if condition="container == null">
                    <entity-find-one entity-name="mantle.product.asset.Container" value-field="container"/></if>
                <if condition="container == null">
                    <entity-find-one entity-name="mantle.product.asset.Container" value-field="container">
                        <field-map field-name="serialNumber" from="containerId"/></entity-find-one>
                    <if condition="container == null"><return error="true" message="Container not found with ID or serial number ${containerId}"/></if>
                    <set field="containerId" from="container.containerId"/>
                </if>
                <set field="facilityId" from="container.facilityId"/>
                <set field="locationSeqId" from="container.locationSeqId"/>
            </if>
            <if condition="locationSeqId">
                <entity-find-one entity-name="mantle.facility.FacilityLocation" value-field="checkFacLoc">
                    <field-map field-name="facilityId"/><field-map field-name="locationSeqId"/></entity-find-one>
                <if condition="checkFacLoc == null"><return error="true" message="Location [${locationSeqId}] is not valid in facility ${ec.resource.expand('FacilityNameTemplate', '', asset.facility)}"/></if>
            </if>

            <if condition="!locationSeqId"><set field="locationSeqId" from="null"/></if>
            <entity-find entity-name="mantle.product.asset.Asset" list="assetList">
                <econdition field-name="productId" ignore-if-empty="true"/>
                <econdition field-name="facilityId"/>
                <econdition field-name="assetPoolId" ignore="!assetPoolId"/>
                <econdition field-name="assetPoolId" ignore="assetPoolId" operator="is-null"/>
                <econdition field-name="locationSeqId"/><!-- no ignore-if-empty, if null only get assets with no location -->
                <econdition field-name="containerId" ignore-if-empty="true"/>
                <econdition field-name="lotId" ignore-if-empty="true"/>
                <econdition field-name="quantityOnHandTotal" operator="greater" from="0.0"/>
                <order-by field-name="receivedDate"/><!-- oldest first -->
                <order-by field-name="-quantityOnHandTotal"/><!-- then by most QOH (should be rare in real world, useful mostly for consistency in tests) -->
                <order-by field-name="-assetId"/><!-- by ID to make sure we have a consistent order for locking -->
            </entity-find>
            <!-- <log level="warn" message="assetList find ${assetList_xafind}"/><log level="warn" message="assetList ${assetList}"/> -->
            <if condition="assetList.size() == 0"><return type="warning" message="No assets found for given parameters"/></if>
            <set field="productIdSet" from="new HashSet(assetList*.productId)"/>
            <if condition="productIdSet.size() &gt; 1"><return type="warning" message="No product specified and found more than one in the location, not moving"/></if>

            <set field="quantityRemaining" from="quantity"/>
            <set field="assetIdList" from="[]"/>
            <iterate list="assetList" entry="asset">
                <set field="curQuantity" from="quantityRemaining &gt; asset.quantityOnHandTotal ? asset.quantityOnHandTotal : quantityRemaining"/>
                <!-- <log level="warn" message="quantity ${quantity} quantityRemaining ${quantityRemaining} curQuantity ${curQuantity}"/> -->
                <if condition="curQuantity != 0.0">
                    <service-call name="mantle.product.AssetServices.move#Asset"
                            in-map="[assetId:asset.assetId, facilityId:facilityId, quantity:curQuantity,
                                locationSeqId:toLocationSeqId, containerId:toContainerId, assetPoolId:toAssetPoolId]"/>
                    <set field="quantityRemaining" from="quantityRemaining - curQuantity"/>
                    <script>assetIdList.add(asset.assetId)</script>
                </if>
                <if condition="quantityRemaining == 0.0"><break/></if>
            </iterate>
        </actions>
    </service>
    <service verb="moveVerify" noun="Product">
        <implements service="mantle.product.AssetServices.move#Product"/>
        <in-parameters>
            <parameter name="verifyLocationSeqId"/><!-- not required otherwise cannot support move from no location -->
            <parameter name="toScanLocation" required="true"/>
        </in-parameters>
        <actions>
            <if condition="verifyLocationSeqId?.trim() != locationSeqId">
                <return type="danger" message="Verify Location did not match move From Location"/></if>
            <service-call name="mantle.product.AssetServices.move#Product" in-map="context" out-map="context"/>
        </actions>
    </service>
    <service verb="check" noun="ScanLocation">
        <in-parameters>
            <parameter name="facilityId"/>
            <parameter name="locationSeqId"/>
            <parameter name="containerId"><description>May be actual containerId or serialNumber</description></parameter>
            <parameter name="scanLocation"><description>May be locationSeqId within facility, containerId, or container serialNumber</description></parameter>
        </in-parameters>
        <out-parameters>
            <parameter name="facilityId"/>
            <parameter name="locationSeqId"/>
            <parameter name="checkFacLoc" type="Map"/>
            <parameter name="containerId"/>
            <parameter name="container" type="Map"/>
        </out-parameters>
        <actions>
            <!-- see if scanLocation is a locationSeqId in the Facility -->
            <if condition="scanLocation &amp;&amp; facilityId">
                <entity-find-one entity-name="mantle.facility.FacilityLocation" value-field="checkFacLoc">
                    <field-map field-name="facilityId"/>
                    <field-map field-name="locationSeqId" from="scanLocation"/>
                </entity-find-one>
                <if condition="checkFacLoc != null"><then>
                    <set field="locationSeqId" from="checkFacLoc.locationSeqId"/>
                    <set field="scanLocation" from="null"/>
                </then><else>
                    <entity-find-one entity-name="mantle.facility.FacilityLocation" value-field="checkFacLoc">
                        <field-map field-name="facilityId"/>
                        <field-map field-name="description" from="scanLocation"/>
                    </entity-find-one>
                    <if condition="checkFacLoc != null">
                        <set field="locationSeqId" from="checkFacLoc.locationSeqId"/>
                        <set field="scanLocation" from="null"/>
                    </if>
                </else></if>
            </if>
            <!-- see if scanLocation is a containerId -->
            <if condition="scanLocation">
                <entity-find-one entity-name="mantle.product.asset.Container" value-field="container">
                    <field-map field-name="containerId" from="scanLocation"/></entity-find-one>
                <if condition="container != null">
                    <set field="containerId" from="container.containerId"/>
                    <set field="scanLocation" from="null"/>
                </if>
            </if>
            <!-- see if scanLocation is a Container.serialNumber -->
            <if condition="scanLocation">
                <entity-find-one entity-name="mantle.product.asset.Container" value-field="container">
                    <field-map field-name="serialNumber" from="scanLocation"/></entity-find-one>
                <if condition="container != null">
                    <set field="containerId" from="container.containerId"/>
                    <set field="scanLocation" from="null"/>
                </if>
            </if>

            <if condition="containerId">
                <if condition="container == null">
                    <entity-find-one entity-name="mantle.product.asset.Container" value-field="container"/></if>
                <if condition="container == null">
                    <entity-find-one entity-name="mantle.product.asset.Container" value-field="container">
                        <field-map field-name="serialNumber" from="containerId"/></entity-find-one>
                    <if condition="container == null"><return error="true" message="Container not found with ID or serial number ${containerId}"/></if>
                    <set field="containerId" from="container.containerId"/>
                </if>
                <set field="facilityId" from="container.facilityId"/>
                <set field="locationSeqId" from="container.locationSeqId"/>
            </if>
            <if condition="facilityId &amp;&amp; locationSeqId">
                <entity-find-one entity-name="mantle.facility.FacilityLocation" value-field="checkFacLoc">
                    <field-map field-name="facilityId"/><field-map field-name="locationSeqId"/></entity-find-one>
                <entity-find-one entity-name="mantle.facility.Facility" value-field="facility"/>
                <if condition="checkFacLoc == null">
                    <return error="true" message="Location [${locationSeqId}] is not valid in facility ${ec.resource.expand('FacilityNameTemplate', '', facility)}"/>
                </if>
            </if>
        </actions>
    </service>

    <service verb="move" noun="Asset">
        <in-parameters>
            <parameter name="assetId" required="true"/>
            <parameter name="facilityId"><description>Defaults to current facilityId</description></parameter>
            <parameter name="locationSeqId"/>
            <parameter name="assetPoolId"/>
            <parameter name="containerId"><description>May be actual containerId or serialNumber</description></parameter>
            <parameter name="scanLocation"><description>May be locationSeqId within facility, containerId, or container serialNumber</description></parameter>
            <parameter name="quantity" type="BigDecimal"><description>Defaults to quantityOnHandTotal if hasQuantity, if not specified move entire Asset</description></parameter>
            <parameter name="forceNewAsset" type="Boolean" default="false">
                <description>If true create a new Asset record for the move rather than updating the existing Asset record even if moving full quantity on hand to the same facility.</description></parameter>
            <parameter name="moveAssetReservationId"/>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="mantle.product.asset.Asset" value-field="asset" for-update="true"/>
            <if condition="asset == null"><message error="true">No asset found for ID ${assetId}</message></if>
            <if condition="!facilityId"><set field="facilityId" from="asset.facilityId"/></if>

            <!-- checks and normalizes facilityId, locationSeqId, containerId, scanLocation -->
            <service-call name="mantle.product.AssetServices.check#ScanLocation" in-map="context" out-map="context"/>

            <!-- get facilityId and locationSeqId from Container, do here instead of relying on EECA rule just in case involves a move to another facility -->
            <if condition="!containerId &amp;&amp; asset.containerId">
                <!-- no containerId passed but Asset has containerId, clear otherwise new location won't get set (will be overridden by container) -->
                <set field="asset.containerId" from="null"/>
                <entity-update value-field="asset"/>
            </if>

            <set field="facLoc" from="asset.location"/>
            <if condition="!locationSeqId">
                <entity-find-one entity-name="mantle.facility.Facility" value-field="facility"><field-map field-name="facilityId"/></entity-find-one>
                <if condition="facility?.assetInventoryLocRequire == 'Y' &amp;&amp; asset.assetTypeEnumId == 'AstTpInventory'">
                    <return error="true" message="No location specified, facility ${ec.resource.expand('FacilityNameTemplate', '', facility)} requires a location for inventory"/></if>
            </if>

            <!-- see if the target location's type has an autoStatusId in the Facility -->
            <if condition="checkFacLoc?.locationTypeEnumId">
                <entity-find-one entity-name="mantle.facility.FacilityLocationType" value-field="facLocType">
                    <field-map field-name="facilityId"/>
                    <field-map field-name="locationTypeEnumId" from="checkFacLoc.locationTypeEnumId"/>
                </entity-find-one>
                <set field="autoStatusId" from="facLocType?.autoStatusId"/>
            </if>

            <!-- default quantity to QOH (note: used to do this only if hasQuantity != 'N', even for serialized always do for AssetDetail, etc) -->
            <if condition="!quantity"><set field="quantity" from="asset.quantityOnHandTotal"/></if>
            <!-- default quantity to QOH -->
            <if condition="quantity &gt; asset.quantityOnHandTotal">
                <return error="true" message="Move quantity ${quantity?.toPlainString()} is greater than on hand quantity ${asset.quantityOnHandTotal?.toPlainString()}"/></if>
            <if condition="(quantity &gt; asset.availableToPromiseTotal) &amp;&amp; !moveAssetReservationId">
                <message type="warning">Move quantity ${quantity?.toPlainString()} is greater than available quantity ${asset.availableToPromiseTotal?.toPlainString()}</message></if>

            <!-- <log level="warn" message="In move from Asset ${asset.assetId} reservation ${moveAssetReservationId} quantity ${quantity} Asset QOH ${asset.quantityOnHandTotal}"/> -->

            <!-- for partial quantity or facilityId change reduce quantity on original and create new with given quantity -->
            <if condition="forceNewAsset || (quantity &amp;&amp; quantity &lt; asset.quantityOnHandTotal) ||
                    (facilityId &amp;&amp; facilityId != asset.facilityId) || (assetPoolId != asset.assetPoolId)"><then>

                <set field="newStatusId" from="autoStatusId ?: asset.statusId"/>

                <!-- look for an existing Asset record to move to -->
                <if condition="!forceNewAsset">
                    <entity-find entity-name="mantle.product.asset.Asset" list="existingAssetList">
                        <econdition field-name="assetId" operator="not-equals" from="asset.assetId"/>
                        <econdition field-name="productId" from="asset.productId"/>
                        <econdition field-name="ownerPartyId" from="asset.ownerPartyId"/>
                        <econdition field-name="statusId" from="newStatusId"/>
                        <econdition field-name="assetPoolId"/>
                        <econdition field-name="facilityId"/>
                        <econdition field-name="locationSeqId"/>
                        <econdition field-name="containerId"/>
                        <econdition field-name="lotId" from="asset.lotId"/>
                        <econdition field-name="receivedDate" from="asset.receivedDate"/>
                        <econdition field-name="expectedEndOfLife" from="asset.expectedEndOfLife"/>
                        <order-by field-name="assetId"/>
                    </entity-find>
                </if>

                <if condition="existingAssetList"><then>
                    <set field="newAssetId" from="existingAssetList[0].assetId"/>
                    <!-- <log level="warn" message="In move from Asset ${asset.assetId} found existing move to Asset ${existingAssetList[0]}"/> -->
                </then><else>
                    <!-- clone asset in new facility/location with quantity -->
                    <service-call name="create#mantle.product.asset.Asset" out-map="newAssetOut"
                            in-map="asset.getMap() + [assetId:null, facilityId:facilityId, locationSeqId:locationSeqId,
                                containerId:containerId, quantityOnHandTotal:0, availableToPromiseTotal:0,
                                statusId:newStatusId, assetPoolId:assetPoolId]"/>
                    <set field="newAssetId" from="newAssetOut.assetId"/>
                </else></if>

                <!-- <log level="warn" message="In move from Asset ${asset.assetId} newAssetId ${newAssetId} existingAssetList ${existingAssetList}"/> -->

                <!-- increase new asset QOH/ATP by quantity -->
                <service-call name="create#mantle.product.asset.AssetDetail" out-map="context"
                        in-map="[assetId:newAssetId, effectiveDate:ec.user.nowTimestamp, quantityOnHandDiff:quantity,
                                 availableToPromiseDiff:quantity, productId:productId, otherAssetId:assetId]"/>

                <!-- between increase new Asset and reduce old Asset move AssetReservation(s) -->
                <if condition="moveAssetReservationId"><then>
                    <!-- <log level="warn" message="In move from Asset ${asset.assetId} moving reservation ${moveAssetReservationId} to new Asset ${newAssetId}"/> -->
                    <service-call name="mantle.product.AssetServices.move#AssetReservation" out-map="moveArOut"
                            in-map="[assetId:newAssetId, assetReservationId:moveAssetReservationId, quantity:quantity]"/>
                </then><else>
                    <!-- move reservations if necessary so ATP doesn't go negative
                        OR if moving from a non-Pick location to a Pick location (along with reserve in Pick location first logic) -->
                    <set field="atpToMoveTotal" from="null"/>
                    <if condition="quantity &gt; asset.availableToPromiseTotal">
                        <!-- move reservations as needed -->
                        <set field="atpToMoveTotal" from="quantity - asset.availableToPromiseTotal"/>
                    </if>
                    <!-- moving from facLoc to checkFacLoc -->
                    <!-- <log message="checkFacLoc?.locationTypeEnumId ${checkFacLoc?.locationTypeEnumId} facLoc?.locationTypeEnumId ${facLoc?.locationTypeEnumId}"/> -->
                    <if condition="checkFacLoc?.locationTypeEnumId == 'FltPick' &amp;&amp; facLoc?.locationTypeEnumId != 'FltPick'">
                        <set field="atpToMoveTotal" from="quantity"/>
                    </if>
                    <if condition="atpToMoveTotal">
                        <!-- NOTE: no longer call displace#AssetReservations for different facility here, handled below with
                            call to check#AssetReservations -->
                        <set field="availableRemaining" from="atpToMoveTotal"/>
                        <entity-find entity-name="mantle.product.issuance.AssetReservation" list="resList">
                            <econdition field-name="assetId"/><order-by field-name="reservedDate"/></entity-find>
                        <iterate list="resList" entry="res">
                            <if condition="availableRemaining == 0"><break/></if>
                            <set field="quantityToMove" from="availableRemaining &lt; res.quantity ? availableRemaining : res.quantity"/>
                            <if condition="quantityToMove == 0"><continue/></if>
                            <!-- make sure quantityToMove is less than res.quantityNotIssued, don't move issued quantities! -->
                            <if condition="quantityToMove &gt; res.quantityNotIssued"><set field="quantityToMove" from="res.quantityNotIssued"/></if>
                            <if condition="quantityToMove &gt; 0">
                                <service-call name="mantle.product.AssetServices.move#AssetReservation" out-map="moveArOut" out-map-add-to-existing="false"
                                        in-map="[assetId:newAssetId, assetReservationId:res.assetReservationId, quantity:quantityToMove]"/>
                                <set field="availableRemaining" from="availableRemaining - moveArOut.quantityMoved"/>
                            </if>
                        </iterate>
                    </if>
                </else></if>

                <!-- reduce original asset QOH/ATP by quantity -->
                <service-call name="create#mantle.product.asset.AssetDetail" out-map="context"
                        in-map="[assetId:assetId, effectiveDate:ec.user.nowTimestamp, quantityOnHandDiff:-quantity,
                                 availableToPromiseDiff:-quantity, productId:productId, otherAssetId:newAssetId]"/>
            </then><else>
                <!-- make sure can change from asset.statusId to autoStatusId -->
                <if condition="autoStatusId">
                    <if condition="asset.statusId &amp;&amp; asset.statusId != autoStatusId">
                        <entity-find-count entity-name="moqui.basic.StatusFlowTransition" count-field="transitionCount">
                            <econdition field-name="statusId" from="asset.statusId"/>
                            <econdition field-name="toStatusId" from="autoStatusId"/>
                        </entity-find-count>
                        <if condition="transitionCount == 0">
                            <return error="true" message="Cannot move asset ${assetId} with status ${asset.statusId} to target location ${locationSeqId} of type ${checkFacLoc?.locationTypeEnumId} with auto status ${autoStatusId}"/></if>
                    </if>

                    <set field="statusId" from="autoStatusId"/>
                </if>
                <!-- <log level="warn" message="In move from Asset ${asset.assetId} update whole Asset"/> -->
                <service-call name="update#mantle.product.asset.Asset" in-map="context"/>
                <set field="newAssetId" from="assetId"/>
            </else></if>

            <entity-find-one entity-name="mantle.product.asset.Asset" value-field="newAsset">
                <field-map field-name="assetId" from="newAssetId"/></entity-find-one>

            <!-- <log level="warn" message="move original asset:\n${asset}\n new asset:\n${newAsset}"/> -->

            <!-- if assetPoolId changed or was set evaluate all reservations to see if they qualify for pool, if not re-reserve -->
            <!-- if assetPoolId was set but is now null call increased inventory service so backordered reservations can use -->
            <!-- do something similar if facilityId changes -->
            <if condition="asset.assetPoolId != newAsset.assetPoolId || asset.facilityId != newAsset.facilityId">
                <service-call name="mantle.product.AssetServices.check#AssetReservations" in-map="[assetId:newAsset.assetId]"/>
            </if>
            <!-- if me to Pick location and has available quantity, look for reservations against non-Pick locations and move them here -->
            <if condition="checkFacLoc?.locationTypeEnumId == 'FltPick' &amp;&amp; newAsset.availableToPromiseTotal &gt; 0.0">
                <service-call name="mantle.product.AssetServices.move#ReservationsFromNonPickLocations" in-map="[assetId:newAsset.assetId]"/>
            </if>

            <set field="newFacLoc" from="newAsset.location"/>
            <message>Moved ${quantity?.toPlainString()} from Asset ${ec.resource.expand('AssetNameTemplate', '', asset)} from ${ec.resource.expand('FacilityLocationNameTemplate', '', facLoc?:[:])} to Asset ${newAssetId ?: asset.assetId} ${ec.resource.expand('FacilityLocationNameTemplate', '', newFacLoc?:[:])}${container ? ' in container ' + (container.serialNumber ?: container.description ?: containerId) : ''}.</message>
        </actions>
    </service>

    <!-- ================================================= -->
    <!-- ========== Physical Inventory Services ========== -->
    <!-- ================================================= -->

    <service verb="record" noun="PhysicalInventoryQuantity" no-tx-cache="true">
        <in-parameters>
            <auto-parameters entity-name="mantle.product.asset.Asset" include="nonpk"><exclude field-name="classEnumId"/>
                <exclude field-name="quantityOnHandTotal"/><exclude field-name="availableToPromiseTotal"/>
                <exclude field-name="hasQuantity"/><exclude field-name="receivedDate"/><exclude field-name="acquiredDate"/></auto-parameters>
            <parameter name="productId" required="true"/>
            <parameter name="facilityId" required="true"/>
            <parameter name="physicalInventoryId"/>
            <parameter name="physicalInventoryCountId"/>
            <parameter name="quantity" type="BigDecimal" required="true"/>
            <parameter name="partyId" default="ec.user.userAccount?.partyId"/>
            <parameter name="physicalInventoryDate" type="Timestamp" default="ec.user.nowTimestamp"/>
            <parameter name="comments"/>
            <parameter name="varianceReasonEnumId"/>
            <parameter name="strictLocation" type="Boolean" default="false">
                <description>If true filter by null locationSeqId (No Location), otherwise for null locationSeqId do not filter (Any Location)</description></parameter>
            <parameter name="strictLot" type="Boolean" default="false">
                <description>If true filter by null lotId (No Lot), otherwise for null lotId do not filter (Any Lot)</description></parameter>
            <parameter name="strictAll" type="Boolean" default="false">
                <description>If true filter by null locationSeqId, lotId, ownerPartyId, assetPoolId, and statusId (No/None); otherwise for null do not filter (Any)</description></parameter>
        </in-parameters>
        <out-parameters>
            <parameter name="physicalInventoryId"/>
            <parameter name="quantityChange" type="BigDecimal"/>
        </out-parameters>
        <actions>
            <if condition="physicalInventoryCountId">
                <service-call name="update#mantle.product.asset.PhysicalInventoryCount"
                        in-map="[physicalInventoryCountId:physicalInventoryCountId, quantityOnHand:quantity]"/>
            </if>

            <set field="currentQoh" from="0"/>
            <entity-find entity-name="mantle.product.asset.Asset" list="assetList">
                <econdition field-name="productId"/>
                <econdition field-name="facilityId"/>
                <econdition field-name="locationSeqId" from="locationSeqId ?: null" ignore="!locationSeqId &amp;&amp; !strictLocation &amp;&amp; !strictAll"/>
                <econdition field-name="lotId" from="lotId ?: null" ignore="!lotId &amp;&amp; !strictLot &amp;&amp; !strictAll"/>
                <econdition field-name="ownerPartyId" from="ownerPartyId ?: null" ignore="!ownerPartyId &amp;&amp; !strictAll"/>
                <econdition field-name="assetPoolId" from="assetPoolId ?: null" ignore="!assetPoolId &amp;&amp; !strictAll"/>
                <econdition field-name="statusId" from="statusId ?: null" ignore="!statusId &amp;&amp; !strictAll"/>
                <!-- with physicalInventoryDate in the past this won't work: <econdition field-name="quantityOnHandTotal" operator="not-equals" from="0.0"/> -->
                <econdition field-name="receivedDate" operator="less-equals" from="physicalInventoryDate" or-null="true"/>
            </entity-find>
            <iterate list="assetList" entry="asset">
                <!-- old approach using quantityOnHandTotal, won't work for back-dated physical inventory:
                <set field="currentQoh" from="currentQoh + asset.quantityOnHandTotal"/>
                -->
                <!-- calculate as of physicalInventoryDate -->
                <entity-find entity-name="mantle.product.asset.AssetDetailSummary" list="detailSummaryList">
                    <econdition field-name="assetId" from="asset.assetId"/>
                    <econdition field-name="effectiveDate" operator="less-equals" from="physicalInventoryDate"/>
                    <select-field field-name="quantityOnHandTotal"/>
                </entity-find>
                <if condition="detailSummaryList.size() &gt; 0">
                    <set field="currentQoh" from="currentQoh + (detailSummaryList.get(0).quantityOnHandTotal ?: 0.0)"/>
                </if>
            </iterate>

            <set field="quantityChange" from="quantity - currentQoh"/>
            <if condition="quantityChange != 0.0"><then>
                <message>Quantity specified (${ec.l10n.format(quantity, null)}) differs from current on hand (${ec.l10n.format(currentQoh, null)}) by ${ec.l10n.format(quantityChange, null)}, adjusting (Prod:${productId}, Fac:${facilityId}, Loc:${locationSeqId?:(strictAll||strictLocation?'None':'Any')}, Lot:${lotId?:(strictAll||strictLot?'None':'Any')}, Owner:${ownerPartyId?:(strictAll?'None':'Any')}, Pool:${assetPoolId?:(strictAll?'None':'Any')}, Stts:${statusId?:(strictAll?'None':'Any')})</message>
                <service-call name="mantle.product.AssetServices.record#PhysicalInventoryChange" in-map="context"/>
            </then><else>
                <message type="success">Quantity specified (${ec.l10n.format(quantity, null)}) matched current records, no adjustment needed</message>
            </else></if>
        </actions>
    </service>
    <service verb="record" noun="PhysicalInventoryChange" no-tx-cache="true">
        <in-parameters>
            <auto-parameters entity-name="mantle.product.asset.Asset" include="nonpk"><exclude field-name="classEnumId"/>
                <exclude field-name="quantityOnHandTotal"/><exclude field-name="availableToPromiseTotal"/>
                <exclude field-name="hasQuantity"/><exclude field-name="receivedDate"/><exclude field-name="acquiredDate"/></auto-parameters>
            <parameter name="productId" required="true"/>
            <parameter name="facilityId" required="true"/>
            <parameter name="physicalInventoryId"/>
            <parameter name="physicalInventoryCountId"/>
            <parameter name="quantityChange" type="BigDecimal" required="true"/>
            <parameter name="partyId" default="ec.user.userAccount?.partyId"/>
            <parameter name="physicalInventoryDate" type="Timestamp" default="ec.user.nowTimestamp"/>
            <parameter name="comments"/>
            <parameter name="varianceReasonEnumId"/>
            <parameter name="assetList" type="EntityList">
                <description>Optional, meant to be used when called by other physical inventory services.</description>
                <parameter name="asset" type="EntityValue"/>
            </parameter>
            <parameter name="strictLocation" type="Boolean" default="false">
                <description>If true filter by null locationSeqId (No Location), otherwise for null locationSeqId do not filter (Any Location)</description></parameter>
            <parameter name="strictLot" type="Boolean" default="false">
                <description>If true filter by null lotId (No Lot), otherwise for null lotId do not filter (Any Lot)</description></parameter>
            <parameter name="strictAll" type="Boolean" default="false">
                <description>If true filter by null locationSeqId, lotId, ownerPartyId, assetPoolId, and statusId (No/None); otherwise for null do not filter (Any)</description></parameter>
        </in-parameters>
        <out-parameters>
            <parameter name="physicalInventoryId"/>
            <parameter name="quantityRemaining" type="BigDecimal"><description>Always zero (0) if quantityChange is
                greater than zero. If quantityChange is less than zero and could not find enough quantity on hand this
                is the quantity that could not be removed.</description></parameter>
            <parameter name="assetIdList" type="List"><parameter name="assetId"/></parameter>
        </out-parameters>
        <actions>
            <!-- set the date to be used on AssetDetail records -->
            <set field="effectiveDate" from="physicalInventoryDate"/>
            <!-- create the PhysicalInventory inventory record -->
            <if condition="!physicalInventoryId">
                <service-call name="create#mantle.product.asset.PhysicalInventory" in-map="context + [statusId:'PIComplete']" out-map="context"/></if>

            <if condition="!ownerPartyId">
                <entity-find-one entity-name="mantle.facility.Facility" value-field="facility"/>
                <set field="ownerPartyId" from="facility.ownerPartyId"/>
            </if>

            <set field="assetIdList" from="[]"/>
            <if condition="!assetList">
                <entity-find entity-name="mantle.product.asset.Asset" list="assetList">
                    <econdition field-name="productId"/>
                    <econdition field-name="facilityId"/>
                    <econdition field-name="locationSeqId" from="locationSeqId ?: null" ignore="!locationSeqId &amp;&amp; !strictLocation &amp;&amp; !strictAll"/>
                    <econdition field-name="lotId" from="lotId ?: null" ignore="!lotId &amp;&amp; !strictLot &amp;&amp; !strictAll"/>
                    <econdition field-name="ownerPartyId" from="ownerPartyId ?: null" ignore="!ownerPartyId &amp;&amp; !strictAll"/>
                    <econdition field-name="assetPoolId" from="assetPoolId ?: null" ignore="!assetPoolId &amp;&amp; !strictAll"/>
                    <econdition field-name="statusId" from="statusId ?: null" ignore="!statusId &amp;&amp; !strictAll"/>
                    <!-- with physicalInventoryDate in the past this won't work: <econdition field-name="quantityOnHandTotal" operator="not-equals" from="0.0"/> -->
                    <econdition field-name="receivedDate" operator="less-equals" from="physicalInventoryDate" or-null="true"/>
                    <order-by field-name="receivedDate"/><!-- oldest first -->
                    <order-by field-name="-assetId"/><!-- by ID to make sure we have a consistent order for locking -->
                </entity-find>
            </if>

            <!-- <log level="warn" message="======= Changing product [${productId}] in facility [${facilityId}:${locationSeqId}] by ${quantityChange}; assetList: ${assetList}"/> -->
            <if condition="quantityChange &gt; 0.0"><then>
                <if condition="assetList"><then>
                    <set field="quantityRemaining" from="quantityChange"/>
                    <!-- NOTE: consider reversing assetList to increase quantity newest first instead of oldest first -->
                    <iterate list="assetList" entry="asset">
                        <!-- NOTE: no real reason for iterating here, will always add it all to the first Asset record; leaving it for now to make more complex logic easier in the future -->
                        <set field="quantityDiff" from="quantityRemaining"/>
                        <if condition="quantityDiff != 0">
                            <service-call name="mantle.product.AssetServices.change#AssetQuantity" in-map="context + [assetId:asset.assetId]"/></if>
                        <set field="quantityRemaining" from="quantityRemaining - quantityDiff"/>
                        <script>assetIdList.add(asset.assetId)</script>
                        <if condition="quantityRemaining == 0"><break/></if>
                    </iterate>
                </then><else>
                    <!-- NOTE: with the change to query assetList above instead of only using passed assetList this will not happen as frequently but is still needed -->
                    <set field="quantityRemaining" from="0.0"/>
                    <!-- no passed assetList and quantityChange > 0, create new Asset -->
                    <service-call name="mantle.product.AssetServices.create#ProductAssetAdHoc" out-map="context"
                            in-map="context + [createdDate:physicalInventoryDate]"/>
                    <service-call name="create#mantle.product.asset.AssetDetail" out-map="context"
                            in-map="[assetId:assetId, effectiveDate:physicalInventoryDate, quantityOnHandDiff:quantityChange,
                                availableToPromiseDiff:quantityChange, productId:productId,
                                physicalInventoryId:physicalInventoryId, physicalInventoryCountId:physicalInventoryCountId,
                                varianceReasonEnumId:varianceReasonEnumId]"/>
                    <!-- reserve the newly available Asset, if needed -->
                    <service-call name="mantle.product.AssetServices.reserve#IncreasedAsset" in-map="[assetId:assetId]"/>
                    <script>assetIdList.add(assetId)</script>
                </else></if>
            </then><else-if condition="quantityChange &lt; 0.0">
                <!-- lock the records we need -->
                <set field="quantityRemaining" from="-quantityChange"/>
                <set field="lockedAssetList" from="[]"/>
                <set field="lockedAssetQoh" from="[:]"/>
                <iterate list="assetList" entry="asset">
                    <!-- calculate quantityOnHandTotal as of physicalInventoryDate instead of using current -->
                    <entity-find entity-name="mantle.product.asset.AssetDetailSummary" list="detailSummaryList">
                        <econdition field-name="assetId" from="asset.assetId"/>
                        <econdition field-name="effectiveDate" operator="less-equals" from="physicalInventoryDate"/>
                        <select-field field-name="quantityOnHandTotal"/>
                    </entity-find>
                    <set field="quantityOnHandTotal" from="detailSummaryList.size() &gt; 0 ? (detailSummaryList.get(0).quantityOnHandTotal ?: 0.0) : 0.0"/>

                    <set field="quantityDiff" from="quantityRemaining &gt; quantityOnHandTotal ? quantityOnHandTotal : quantityRemaining"/>
                    <if condition="quantityDiff != 0.0">
                        <!-- get a locked record -->
                        <entity-find-one entity-name="mantle.product.asset.Asset" value-field="lockedAsset" for-update="true">
                            <field-map field-name="assetId" from="asset.assetId"/></entity-find-one>
                        <set field="quantityDiff" from="quantityRemaining &gt; quantityOnHandTotal ? quantityOnHandTotal : quantityRemaining"/>
                        <if condition="quantityDiff != 0.0">
                            <script>
                                lockedAssetList.add(lockedAsset)
                                lockedAssetQoh.put(lockedAsset.assetId, quantityOnHandTotal)
                            </script>
                            <set field="quantityRemaining" from="quantityRemaining - quantityDiff"/>
                        </if>
                    </if>
                    <if condition="quantityRemaining == 0.0"><break/></if>
                </iterate>

                <!-- do the actual quantity changes -->
                <set field="quantityRemaining" from="-quantityChange"/>
                <iterate list="lockedAssetList" entry="asset">
                    <set field="quantityOnHandTotal" from="lockedAssetQoh.get(asset.assetId)"/>
                    <set field="quantityDiff" from="quantityRemaining &gt; quantityOnHandTotal ? quantityOnHandTotal : quantityRemaining"/>
                    <if condition="quantityDiff != 0.0">
                        <service-call name="mantle.product.AssetServices.change#AssetQuantity" in-map="context +
                                [assetId:asset.assetId, quantityDiff:-quantityDiff]"/>
                        <set field="quantityRemaining" from="quantityRemaining - quantityDiff"/>
                        <script>assetIdList.add(asset.assetId)</script>
                    </if>
                    <if condition="quantityRemaining == 0.0"><break/></if>
                </iterate>
            </else-if></if>
            <if condition="quantityRemaining != 0">
                <message type="warning">Could not reduce quantity by ${quantityRemaining}, insufficient quantity on hand.</message></if>
        </actions>
    </service>
    <service verb="create" noun="ProductAssetAdHoc">
        <in-parameters>
            <auto-parameters entity-name="mantle.product.asset.Asset" include="nonpk"><exclude field-name="classEnumId"/>
                <exclude field-name="quantityOnHandTotal"/><exclude field-name="availableToPromiseTotal"/>
                <exclude field-name="hasQuantity"/><exclude field-name="receivedDate"/><exclude field-name="acquiredDate"/></auto-parameters>
            <parameter name="productId" required="true"/>
            <parameter name="facilityId" required="true"/>
            <parameter name="createdDate" type="Timestamp" default="ec.user.nowTimestamp"/>
        </in-parameters>
        <out-parameters><parameter name="assetId"/></out-parameters>
        <actions>
            <entity-find-one entity-name="mantle.product.Product" value-field="product" cache="true"/>
            <set field="assetTypeEnumId" from="product.assetTypeEnumId ?: 'AstTpInventory'"/>
            <set field="statusId" from="statusId ?: (assetTypeEnumId == 'AstTpInventory' ? 'AstAvailable' : 'AstInStorage')"/>
            <if condition="!acquireCost">
                <!-- we may want more options for this, for now grab the most recent record to try to find a reasonable cost -->
                <entity-find entity-name="mantle.product.asset.Asset" list="costAssetList" limit="1">
                    <econdition field-name="productId"/><econdition field-name="facilityId"/>
                    <econdition field-name="ownerPartyId" ignore-if-empty="true"/>
                    <order-by field-name="-assetId"/>
                </entity-find>
                <if condition="costAssetList">
                    <set field="acquireCost" from="costAssetList[0].acquireCost"/>
                    <set field="acquireCostUomId" from="costAssetList[0].acquireCostUomId"/>
                </if>
            </if>
            <service-call name="create#mantle.product.asset.Asset" out-map="assetOut"
                    in-map="context + [classEnumId:product.assetClassEnumId, quantityOnHandTotal:0, availableToPromiseTotal:0,
                        hasQuantity:'Y', receivedDate:createdDate, acquiredDate:createdDate]"/>
            <set field="assetId" from="assetOut.assetId"/>
        </actions>
    </service>

    <service verb="update" noun="PhysicalInventoryDate">
        <description>Update date on PhysicalInventory, AssetDetail, and repost AcctgTrans with new date</description>
        <in-parameters>
            <parameter name="physicalInventoryId" required="true"/>
            <parameter name="physicalInventoryDate" required="true"/>
            <parameter name="comments"/>
        </in-parameters>
        <actions>
            <set field="updateMap" from="[physicalInventoryId:physicalInventoryId, physicalInventoryDate:physicalInventoryDate]"/>
            <if condition="comments"><set field="updateMap.comments" from="comments"/></if>
            <service-call name="update#mantle.product.asset.PhysicalInventory" in-map="updateMap"/>
            <entity-find entity-name="mantle.product.asset.AssetDetail" list="assetDetailList">
                <econdition field-name="physicalInventoryId"/></entity-find>
            <iterate list="assetDetailList" entry="assetDetail">
                <if condition="assetDetail.effectiveDate != physicalInventoryDate">
                    <service-call name="update#mantle.product.asset.AssetDetail"
                            in-map="[assetDetailId:assetDetail.assetDetailId, effectiveDate:physicalInventoryDate]"/>
                    <service-call name="mantle.ledger.AssetAutoPostServices.repost#PhysicalInventoryVariance"
                            in-map="[assetDetailId:assetDetail.assetDetailId]"/>
                </if>
            </iterate>
        </actions>
    </service>
</services>
