<?xml version="1.0" encoding="UTF-8"?>
<services xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:noNamespaceSchemaLocation="http://moqui.org/xsd/service-definition-3.xsd">

  <!-- MCP Authorization Services -->

  <service verb="validate" noun="McpApiKey">
    <description>Validate API key for MCP access with classificationId AppSupport</description>
    <in-parameters>
      <parameter name="apiKey" type="String" required="false" />
      <parameter name="classificationId" type="String" default-value="AppSupport" />
    </in-parameters>
    <out-parameters>
      <parameter name="authenticated" type="Boolean" />
      <parameter name="userId" type="String" />
      <parameter name="ownerPartyId" type="String" />
      <parameter name="companyPartyId" type="String" />
      <parameter name="userPartyId" type="String" />
      <parameter name="errorMessage" type="String" />
    </out-parameters>
    <actions>
      <set field="authenticated" value="false" />

      <!-- Get API key from header if not passed as parameter -->
      <if condition="!apiKey">
        <set field="apiKey" from="ec.web?.request?.getHeader('api_key')" />
      </if>

      <!-- Check for Bearer token in Authorization header -->
      <if condition="!apiKey">
        <set field="authHeader" from="ec.web?.request?.getHeader('Authorization')" />
        <if condition="authHeader?.startsWith('Bearer ')">
          <set field="apiKey" from="authHeader.substring(7)" />
        </if>
      </if>

      <!-- If still no API key, check current user -->
      <if condition="!apiKey &amp;&amp; ec.user.userId">
        <set field="apiKey" from="ec.user.getLoginKey()" />
      </if>

      <!-- If no API key found, return not authenticated -->
      <if
        condition="!apiKey || apiKey.trim().isEmpty() || 'null'.equals(apiKey) || 'undefined'.equals(apiKey)">
        <set field="errorMessage" value="API key required for MCP access" />
        <return />
      </if>

      <!-- Validate the API key by attempting to login -->
      <script><![CDATA[
        try {
          // Save current user state
          def currentUserId = ec.user.userId
          def currentUsername = ec.user.username
          
          // Attempt login with the API key
          def loginResult = ec.user.loginUserKey(apiKey.trim())
          
          if (loginResult && ec.user.userId) {
            // Successfully authenticated
            authenticated = true
            userId = ec.user.userId
            
            // Get related company and owner information using GrowERP service
            try {
              def authResult = ec.service.sync().name("growerp.100.GeneralServices100.get#Authenticate")
                .parameter("classificationId", classificationId)
                .call()
              
              if (authResult && authResult.authenticate) {
                ownerPartyId = authResult.authenticate.ownerPartyId
                companyPartyId = authResult.authenticate.company?.partyId
                userPartyId = authResult.authenticate.user?.partyId
              } else {
                errorMessage = "User not authorized for classification: " + classificationId
                authenticated = false
              }
            } catch (Exception e) {
              ec.logger.warn("Error getting authentication details: " + e.message)
              errorMessage = "Authentication validation failed: " + e.message
              authenticated = false
            }
          } else {
            errorMessage = "Invalid API key"
          }
          
          // Restore original user state if it was different
          /* if (currentUserId && currentUserId != ec.user.userId) {
            if (currentUsername) {
              ec.user.loginUser(currentUsername, null)
            } else {
              ec.user.logoutUser()
            }
          } */
        } catch (Exception e) {
          ec.logger.warn("Error validating API key: " + e.message)
          errorMessage = "API key validation failed: " + e.message
          authenticated = false
        }
      ]]></script>
    </actions>
  </service>

  <service verb="create" noun="AuthPrompt">
    <description>Create an authentication prompt for AI when authorization fails</description>
    <in-parameters>
      <parameter name="requestId" type="Object" required="false" />
      <parameter name="operation" type="String" default-value="login" />
      <parameter name="reason" type="String" default-value="Authentication required" />
    </in-parameters>
    <out-parameters>
      <parameter name="promptResponse" type="Map" />
    </out-parameters>
    <actions>
      <!-- Create a structured response that tells the AI to prompt for credentials -->
      <set field="promptResponse"
        from="[
        jsonrpc: '2.0',
        id: requestId,
        error: [
          code: -32002,
          message: 'Authentication required',
          data: [
            type: 'auth_prompt',
            operation: operation,
            reason: reason,
            prompt: [
              name: 'growerp_login',
              description: 'Login to GrowERP to access MCP services',
              arguments: [
                properties: [
                  username: [
                    type: 'string',
                    description: 'GrowERP username/email',
                    required: true
                  ],
                  password: [
                    type: 'string',
                    description: 'GrowERP password',
                    required: true,
                    secret: true
                  ],
                  classificationId: [
                    type: 'string',
                    description: 'User classification (default: AppSupport)',
                    default: 'AppSupport'
                  ]
                ],
                required: ['username', 'password']
              ],
              instructions: 'Please provide your GrowERP credentials to access MCP services. Use test@example.com/qqqqqq9! for testing.'
            ]
          ]
        ]
      ]" />
    </actions>
  </service>

  <service verb="get" noun="OauthDiscovery">
    <description>
      Provide an OAuth 2.0 / OIDC-like discovery document for clients that expect it.
      This points to the custom token/login implementation.
    </description>
    <out-parameters>
      <parameter name="discoveryConfig" type="Map" />
    </out-parameters>
    <actions>
      <script>
        // Get the base URL from the request, ensuring it's an absolute URL
        String baseUrl = ec.web.getWebappRootUrl(true, null)
        if (baseUrl.endsWith("/")) baseUrl = baseUrl.substring(0, baseUrl.length() - 1)

        // Construct the full issuer and token endpoint URLs
        String issuer = baseUrl + "/rest/s1/mcp"
        String tokenEndpoint = baseUrl + "/rest/s1/mcp/auth/token"
        String userInfoEndpoint = baseUrl + "/rest/s1/mcp/auth/userinfo"
        String jwksEndpoint = baseUrl + "/rest/s1/mcp/auth/jwks"

        discoveryConfig = [
          issuer: issuer,
          token_endpoint: tokenEndpoint,
          userinfo_endpoint: userInfoEndpoint,
          jwks_uri: jwksEndpoint,
          // Advertise the 'password' grant type, which matches the username/password login flow
          grant_types_supported: ["password"],
          // The 'token' is the API key
          token_types_supported: ["Bearer"],
          // Let the client know which scopes are available (optional but good practice)
          scopes_supported: ["MCP_VIEW", "MCP_EXECUTE", "MCP_ADMIN"],
          // The credentials are in the POST body, not basic auth
          token_endpoint_auth_methods_supported: ["none"], 
          response_types_supported: ["token"]
        ]
      </script>
    </actions>
  </service>

  <service verb="handle" noun="LoginPrompt">
    <description>Handle login attempt from AI prompt response</description>
    <in-parameters>
      <parameter name="username" type="String" required="true" />
      <parameter name="password" type="String" required="true" />
      <parameter name="classificationId" type="String" default-value="AppSupport" />
      <parameter name="requestId" type="Object" required="false" />
    </in-parameters>
    <out-parameters>
      <parameter name="loginResponse" type="Map" />
      <parameter name="success" type="Boolean" />
      <parameter name="apiKey" type="String" />
      <parameter name="errorMessage" type="String" />
    </out-parameters>
    <actions>
      <set field="success" value="false" />

      <!-- Attempt to login with provided credentials -->
      <script><![CDATA[
        try {
          // Call GrowERP login service
          def loginResult = ec.service.sync().name("growerp.100.GeneralServices100.login#User")
            .parameter("username", username)
            .parameter("password", password)
            .parameter("classificationId", classificationId)
            .call()
          
          if (loginResult && loginResult.authenticate && loginResult.authenticate.apiKey) {
            success = true
            apiKey = loginResult.authenticate.apiKey
            
            // Create successful login response
            loginResponse = [
              jsonrpc: '2.0',
              id: requestId,
              result: [
                type: 'auth_success',
                message: 'Login successful',
                apiKey: apiKey,
                instructions: 'Use this API key in the api_key header for subsequent MCP requests',
                user: [
                  userId: loginResult.authenticate.user?.userId,
                  name: loginResult.authenticate.user?.fullName,
                  email: loginResult.authenticate.user?.email
                ],
                company: [
                  name: loginResult.authenticate.company?.name,
                  partyId: loginResult.authenticate.company?.partyId
                ]
              ]
            ]
          } else {
            errorMessage = "Login failed: Invalid credentials or insufficient permissions"
            loginResponse = [
              jsonrpc: '2.0',
              id: requestId,
              error: [
                code: -32003,
                message: errorMessage,
                data: [
                  type: 'auth_failed',
                  reason: 'Invalid username/password or missing AppSupport classification',
                  retry: true
                ]
              ]
            ]
          }
        } catch (Exception e) {
          ec.logger.warn("Login error: " + e.message)
          errorMessage = "Login failed: " + e.message
          loginResponse = [
            jsonrpc: '2.0',
            id: requestId,
            error: [
              code: -32003,
              message: errorMessage,
              data: [
                type: 'auth_error',
                reason: e.message,
                retry: true
              ]
            ]
          ]
        }
      ]]></script>
    </actions>
  </service>

  <service verb="handle" noun="OauthToken">
    <description>OAuth 2.0 token endpoint - handle password grant</description>
    <in-parameters>
      <parameter name="grantType" type="String" required="true" />
      <parameter name="username" type="String" required="false" />
      <parameter name="password" type="String" required="false" />
      <parameter name="clientId" type="String" required="false" />
      <parameter name="classificationId" type="String" default-value="AppSupport" />
      <parameter name="scope" type="String" required="false" />
    </in-parameters>
    <out-parameters>
      <parameter name="access_token" type="String" />
      <parameter name="token_type" type="String" />
      <parameter name="expires_in" type="Integer" />
      <parameter name="scope" type="String" />
      <parameter name="error" type="String" />
      <parameter name="error_description" type="String" />
    </out-parameters>
    <actions>
      <script><![CDATA[
        try {
          // Validate grant type
          if (grantType != "password") {
            error = "unsupported_grant_type"
            error_description = "Only 'password' grant type is supported"
            return
          }
          
          if (!username || !password) {
            error = "invalid_request"
            error_description = "Username and password are required"
            return
          }
          
          // Call login service
          def loginResult = ec.service.sync().name("McpAuthServices.handle#LoginPrompt")
            .parameters([
              username: username,
              password: password,
              classificationId: classificationId,
              requestId: "oauth-token"
            ]).call()
          
          if (loginResult.success && loginResult.apiKey) {
            // Return OAuth-compliant token response
            access_token = loginResult.apiKey
            token_type = "api_key"
            expires_in = 3600 // 1 hour
            scope = scope ?: "MCP_VIEW MCP_EXECUTE"
          } else {
            error = "invalid_grant"
            error_description = loginResult.errorMessage ?: "Authentication failed"
          }
          
        } catch (Exception e) {
          ec.logger.error("OAuth token error", e)
          error = "server_error"
          error_description = "Internal server error: ${e.message}"
        }
      ]]></script>
    </actions>
  </service>

  <service verb="get" noun="UserInfo">
    <description>OAuth 2.0 user info endpoint</description>
    <out-parameters>
      <parameter name="sub" type="String" />
      <parameter name="user_id" type="String" />
      <parameter name="owner_party_id" type="String" />
      <parameter name="company_party_id" type="String" />
      <parameter name="user_party_id" type="String" />
      <parameter name="authenticated" type="Boolean" />
      <parameter name="error" type="String" />
      <parameter name="error_description" type="String" />
    </out-parameters>
    <actions>
      <script><![CDATA[
        try {
          // Validate current session/API key
          def authResult = ec.service.sync().name("McpAuthServices.validate#McpApiKey").call()
          
          if (authResult.authenticated) {
            sub = authResult.userId
            user_id = authResult.userId
            owner_party_id = authResult.ownerPartyId
            company_party_id = authResult.companyPartyId
            user_party_id = authResult.userPartyId
            authenticated = true
          } else {
            error = "invalid_token"
            error_description = authResult.errorMessage ?: "Invalid or expired token"
          }
          
        } catch (Exception e) {
          ec.logger.error("Userinfo error", e)
          error = "server_error"
          error_description = "Internal server error: ${e.message}"
        }
      ]]></script>
    </actions>
  </service>

  <service verb="get" noun="Jwks">
    <description>JSON Web Key Set endpoint</description>
    <out-parameters>
      <parameter name="keys" type="List" />
    </out-parameters>
    <actions>
      <script><![CDATA[
        // Simple JWKS response - since we use API keys, this is mostly for compliance
        keys = [
          [
            kty: "oct", // Symmetric key type for API keys
            use: "sig",
            kid: "api-key-1",
            alg: "HS256"
            // Note: We don't expose the actual key material
          ]
        ]
      ]]></script>
    </actions>
  </service>

  <service verb="check" noun="McpAuthorization">
    <description>Check if current user is authorized for MCP operations</description>
    <in-parameters>
      <parameter name="operation" type="String" default-value="read" />
      <parameter name="resource" type="String" default-value="mcp" />
      <parameter name="method" type="String" required="true" />
      <parameter name="requestId" type="Object" required="false" />
      <parameter name="enablePrompts" type="Boolean" default-value="true" />
    </in-parameters>
    <out-parameters>
      <parameter name="authorized" type="Boolean" />
      <parameter name="errorMessage" type="String" />
      <parameter name="authPrompt" type="Map" />
      <parameter name="requiresAuth" type="Boolean" />
    </out-parameters>
    <actions>
      <set field="authorized" value="false" />
      <set field="requiresAuth" value="false" />

      <!-- First, perform login using the API key -->
      <service-call name="McpAuthServices.validate#McpApiKey" out-map="authResult" />

      <if condition="!authResult.authenticated">
        <set field="requiresAuth" value="true" />
        <if condition="enablePrompts">
          <!-- Create authentication prompt for AI -->
          <service-call name="McpAuthServices.create#AuthPrompt"
            in-map="[requestId: requestId, operation: 'login', reason: authResult.errorMessage ?: 'API key required']"
            out-map="promptResult" />
          <set field="authPrompt" from="promptResult.promptResponse" />
          <else>
            <set field="errorMessage" from="authResult.errorMessage ?: 'Authentication required'" />
          </else>
        </if>
        <return />
      </if>

      <!-- At this point, the user is authenticated. Now check permissions. -->
      <if condition="operation == 'execute' || method == 'tools/call' || method == 'tools/execute'">
        <if condition="ec.user.hasPermission('MCP_EXECUTE') || ec.user.hasPermission('MCP_ADMIN')">
          <set field="authorized" value="true" />
          <else>
            <set field="errorMessage"
              value="MCP_EXECUTE or MCP_ADMIN permission required for tool execution" />
            <set field="authorized" value="false" />
          </else>
        </if>
        <else>
          <if condition="ec.user.hasPermission('MCP_VIEW') || ec.user.hasPermission('MCP_ADMIN')">
            <set field="authorized" value="true" />
            <else>
              <set field="errorMessage"
                value="MCP_VIEW or MCP_ADMIN permission required for this operation" />
              <set field="authorized" value="false" />
            </else>
          </if>
        </else>
      </if>
    </actions>
  </service>

</services>